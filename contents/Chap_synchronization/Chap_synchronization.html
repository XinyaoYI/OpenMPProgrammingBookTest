
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>7. Synchronization &#8212; OpenMP Application Programming Interface Examples</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="8. Data Environment" href="../Chap_data_environment/Chap_data_environment.html" />
    <link rel="prev" title="6. Loop Transformations" href="../Chap_loop_transformations/Chap_loop_transformations.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to OMP Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Title_Page.html">
   Cover
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Foreword_Chapt.html">
   Foreword
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_directives/0_Chap_directives.html">
   1. OpenMP Directive Syntax
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="simple">
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_parallel_execution/0_Chap_parallel_execution.html">
   2. Parallel Execution
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/1_A_Simple_Parallel_Loop.html">
     2.1. A Simple Parallel Loop
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/2_parallel_Construct.html">
     2.2.
     <strong>
      parallel
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/3_teams_Construct_on_Host.html">
     2.3.
     <strong>
      teams
     </strong>
     Construct on Host
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/4_Controlling_the_Number_of_Threads_on_Multiple_Nesting_Levels.html">
     2.4. Controlling the Number of Threads on Multiple Nesting Levels
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/5_Interaction_Between_the_num_threads_Clause_and_omp_set_dynamic.html">
     2.5. Interaction Between the
     <strong>
      num_threads
     </strong>
     Clause and
     <strong>
      omp_set_dynamic
     </strong>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/6_Fortran_Restrictions_on_the_do_Construct.html">
     2.6. Fortran Restrictions on the
     <strong>
      do
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/7_nowait_Clause.html">
     2.7.
     <strong>
      nowait
     </strong>
     Clause
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/8_collapse_Clause.html">
     2.8.
     <strong>
      collapse
     </strong>
     Clause
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/9_linear_Clause_in_Loop_Constructs.html">
     2.9.
     <strong>
      linear
     </strong>
     Clause in Loop Constructs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/10_parallel_sections_Construct.html">
     2.10.
     <strong>
      parallel
     </strong>
     <strong>
      sections
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/11_firstprivate_Clause_and_sections_Construct.html">
     2.11.
     <strong>
      firstprivate
     </strong>
     Clause and
     <strong>
      sections
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/12_single_Construct.html">
     2.12.
     <strong>
      single
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/13_workshare_Construct.html">
     2.13.
     <strong>
      workshare
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/14_masked_Construct.html">
     2.14.
     <strong>
      masked
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/15_loop_Construct.html">
     2.15.
     <strong>
      loop
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/16_Parallel_Random_Access_Iterator_Loop.html">
     2.16. Parallel Random Access Iterator Loop
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/17_omp_set_dynamic_and_omp_set_num_threads_Routines.html">
     2.17.
     <strong>
      omp_set_dynamic
     </strong>
     and
     <strong>
      omp_set_num_threads
     </strong>
     Routines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/18_omp_get_num_threads_Routine.html">
     2.18.
     <strong>
      omp_get_num_threads
     </strong>
     Routine
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_tasking/0_Chap_tasking.html">
   3. Tasking
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/1_task_and_taskwait_Constructs.html">
     3.1.
     <strong>
      task
     </strong>
     and
     <strong>
      taskwait
     </strong>
     Constructs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/2_Task_Priority.html">
     3.2. Task Priority
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/3_Task_Dependences.html">
     3.3. Task Dependences
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/4_Task_Detachment.html">
     3.4. Task Detachment
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/5_taskgroup_Construct.html">
     3.5.
     <strong>
      taskgroup
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/6_taskyield_Construct.html">
     3.6.
     <strong>
      taskyield
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/7_taskloop_Construct.html">
     3.7.
     <strong>
      taskloop
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/8_Combined_parallel_masked_and_taskloop_Constructs.html">
     3.8. Combined
     <strong>
      parallel
     </strong>
     <strong>
      masked
     </strong>
     and
     <strong>
      taskloop
     </strong>
     Constructs
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_devices/Chap_devices.html">
   4. Devices
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_SIMD/Chap_SIMD.html">
   5. SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_loop_transformations/Chap_loop_transformations.html">
   6. Loop Transformations
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   7. Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_data_environment/Chap_data_environment.html">
   8. Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_memory_model/Chap_memory_model.html">
   9. Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_program_control/Chap_program_control.html">
   10. Program Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_ompt_interface/Chap_ompt_interface.html">
   11. OMPT Interface
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_synchronization/Chap_synchronization.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/passlab/Examples"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_synchronization/Chap_synchronization.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../_sources/contents/Chap_synchronization/Chap_synchronization.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#critical-construct">
   7.1.
   <strong>
    critical
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#worksharing-constructs-inside-a-critical-construct">
   7.2. Worksharing Constructs Inside a
   <strong>
    critical
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#binding-of-barrier-regions">
   7.3. Binding of
   <strong>
    barrier
   </strong>
   Regions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#atomic-construct">
   7.4.
   <strong>
    atomic
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#restrictions-on-the-atomic-construct">
   7.5. Restrictions on the
   <strong>
    atomic
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#flush-construct-without-a-list">
   7.6.
   <strong>
    flush
   </strong>
   Construct without a List
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#synchronization-based-on-acquire-release-semantics">
   7.7. Synchronization Based on Acquire/Release Semantics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ordered-clause-and-ordered-construct">
   7.8.
   <strong>
    ordered
   </strong>
   Clause and
   <strong>
    ordered
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#depobj-construct">
   7.9.
   <strong>
    depobj
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#doacross-loop-nest">
   7.10. Doacross Loop Nest
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lock-routines">
   7.11. Lock Routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-init-lock-routine">
     7.11.1.
     <strong>
      omp_init_lock
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-init-lock-with-hint-routine">
     7.11.2.
     <strong>
      omp_init_lock_with_hint
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ownership-of-locks">
     7.11.3. Ownership of Locks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-lock-routines">
     7.11.4. Simple Lock Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nestable-lock-routines">
     7.11.5. Nestable Lock Routines
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Synchronization</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#critical-construct">
   7.1.
   <strong>
    critical
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#worksharing-constructs-inside-a-critical-construct">
   7.2. Worksharing Constructs Inside a
   <strong>
    critical
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#binding-of-barrier-regions">
   7.3. Binding of
   <strong>
    barrier
   </strong>
   Regions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#atomic-construct">
   7.4.
   <strong>
    atomic
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#restrictions-on-the-atomic-construct">
   7.5. Restrictions on the
   <strong>
    atomic
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#flush-construct-without-a-list">
   7.6.
   <strong>
    flush
   </strong>
   Construct without a List
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#synchronization-based-on-acquire-release-semantics">
   7.7. Synchronization Based on Acquire/Release Semantics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ordered-clause-and-ordered-construct">
   7.8.
   <strong>
    ordered
   </strong>
   Clause and
   <strong>
    ordered
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#depobj-construct">
   7.9.
   <strong>
    depobj
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#doacross-loop-nest">
   7.10. Doacross Loop Nest
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lock-routines">
   7.11. Lock Routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-init-lock-routine">
     7.11.1.
     <strong>
      omp_init_lock
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-init-lock-with-hint-routine">
     7.11.2.
     <strong>
      omp_init_lock_with_hint
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ownership-of-locks">
     7.11.3. Ownership of Locks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-lock-routines">
     7.11.4. Simple Lock Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nestable-lock-routines">
     7.11.5. Nestable Lock Routines
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="synchronization">
<h1><span class="section-number">7. </span>Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline">#</a></h1>
<p>The <strong>barrier</strong> construct is a stand-alone directive that requires all threads of a team (within a contention group) to execute the barrier and complete execution of all tasks within the region, before continuing past the barrier.</p>
<p>The <strong>critical</strong> construct is a directive that contains a structured block.  The construct allows only a single thread at a time to execute the structured block (region). Multiple critical regions may exist in a parallel region, and may act cooperatively (only one thread at a time in all <strong>critical</strong> regions), or separately (only one thread at a time in each <strong>critical</strong> regions when a unique name is supplied on each <strong>critical</strong> construct). An optional (lock) <strong>hint</strong> clause may be specified on a named <strong>critical</strong>  construct to provide the OpenMP runtime guidance in selection a locking  mechanism.</p>
<p>On a finer scale the <strong>atomic</strong> construct allows only a single thread at  a time to have atomic access to a storage location involving a single read,  write, update or capture statement, and a limited number of combinations  when specifying the <strong>capture</strong>  <em>atomic-clause</em>  clause.  The  <em>atomic-clause</em>  clause is required for some expression statements, but is not required for <strong>update</strong> statements. The  <em>memory-order</em>  clause can be used to specify the degree of memory ordering enforced by an <strong>atomic</strong> construct. From weakest to strongest, they are <strong>relaxed</strong> (the default), acquire and/or release clauses (specified with <strong>acquire</strong>, <strong>release</strong>, or <strong>acq_rel</strong>), and <strong>seq_cst</strong>.  Please see the details in the  <em>atomic Construct</em>  subsection of the  <em>Directives</em>  chapter in the OpenMP Specifications document.</p>
<p>The <strong>ordered</strong> construct either specifies a structured block in a loop,  simd, or loop SIMD region that will be executed in the order of the loop  iterations.  The ordered construct sequentializes and orders the execution  of ordered regions while allowing code outside the region to run in parallel.</p>
<p>Since OpenMP 4.5 the <strong>ordered</strong> construct can also be a stand-alone  directive that specifies cross-iteration dependences in a doacross loop nest.   The <strong>depend</strong> clause uses a <strong>sink</strong>  <em>dependence-type</em> , along with an  iteration vector argument (vec) to indicate the iteration that satisfies the  dependence.  The <strong>depend</strong> clause with a <strong>source</strong>  <em>dependence-type</em>  specifies dependence satisfaction.</p>
<p>The <strong>flush</strong> directive is a stand-alone construct for enforcing consistency between a thread’s view of memory and the view of memory for other threads (see the Memory Model chapter of this document for more details). When the construct is used with an explicit variable list, a  <em>strong flush</em>  that forces a thread’s temporary view of memory to be consistent with the actual memory is applied to all listed variables. When the construct is used without an explicit variable list and without a  <em>memory-order</em>  clause, a strong flush is applied to all locally thread-visible data as defined by the base language, and additionally the construct provides both acquire and release memory ordering semantics.  When an explicit variable list is not present and a  <em>memory-order</em>  clause is present, the construct provides acquire and/or release memory ordering semantics according to the  <em>memory-order</em>  clause, but no strong flush is performed. A resulting strong flush that applies to a set of variables effectively ensures that no memory (load or store) operation for the affected variables may be reordered across the <strong>flush</strong> directive.</p>
<p>General-purpose routines provide mutual exclusion semantics through locks,  represented by lock variables.   The semantics allows a task to  <em>set</em> , and hence   <em>own</em>  a lock, until it is  <em>unset</em>  by the task that set it. A   <em>nestable</em>  lock can be set multiple times by a task, and is used when in code requires nested control of locks.  A  <em>simple lock</em>  can only be set once by the owning task. There are specific calls for the two types of locks, and the variable of a specific lock type cannot be used by the other lock type.</p>
<p>Any explicit task will observe the synchronization prescribed in a  <strong>barrier</strong> construct and an implied barrier.  Also, additional synchronizations  are available for tasks.  All children of a task will wait at a <strong>taskwait</strong> (for  their siblings to complete).  A <strong>taskgroup</strong> construct creates a region in which the current task is suspended at the end of the region until all sibling tasks,  and their descendants, have completed.  Scheduling constraints on task execution can be prescribed by the <strong>depend</strong> clause to enforce dependence on previously generated tasks. More details on controlling task executions can be found in the  <em>Tasking</em>  Chapter in the OpenMP Specifications document.</p>
<section id="critical-construct">
<h2><span class="section-number">7.1. </span><strong>critical</strong> Construct<a class="headerlink" href="#critical-construct" title="Permalink to this headline">#</a></h2>
<p>The following example includes several <strong>critical</strong> constructs. The example  illustrates a queuing model in which a task is dequeued and worked on. To guard  against multiple threads dequeuing the same task, the dequeuing operation must  be in a <strong>critical</strong> region. Because the two queues in this example are independent,  they are protected by <strong>critical</strong> constructs with different names,  <em>xaxis</em>   and  <em>yaxis</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: critical.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">dequeue</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">critical_example</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ix_next</span><span class="p">,</span><span class="w"> </span><span class="n">iy_next</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel shared(x, y) private(ix_next, iy_next)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp critical (xaxis)</span>
<span class="w">      </span><span class="n">ix_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">work</span><span class="p">(</span><span class="n">ix_next</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cp">#pragma omp critical (yaxis)</span>
<span class="w">      </span><span class="n">iy_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">work</span><span class="p">(</span><span class="n">iy_next</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">critical</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">CRITICAL_EXAMPLE</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">REAL</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">IX_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">IY_NEXT</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SHARED</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"> </span><span class="n">PRIVATE</span><span class="p">(</span><span class="n">IX_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">IY_NEXT</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">CRITICAL</span><span class="p">(</span><span class="n">XAXIS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">DEQUEUE</span><span class="p">(</span><span class="n">IX_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">CRITICAL</span><span class="p">(</span><span class="n">XAXIS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">IX_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">CRITICAL</span><span class="p">(</span><span class="n">YAXIS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">DEQUEUE</span><span class="p">(</span><span class="n">IY_NEXT</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">CRITICAL</span><span class="p">(</span><span class="n">YAXIS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">IY_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">CRITICAL_EXAMPLE</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example extends the previous example by adding the <strong>hint</strong> clause to the <strong>critical</strong> constructs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: critical.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">dequeue</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">critical_example</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ix_next</span><span class="p">,</span><span class="w"> </span><span class="n">iy_next</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel shared(x, y) private(ix_next, iy_next)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp critical (xaxis) hint(omp_sync_hint_contended)</span>
<span class="w">      </span><span class="n">ix_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">work</span><span class="p">(</span><span class="n">ix_next</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cp">#pragma omp critical (yaxis) hint(omp_sync_hint_contended)</span>
<span class="w">      </span><span class="n">iy_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">work</span><span class="p">(</span><span class="n">iy_next</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">critical</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">CRITICAL_EXAMPLE</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">INCLUDE</span><span class="w"> </span><span class="s">&quot;omp_lib.h&quot;</span><span class="w"></span>

<span class="w">        </span><span class="n">REAL</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">IX_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">IY_NEXT</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SHARED</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"> </span><span class="n">PRIVATE</span><span class="p">(</span><span class="n">IX_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">IY_NEXT</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">CRITICAL</span><span class="p">(</span><span class="n">XAXIS</span><span class="p">)</span><span class="w"> </span><span class="n">HINT</span><span class="p">(</span><span class="n">OMP_SYNC_HINT_CONTENDED</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">DEQUEUE</span><span class="p">(</span><span class="n">IX_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">CRITICAL</span><span class="p">(</span><span class="n">XAXIS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">IX_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">CRITICAL</span><span class="p">(</span><span class="n">YAXIS</span><span class="p">)</span><span class="w"> </span><span class="n">HINT</span><span class="p">(</span><span class="n">OMP_SYNC_HINT_CONTENDED</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">DEQUEUE</span><span class="p">(</span><span class="n">IY_NEXT</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">CRITICAL</span><span class="p">(</span><span class="n">YAXIS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">IY_NEXT</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">CRITICAL_EXAMPLE</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="worksharing-constructs-inside-a-critical-construct">
<h2><span class="section-number">7.2. </span>Worksharing Constructs Inside a <strong>critical</strong> Construct<a class="headerlink" href="#worksharing-constructs-inside-a-critical-construct" title="Permalink to this headline">#</a></h2>
<p>The following example demonstrates using a worksharing construct inside a <strong>critical</strong>  construct. This example is conforming because the worksharing <strong>single</strong>   region is not closely nested inside the <strong>critical</strong> region. A single thread  executes the one and only section in the <strong>sections</strong> region, and executes  the <strong>critical</strong> region. The same thread encounters the nested <strong>parallel</strong>  region, creates a new team of threads, and becomes the primary thread of the new team.  One of the threads in the new team enters the <strong>single</strong> region and increments  <strong>i</strong> by <strong>1</strong>. At the end of this example <strong>i</strong> is equal to <strong>2</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: worksharing_critical.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">critical_work</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel sections</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp section</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp critical (name)</span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#pragma omp parallel</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="cp">#pragma omp single</span>
<span class="w">          </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">worksharing_critical</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">CRITICAL_WORK</span><span class="p">()</span><span class="w"></span>

<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">        </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SECTIONS</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">SECTION</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">CRITICAL</span><span class="w"> </span><span class="p">(</span><span class="n">NAME</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">         </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">           </span><span class="n">SINGLE</span><span class="w"></span>
<span class="w">                  </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">           </span><span class="n">END</span><span class="w"> </span><span class="n">SINGLE</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">         </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">END</span><span class="w"> </span><span class="n">CRITICAL</span><span class="w"> </span><span class="p">(</span><span class="n">NAME</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SECTIONS</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">CRITICAL_WORK</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="binding-of-barrier-regions">
<h2><span class="section-number">7.3. </span>Binding of <strong>barrier</strong> Regions<a class="headerlink" href="#binding-of-barrier-regions" title="Permalink to this headline">#</a></h2>
<p>The binding rules call for a <strong>barrier</strong> region to bind to the closest enclosing  <strong>parallel</strong> region.</p>
<p>In the following example, the call from the main program to  <em>sub2</em>  is conforming  because the <strong>barrier</strong> region (in  <em>sub3</em> ) binds to the <strong>parallel</strong>  region in  <em>sub2</em> . The call from the main program to  <em>sub1</em>  is conforming  because the <strong>barrier</strong> region binds to the <strong>parallel</strong> region in subroutine   <em>sub2</em> .</p>
<p>The call from the main program to  <em>sub3</em>  is conforming because the <strong>barrier</strong>  region binds to the implicit inactive <strong>parallel</strong> region enclosing the sequential  part. Also note that the <strong>barrier</strong> region in  <em>sub3</em>  when called from   <em>sub2</em>  only synchronizes the team of threads in the enclosing <strong>parallel</strong>  region and not all the threads created in  <em>sub1</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: barrier_regions.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">sub3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">work</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp barrier</span>
<span class="w">  </span><span class="n">work</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">sub2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel shared(k)</span>
<span class="w">    </span><span class="n">sub3</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">sub1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel private(i) shared(n)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">sub2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">sub1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">sub2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">sub3</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">barrier_regions</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB3</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB3</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB2</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">K</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SHARED</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB3</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB2</span><span class="w"></span>


<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB1</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">PRIVATE</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="n">SHARED</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">DO</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB2</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB1</span><span class="w"></span>

<span class="w">      </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">EXAMPLE</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB2</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB3</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">EXAMPLE</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="atomic-construct">
<h2><span class="section-number">7.4. </span><strong>atomic</strong> Construct<a class="headerlink" href="#atomic-construct" title="Permalink to this headline">#</a></h2>
<p>The following example avoids race conditions (simultaneous updates of an element  of  <em>x</em>  by multiple threads) by using the <strong>atomic</strong> construct .</p>
<p>The advantage of using the <strong>atomic</strong> construct in this example is that it  allows updates of two different elements of  <em>x</em>  to occur in parallel. If  a <strong>critical</strong> construct were used instead, then all updates to elements of   <em>x</em>  would be executed serially (though not in any guaranteed order).</p>
<p>Note that the <strong>atomic</strong> directive applies only to the statement immediately  following it. As a result, elements of  <em>y</em>  are not updated atomically in  this example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: atomic.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">work1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">float</span><span class="w"> </span><span class="nf">work2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">atomic_example</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel for shared(x, y, index, n)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp atomic update</span>
<span class="w">      </span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">work1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">work2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">10000</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">[</span><span class="mi">10000</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">atomic_example</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">atomic</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="w">      </span><span class="n">REAL</span><span class="w"> </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">WORK1</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">        </span><span class="n">WORK1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">        </span><span class="n">RETURN</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">WORK1</span><span class="w"></span>

<span class="w">      </span><span class="n">REAL</span><span class="w"> </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">WORK2</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">        </span><span class="n">WORK2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">        </span><span class="n">RETURN</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">WORK2</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">INDEX</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">REAL</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">INDEX</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DO</span><span class="w"> </span><span class="n">SHARED</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">INDEX</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"></span>
<span class="w">              </span><span class="n">X</span><span class="p">(</span><span class="n">INDEX</span><span class="p">(</span><span class="n">I</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">INDEX</span><span class="p">(</span><span class="n">I</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">WORK1</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">Y</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">WORK2</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">ENDDO</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB</span><span class="w"></span>

<span class="w">      </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">ATOMIC_EXAMPLE</span><span class="w"></span>
<span class="w">        </span><span class="n">REAL</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">INDEX</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>

<span class="w">        </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">10000</span><span class="w"></span>
<span class="w">          </span><span class="n">INDEX</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MOD</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">Y</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"></span>
<span class="w">        </span><span class="n">ENDDO</span><span class="w"></span>

<span class="w">        </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="w"></span>
<span class="w">          </span><span class="n">X</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"></span>
<span class="w">        </span><span class="n">ENDDO</span><span class="w"></span>

<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">INDEX</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">ATOMIC_EXAMPLE</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example illustrates the <strong>read</strong> and <strong>write</strong>  clauses  for the <strong>atomic</strong> directive. These clauses ensure that the given variable  is read or written, respectively, as a whole. Otherwise, some other thread might  read or write part of the variable while the current thread was reading or writing  another part of the variable. Note that most hardware provides atomic reads and  writes for some set of properly aligned variables of specific sizes, but not necessarily  for all the variable types supported by the OpenMP API.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: atomic.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">atomic_read</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="cm">/* Guarantee that the entire value of *p is read atomically. No part of</span>
<span class="cm"> * *p can change during the read operation.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#pragma omp atomic read</span>
<span class="w">     </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">atomic_write</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cm">/* Guarantee that value is stored atomically into *p. No part of *p can</span>
<span class="cm">change</span>
<span class="cm"> * until after the entire write operation is completed.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#pragma omp atomic write</span>
<span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">atomic</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="w">       </span><span class="n">function</span><span class="w"> </span><span class="n">atomic_read</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">atomic_read</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">Guarantee</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">entire</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">atomically</span><span class="p">.</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="n">of</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="n">during</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">operation</span><span class="p">.</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">read</span><span class="w"></span>
<span class="w">       </span><span class="n">atomic_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">       </span><span class="k">return</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">atomic_read</span><span class="w"></span>

<span class="w">       </span><span class="n">subroutine</span><span class="w"> </span><span class="n">atomic_write</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">Guarantee</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">stored</span><span class="w"> </span><span class="n">atomically</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">change</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">entire</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">completed</span><span class="p">.</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"></span>
<span class="w">       </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">atomic_write</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example illustrates the <strong>capture</strong> clause for the <strong>atomic</strong>  directive. In this case the value of a variable is captured, and then the variable  is incremented. These operations occur atomically. This example could  be implemented using the fetch-and-add instruction available on many kinds of hardware.  The example also shows a way to implement a spin lock using the <strong>capture</strong>   and <strong>read</strong> clauses.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: atomic.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">fetch_and_add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cm">/* Atomically read the value of *p and then increment it. The</span>
<span class="cm">      previous value is returned. This can be used to implement a</span>
<span class="cm">      simple lock as shown below.</span>
<span class="cm">    */</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">old</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp atomic capture</span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">old</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Use fetch_and_add to implement a lock</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">locktype</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">ticketnumber</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">turn</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">do_locked_work</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">locktype</span><span class="w"> </span><span class="o">*</span><span class="n">lock</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">atomic_read</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="n">work</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Obtain the lock</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">myturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ticketnumber</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">turn</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">myturn</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Do some work. The flush is needed to ensure visibility of</span>
<span class="w">   </span><span class="c1">// variables not involved in atomic directives</span>

<span class="w">   </span><span class="cp">#pragma omp flush</span>
<span class="w">   </span><span class="n">work</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp flush</span>
<span class="w">   </span><span class="c1">// Release the lock</span>
<span class="w">   </span><span class="n">fetch_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">turn</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">atomic</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="w">       </span><span class="n">function</span><span class="w"> </span><span class="n">fetch_and_add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="o">::</span><span class="w"> </span><span class="n">fetch_and_add</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">Atomically</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">returned</span><span class="p">.</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">implement</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">simple</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">shown</span><span class="w"> </span><span class="n">below</span><span class="p">.</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">capture</span><span class="w"></span>
<span class="w">       </span><span class="n">fetch_and_add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">       </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">atomic</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">fetch_and_add</span><span class="w"></span>
<span class="w">       </span><span class="n">module</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">       </span><span class="n">interface</span><span class="w"></span>
<span class="w">         </span><span class="n">function</span><span class="w"> </span><span class="n">fetch_and_add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">fetch_and_add</span><span class="w"></span>
<span class="w">           </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>
<span class="w">         </span><span class="n">function</span><span class="w"> </span><span class="n">atomic_read</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">atomic_read</span><span class="w"></span>
<span class="w">           </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"> </span><span class="n">interface</span><span class="w"></span>
<span class="w">       </span><span class="n">type</span><span class="w"> </span><span class="n">locktype</span><span class="w"></span>
<span class="w">          </span><span class="n">integer</span><span class="w"> </span><span class="n">ticketnumber</span><span class="w"></span>
<span class="w">          </span><span class="n">integer</span><span class="w"> </span><span class="n">turn</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="w">       </span><span class="n">contains</span><span class="w"></span>
<span class="w">       </span><span class="n">subroutine</span><span class="w"> </span><span class="n">do_locked_work</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">type</span><span class="p">(</span><span class="n">locktype</span><span class="p">),</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">lock</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="w"> </span><span class="n">myturn</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="w"> </span><span class="n">junk</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">obtain</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">lock</span><span class="w"></span>
<span class="w">        </span><span class="n">myturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_and_add</span><span class="p">(</span><span class="n">lock</span><span class="o">%</span><span class="n">ticketnumber</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">lock</span><span class="o">%</span><span class="n">turn</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">ne</span><span class="p">.</span><span class="w"> </span><span class="n">myturn</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="w"></span>
<span class="w">        </span><span class="n">enddo</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">work</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">flush</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">needed</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">ensure</span><span class="w"> </span><span class="n">visibility</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">variables</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">involved</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">directives</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="w"></span>
<span class="w">       </span><span class="n">call</span><span class="w"> </span><span class="n">work</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">Release</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">lock</span><span class="w"></span>
<span class="w">       </span><span class="n">junk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_and_add</span><span class="p">(</span><span class="n">lock</span><span class="o">%</span><span class="n">turn</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="restrictions-on-the-atomic-construct">
<h2><span class="section-number">7.5. </span>Restrictions on the <strong>atomic</strong> Construct<a class="headerlink" href="#restrictions-on-the-atomic-construct" title="Permalink to this headline">#</a></h2>
<p>The following non-conforming examples illustrate the restrictions on the <strong>atomic</strong>  construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: atomic_restrict.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">atomic_wrong</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;}</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp parallel</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp atomic update</span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">n</span><span class="o">++</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp atomic update</span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* Incorrect because the atomic constructs reference the same location</span>
<span class="cm">   through incompatible types */</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">atomic_restrict</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ATOMIC_WRONG</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="o">::</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">        </span><span class="n">REAL</span><span class="o">::</span><span class="w"> </span><span class="n">R</span><span class="w"></span>
<span class="w">        </span><span class="n">EQUIVALENCE</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">R</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"></span>
<span class="w">            </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"></span>
<span class="w">            </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">location</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">different</span><span class="w"> </span><span class="n">types</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ATOMIC_WRONG</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: atomic_restrict.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">atomic_wrong2</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="kt">float</span><span class="w">   </span><span class="o">*</span><span class="n">r</span><span class="p">;</span><span class="w"></span>

<span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp parallel</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp atomic update</span>
<span class="w">    </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp atomic update</span>
<span class="w">    </span><span class="o">*</span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* Incorrect because the atomic constructs reference the same location</span>
<span class="cm">   through incompatible types */</span><span class="w"></span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because <strong>I</strong> and <strong>R</strong> reference  the same location but have different types.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">atomic_restrict</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">COMMON</span><span class="w"> </span><span class="o">/</span><span class="n">BLK</span><span class="o">/</span><span class="w"> </span><span class="n">R</span><span class="w"></span>
<span class="w">        </span><span class="n">REAL</span><span class="w"> </span><span class="n">R</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"></span>
<span class="w">          </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ATOMIC_WRONG2</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">COMMON</span><span class="w"> </span><span class="o">/</span><span class="n">BLK</span><span class="o">/</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"></span>
<span class="w">            </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB</span><span class="p">()</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ATOMIC_WRONG2</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>Although the following example might work on some implementations, this is also  non-conforming:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">atomic_restrict</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ATOMIC_WRONG3</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="o">::</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">        </span><span class="n">REAL</span><span class="o">::</span><span class="w"> </span><span class="n">R</span><span class="w"></span>
<span class="w">        </span><span class="n">EQUIVALENCE</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">R</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"></span>
<span class="w">            </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">location</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">different</span><span class="w"> </span><span class="n">types</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"></span>
<span class="w">            </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">location</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">different</span><span class="w"> </span><span class="n">types</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ATOMIC_WRONG3</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="flush-construct-without-a-list">
<h2><span class="section-number">7.6. </span><strong>flush</strong> Construct without a List<a class="headerlink" href="#flush-construct-without-a-list" title="Permalink to this headline">#</a></h2>
<p>The following example distinguishes the shared variables affected by a <strong>flush</strong>  construct with no list from the shared objects that are not affected:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: flush_nolist.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp flush</span>
<span class="w">  </span><span class="cm">/* x, p, and *q are flushed */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* because they are shared and accessible */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* q is not flushed because it is not shared. */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp barrier</span>
<span class="w">  </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp barrier</span>

<span class="w">  </span><span class="cm">/* a barrier implies a flush */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* x, p, and *q are flushed */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* because they are shared and accessible */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* q is not flushed because it is not shared. */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel reduction(+: sum) num_threads(10)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">f1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* i, n and sum were not flushed */</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* because they were not accessible in f1 */</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* j was flushed because it was accessible */</span><span class="w"></span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">f2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* i, n, and sum were not flushed */</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* because they were not accessible in f2 */</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* j was flushed because it was accessible */</span><span class="w"></span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">flush_nolist</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">F1</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">COMMON</span><span class="w"> </span><span class="o">/</span><span class="n">DATA</span><span class="o">/</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">TARGET</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">POINTER</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">Q</span><span class="w"></span>

<span class="w">        </span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">FLUSH</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">flushed</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">they</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">accessible</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">F1</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">F2</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">COMMON</span><span class="w"> </span><span class="o">/</span><span class="n">DATA</span><span class="o">/</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">TARGET</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">POINTER</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">Q</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">          </span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">          </span><span class="o">!</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">implies</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">flush</span><span class="w"></span>
<span class="w">          </span><span class="o">!</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">flushed</span><span class="w"></span>
<span class="w">          </span><span class="o">!</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">they</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">accessible</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">F2</span><span class="w"></span>

<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">G</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">COMMON</span><span class="w"> </span><span class="o">/</span><span class="n">DATA</span><span class="o">/</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">TARGET</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">POINTER</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">J</span><span class="p">,</span><span class="w"> </span><span class="n">SUM</span><span class="w"></span>

<span class="w">        </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="n">SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">REDUCTION</span><span class="p">(</span><span class="o">+:</span><span class="w"> </span><span class="n">SUM</span><span class="p">)</span><span class="w"> </span><span class="n">NUM_THREADS</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">F1</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">SUM</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">flushed</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="w">   </span><span class="n">because</span><span class="w"> </span><span class="n">they</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">accessible</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">F1</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">flushed</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">accessible</span><span class="w"></span>
<span class="w">          </span><span class="n">SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SUM</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J</span><span class="w"></span>

<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">F2</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">SUM</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">flushed</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="w">   </span><span class="n">because</span><span class="w"> </span><span class="n">they</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">accessible</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">f2</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">flushed</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">accessible</span><span class="w"></span>
<span class="w">          </span><span class="n">SUM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SUM</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="w">        </span><span class="n">G</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SUM</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">G</span><span class="w"></span>

<span class="w">      </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">FLUSH_NOLIST</span><span class="w"></span>
<span class="w">        </span><span class="n">COMMON</span><span class="w"> </span><span class="o">/</span><span class="n">DATA</span><span class="o">/</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">TARGET</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">POINTER</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">RESULT</span><span class="p">,</span><span class="w"> </span><span class="n">G</span><span class="w"></span>

<span class="w">        </span><span class="n">P</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">        </span><span class="n">RESULT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">PRINT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">RESULT</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">FLUSH_NOLIST</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="synchronization-based-on-acquire-release-semantics">
<h2><span class="section-number">7.7. </span>Synchronization Based on Acquire/Release Semantics<a class="headerlink" href="#synchronization-based-on-acquire-release-semantics" title="Permalink to this headline">#</a></h2>
<p>As explained in the Memory Model chapter of this document, a flush operation may be an <strong>acquire flush</strong> and/or a <strong>release flush</strong>, and OpenMP 5.0 defines acquire/release semantics in terms of these fundamental flush operations.  For any synchronization between two threads that is specified by OpenMP, a release flush logically occurs at the source of the synchronization and an acquire flush logically occurs at the sink of the synchronization. OpenMP 5.0 added memory ordering clauses - <strong>acquire</strong>, <strong>release</strong>, and <strong>acq_rel</strong> - to the <strong>flush</strong> and <strong>atomic</strong> constructs for explicitly requesting acquire/release semantics.  Furthermore, implicit flushes for all OpenMP constructs and runtime routines that synchronize OpenMP threads in some manner were redefined in terms of synchronizing release and acquire flushes to avoid the requirement of strong memory fences (see the  <em>Flush Synchronization and Happens Before</em>  and  <em>Implicit Flushes</em>  sections of the OpenMP Specifications document).</p>
<p>The examples that follow in this section illustrate how acquire and release flushes may be employed, implicitly or explicitly, for synchronizing threads. A <strong>flush</strong> directive without a list and without any memory ordering clause can also function as both an acquire and release flush for facilitating thread synchronization.  Flushes implied on entry to, or exit from, an atomic operation (specified by an <strong>atomic</strong> construct) may function as an acquire flush or a release flush if a memory ordering clause appears on the construct. On entry to and exit from a <strong>critical</strong> construct there is now an implicit acquire flush and release flush, respectively.</p>
<p>The first example illustrates how the release and acquire flushes implied by a <strong>critical</strong> region guarantee a value written by the first thread is visible to a read of the value on the second thread. Thread 0 writes to  <em>x</em>  and then executes a <strong>critical</strong> region in which it writes to  <em>y</em> ; the write to  <em>x</em>  happens before the execution of the <strong>critical</strong> region, consistent with the program order of the thread.  Meanwhile, thread 1 executes a <strong>critical</strong> region in a loop until it reads a non-zero value from  <em>y</em>  in the <strong>critical</strong> region, after which it prints the value of  <em>x</em> ; again, the execution of the <strong>critical</strong> regions happen before the read from  <em>x</em>  based on the program order of the thread. The <strong>critical</strong> regions executed by the two threads execute in a serial manner, with a pairwise synchronization from the exit of one <strong>critical</strong> region to the entry to the next <strong>critical</strong> region.  These pairwise synchronizations result from the implicit release flushes that occur on exit from <strong>critical</strong> regions and the implicit acquire flushes that occur on entry to <strong>critical</strong> regions; hence, the execution of each <strong>critical</strong> region in the sequence happens before the execution of the next <strong>critical</strong> region. A “happens before’’ order is therefore established between the assignment to  <em>x</em>  by thread 0 and the read from  <em>x</em>  by thread 1, and so thread 1 must see that  <em>x</em>  equals 10.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: acquire_release.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">thrd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thrd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp critical</span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="cp">#pragma omp critical</span>
<span class="w">           </span><span class="p">{</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// always &quot;x = 10&quot;</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">acquire_release</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">rel_acq_ex1</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">thrd</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">   </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">thrd</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">thrd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thrd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">         </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">         </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">         </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">            </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="o">!!</span><span class="w"> </span><span class="n">always</span><span class="w"> </span><span class="s">&quot;x = 10&quot;</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">if</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the second example, the <strong>critical</strong> constructs are exchanged with <strong>atomic</strong> constructs that have <em>explicit</em> memory ordering specified. When the atomic read operation on thread 1 reads a non-zero value from  <em>y</em> , this results in a release/acquire synchronization that in turn implies that the assignment to  <em>x</em>  on thread 0 happens before the read of  <em>x</em>  on thread 1. Therefore, thread 1 will print “x = 10’’.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: acquire_release.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">thrd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span><span class="w"></span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thrd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="cp">#pragma omp atomic write release </span><span class="c1">// or seq_cst</span>
<span class="w">          </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#pragma omp atomic read acquire </span><span class="c1">// or seq_cst</span>
<span class="w">            </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// always &quot;x = 10&quot;</span>
<span class="w">       </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">acquire_release</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">rel_acq_ex2</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">thrd</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">   </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">thrd</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">thrd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thrd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">         </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="n">release</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">seq_cst</span><span class="w"></span>
<span class="w">          </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">atomic</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">         </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">acquire</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">seq_cst</span><span class="w"></span>
<span class="w">            </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">atomic</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="o">!!</span><span class="w"> </span><span class="n">always</span><span class="w"> </span><span class="s">&quot;x = 10&quot;</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">if</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the third example, <strong>atomic</strong> constructs that specify relaxed atomic operations are used with explicit <strong>flush</strong> directives to enforce memory ordering between the two threads. The explicit <strong>flush</strong> directive on thread 0 must specify a release flush and the explicit <strong>flush</strong> directive on thread 1 must specify an acquire flush to establish a release/acquire synchronization between the two threads. The <strong>flush</strong> and <strong>atomic</strong> constructs encountered by thread 0 can be replaced by the <strong>atomic</strong> construct used in Example 2 for thread 0, and similarly the <strong>flush</strong> and <strong>atomic</strong> constructs encountered by thread 1 can be replaced by the <strong>atomic</strong> construct used in Example 2 for thread 1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: acquire_release.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">thrd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thrd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp flush </span><span class="c1">// or with acq_rel or release clause</span>
<span class="w">         </span><span class="cp">#pragma omp atomic write </span><span class="c1">// or with relaxed clause</span>
<span class="w">         </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="cp">#pragma omp atomic read </span><span class="c1">// or with relaxed clause</span>
<span class="w">           </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp flush </span><span class="c1">// or with acq_rel or acquire clause</span>
<span class="w">         </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w">  </span><span class="c1">// always &quot;x = 10&quot;</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">acquire_release</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">rel_acq_ex3</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">thrd</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">   </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">thrd</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">thrd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thrd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">         </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">acq_rel</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">release</span><span class="w"> </span><span class="n">clause</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"></span>
<span class="w">         </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">atomic</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">         </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">read</span><span class="w"></span>
<span class="w">            </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">atomic</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">acq_rel</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">acquire</span><span class="w"> </span><span class="n">clause</span><span class="w"></span>
<span class="w">         </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="o">!!</span><span class="w"> </span><span class="n">always</span><span class="w"> </span><span class="s">&quot;x = 10&quot;</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">if</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>Example 4 will fail to order the write to  <em>x</em>  on thread 0 before the read from  <em>x</em>  on thread 1. Importantly, the implicit release flush on exit from the <strong>critical</strong> region will not synchronize with the acquire flush that occurs on the atomic read operation performed by thread 1. This is because implicit release flushes that occur on a given construct may only synchronize with implicit acquire flushes on a compatible construct (and vice-versa) that internally makes use of the same synchronization variable. For a <strong>critical</strong> construct, this might correspond to a  <em>lock</em>  object that is used by a given implementation (for the synchronization semantics of other constructs due to implicit release and acquire flushes, refer to the  <em>Implicit Flushes</em>  section of the OpenMP Specifications document).  Either an explicit <strong>flush</strong> directive that provides a release flush (i.e., a flush without a list that does not have the <strong>acquire</strong> clause) must be specified between the <strong>critical</strong> construct and the atomic write, or an atomic operation that modifies  <em>y</em>  and provides release semantics must be specified.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: acquire_release_broke.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="c1">// !!! THIS CODE WILL FAIL TO PRODUCE CONSISTENT RESULTS !!!!!!!</span>
<span class="c1">// !!! DO NOT PROGRAM SYNCHRONIZATION THIS WAY !!!!!!!</span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">thrd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thrd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp critical</span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="c1">// an explicit flush directive that provides</span>
<span class="w">         </span><span class="c1">// release semantics is needed here</span>
<span class="w">         </span><span class="c1">// to complete the synchronization.</span>
<span class="w">         </span><span class="cp">#pragma omp atomic write</span>
<span class="w">         </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#pragma omp atomic read acquire </span><span class="c1">// or seq_cst</span>
<span class="w">            </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp critical</span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// !! NOT ALWAYS 10</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">acquire_release_broke</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">rel_acq_ex4</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">thrd</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="o">!!</span><span class="w"> </span><span class="o">!!!</span><span class="w"> </span><span class="n">THIS</span><span class="w"> </span><span class="n">CODE</span><span class="w"> </span><span class="n">WILL</span><span class="w"> </span><span class="n">FAIL</span><span class="w"> </span><span class="n">TO</span><span class="w"> </span><span class="n">PRODUCE</span><span class="w"> </span><span class="n">CONSISTENT</span><span class="w"> </span><span class="n">RESULTS</span><span class="w"> </span><span class="o">!!!!!!!</span><span class="w"></span>
<span class="o">!!</span><span class="w"> </span><span class="o">!!!</span><span class="w"> </span><span class="n">DO</span><span class="w"> </span><span class="n">NOT</span><span class="w"> </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">SYNCHRONIZATION</span><span class="w"> </span><span class="n">THIS</span><span class="w"> </span><span class="n">WAY</span><span class="w"> </span><span class="o">!!!!!!!</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">thrd</span><span class="p">)</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">thrd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thrd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">         </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">explicit</span><span class="w"> </span><span class="n">flush</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">provides</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="w"> </span><span class="n">release</span><span class="w"> </span><span class="n">semantics</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">needed</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="n">to</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="w"> </span><span class="n">complete</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">synchronization</span><span class="p">.</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"></span>
<span class="w">         </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">atomic</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">         </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">acquire</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">seq_cst</span><span class="w"></span>
<span class="w">           </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">           </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">atomic</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">         </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w">  </span><span class="o">!!</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">NOT</span><span class="w"> </span><span class="n">ALWAYS</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">if</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="ordered-clause-and-ordered-construct">
<h2><span class="section-number">7.8. </span><strong>ordered</strong> Clause and <strong>ordered</strong> Construct<a class="headerlink" href="#ordered-clause-and-ordered-construct" title="Permalink to this headline">#</a></h2>
<p>Ordered constructs  are useful for sequentially ordering the output from work that  is done in parallel. The following program prints out the indices in sequential  order:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: ordered.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp ordered</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ordered_example</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lb</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ub</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">stride</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel for ordered schedule(dynamic)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">lb</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">ub</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="n">stride</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ordered_example</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">ordered</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">k</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">        </span><span class="n">WRITE</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">K</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB</span><span class="p">(</span><span class="n">LB</span><span class="p">,</span><span class="w"> </span><span class="n">UB</span><span class="p">,</span><span class="w"> </span><span class="n">STRIDE</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">LB</span><span class="p">,</span><span class="w"> </span><span class="n">UB</span><span class="p">,</span><span class="w"> </span><span class="n">STRIDE</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DO</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"> </span><span class="n">SCHEDULE</span><span class="p">(</span><span class="n">DYNAMIC</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="o">=</span><span class="n">LB</span><span class="p">,</span><span class="n">UB</span><span class="p">,</span><span class="n">STRIDE</span><span class="w"></span>
<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB</span><span class="w"></span>

<span class="w">      </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">ORDERED_EXAMPLE</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">ORDERED_EXAMPLE</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>It is possible to have multiple <strong>ordered</strong> constructs within a loop region  with the <strong>ordered</strong> clause specified. The first example is non-conforming  because all iterations execute two <strong>ordered</strong> regions. An iteration of a  loop must not execute more than one <strong>ordered</strong> region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: ordered.2</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ordered_wrong</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp for ordered</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cm">/* incorrect because an iteration may not execute more than one</span>
<span class="cm">   ordered region */</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp ordered</span>
<span class="w">      </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp ordered</span>
<span class="w">      </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">ordered</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ORDERED_WRONG</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">DO</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">        </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">one</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">region</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">END</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">END</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ORDERED_WRONG</span><span class="w"></span>

</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/tmp/tmpo5loiqel.out: /tmp/tmp2zj0ztim.out: undefined symbol: main
[Native kernel] Executable exited with code 1
</pre></div>
</div>
</div>
</div>
<p>The following is a conforming example with more than one <strong>ordered</strong> construct.  Each iteration will execute only one <strong>ordered</strong> region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: ordered.3</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ordered_good</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp for ordered</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp ordered</span>
<span class="w">         </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp ordered</span>
<span class="w">        </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">ordered</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ORDERED_GOOD</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">DO</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">        </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">          </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">              </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">END</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">          </span><span class="n">ENDIF</span><span class="w"></span>

<span class="w">          </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">              </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">END</span><span class="w"> </span><span class="n">ORDERED</span><span class="w"></span>
<span class="w">          </span><span class="n">ENDIF</span><span class="w"></span>
<span class="w">        </span><span class="n">ENDDO</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">ORDERED_GOOD</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="depobj-construct">
<h2><span class="section-number">7.9. </span><strong>depobj</strong> Construct<a class="headerlink" href="#depobj-construct" title="Permalink to this headline">#</a></h2>
<p>The stand-alone <strong>depobj</strong> construct provides a mechanism  to create a  <em>depend object</em>  that expresses a dependence to be  used subsequently in the <strong>depend</strong> clause of another construct. The dependence is created from a dependence type and a storage location, within a <strong>depend</strong> clause of an <strong>depobj</strong> construct;  and it is stored in the depend object. The depend object is represented by a variable of type <strong>omp_depend_t</strong>  in C/C++ (by a scalar variable of integer kind <strong>omp_depend_kind</strong> in Fortran).</p>
<p>In the example below the stand-alone <strong>depobj</strong> construct uses the  <strong>depend</strong>, <strong>update</strong> and <strong>destroy</strong> clauses to   <em>initialize</em> ,  <em>update</em>  and  <em>uninitialize</em>  a depend object (<strong>obj</strong>).</p>
<p>The first <strong>depobj</strong> construct initializes the <strong>obj</strong>  depend object with  an <strong>inout</strong> dependence type with a storage  location defined by variable <strong>a</strong>.   This dependence is passed into the  <em>driver</em>   routine via the <strong>obj</strong> depend object.</p>
<p>In the first  <em>driver</em>  routine call, <strong>Task 1</strong> uses the dependence of the object (<strong>inout</strong>),  while <strong>Task 2</strong> uses an <strong>in</strong> dependence specified  directly in a <strong>depend</strong> clause. For these task dependences <strong>Task 1</strong> must execute and  complete before <strong>Task 2</strong> begins.</p>
<p>Before the second call to  <em>driver</em> , <strong>obj</strong> is updated  using the <strong>depobj</strong> construct to represent an <strong>in</strong> dependence.  Hence, in the second call to  <em>driver</em> , <strong>Task 1</strong> will have an <strong>in</strong> dependence; and <strong>Task 1</strong> and  <strong>Task 2</strong> can execute simultaneously. Note: in an <strong>update</strong> clause, only the dependence type can be (is) updated.</p>
<p>The third <strong>depobj</strong> construct uses the <strong>destroy</strong> clause. It frees resources as it puts the depend object in an uninitialized state– effectively destroying the depend object. After an object has been uninitialized it can be initialized again with a new dependence type <strong>and</strong> a new variable.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       depobj.1</span>
<span class="cm">* type:       C</span>
<span class="cm">* version:    omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="cp">#define N 100</span>
<span class="cp">#define TRUE  1</span>
<span class="cp">#define FALSE 0</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">driver</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">update</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">omp_depend_t</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update_copy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">update</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">checkpoint</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>

<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">omp_depend_t</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp depobj(obj) depend(inout: a)</span>

<span class="w">   </span><span class="n">driver</span><span class="p">(</span><span class="n">TRUE</span><span class="p">,</span><span class="w">  </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">obj</span><span class="p">);</span><span class="w">  </span><span class="c1">// updating a occurs</span>

<span class="w">   </span><span class="cp">#pragma omp depobj(obj) update(in)</span>

<span class="w">   </span><span class="n">driver</span><span class="p">(</span><span class="n">FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">obj</span><span class="p">);</span><span class="w">  </span><span class="c1">// no updating of a</span>

<span class="w">   </span><span class="cp">#pragma omp depobj(obj) destroy(obj)  </span><span class="c1">// obj is set to uninitialized</span>
<span class="w">                                         </span><span class="c1">// state, resources are freed</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">driver</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">update</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">omp_depend_t</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">   </span><span class="cp">#pragma omp single</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="cp">#pragma omp task depend(depobj: *obj) </span><span class="c1">// Task 1, uses depend object</span>
<span class="w">         </span><span class="n">update_copy</span><span class="p">(</span><span class="n">update</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// may update a, always copy a to b</span>

<span class="w">     </span><span class="cp">#pragma omp task depend(in: a[:n])     </span><span class="c1">// Task 2, only read a</span>
<span class="w">         </span><span class="n">checkpoint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update_copy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">update</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">update</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">checkpoint</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %f &quot;</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       depobj.1
! type:       F-free
! version: omp_5.2

program main
    use omp_lib
    implicit none

    integer,parameter        :: N=100
    real                     :: a(N),b(N)
    integer(omp_depend_kind) :: obj

    call init(a, N)

    !$omp depobj(obj) depend(inout: a)

    call driver(.true.,  a,b,N, obj)  !! updating occurs

    !$omp depobj(obj) update(in)

    call driver(.false., a,b,N, obj)  !! no updating

    !$omp depobj(obj) destroy(obj)    !! obj is set to uninitialized
                                      !! state, resources are freed

end program

subroutine driver(update, a, b, n, obj)
   use omp_lib
   implicit none
   logical :: update
   real    :: a(n), b(n)
   integer :: n
   integer(omp_depend_kind) :: obj

   !$omp parallel num_threads(2)

     !$omp single

       !$omp task depend(depobj: obj)       !! Task 1, uses depend object
         call update_copy(update, a,b,n)
              !! update a or not, always copy a to b
       !$omp end task

       !$omp task depend(in: a)             !! Task 2, only read a
         call checkpoint(a,n)
       !$omp end task

     !$omp end single

   !$omp end parallel

end subroutine

subroutine update_copy(update, a, b, n)
   implicit none
   logical :: update
   real    :: a(n), b(n)
   integer :: n

   if (update) a = a + 1.0

   b = a

end subroutine

subroutine checkpoint( a, n)
   implicit none
   integer :: n
   real    :: a(n)
   integer :: i

   write(*,&#39;( *(f5.0) )&#39;) (a(i), i=1,n)
end subroutine

subroutine init(a,n)
   implicit none
   integer :: n
   real    :: a(n)
   integer :: i

   a=[ (i, i=1,n) ]
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="doacross-loop-nest">
<h2><span class="section-number">7.10. </span>Doacross Loop Nest<a class="headerlink" href="#doacross-loop-nest" title="Permalink to this headline">#</a></h2>
<p>An <strong>ordered</strong> clause can be used on a loop construct with an integer parameter argument to define the number of associated loops within  a  <em>doacross loop nest</em>  where cross-iteration dependences exist. A <strong>doacross</strong> clause on an <strong>ordered</strong> construct within an ordered  loop describes the dependences of the  <em>doacross</em>  loops.</p>
<p>In the code below, the <strong>doacross(sink:i-1)</strong> clause defines an  <em>i-1</em>   to  <em>i</em>  cross-iteration dependence that specifies a wait point for  the completion of computation from iteration  <em>i-1</em>  before proceeding  to the subsequent statements. The <strong>doacross(source:omp_cur_iteration)</strong>  or <strong>doacross(source:)</strong> clause indicates  the completion of computation from the current iteration ( <em>i</em> )  to satisfy the cross-iteration dependence that arises from the iteration. The <strong>omp_cur_iteration</strong> keyword is optional for the <strong>source</strong> dependence type. For this example the same sequential ordering could have been achieved  with an <strong>ordered</strong> clause without a parameter, on the loop directive,  and a single <strong>ordered</strong> directive without the <strong>doacross</strong> clause specified for the statement executing the  <em>bar</em>  function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: doacross.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>

<span class="kt">float</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp for ordered(1)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp ordered doacross(sink: i-1)</span>
<span class="w">    </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp ordered doacross(source: omp_cur_iteration)</span>

<span class="w">    </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">baz</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">doacross</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">dimension</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">external</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">baz</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">ordered</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">source</span><span class="o">:</span><span class="w"> </span><span class="n">omp_cur_iteration</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">baz</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following code is similar to the previous example but with   <em>doacross loop nest</em>  extended to two nested loops,  <em>i</em>  and  <em>j</em> ,  as specified by the <strong>ordered(2)</strong> clause on the loop directive.  In the C/C++ code, the  <em>i</em>  and  <em>j</em>  loops are the first and second associated loops, respectively, whereas in the Fortran code, the  <em>j</em>  and  <em>i</em>  loops are the first and second associated loops, respectively. The <strong>doacross(sink:i-1,j)</strong> and <strong>doacross(sink:i,j-1)</strong> clauses in  the C/C++ code define cross-iteration dependences in two dimensions from  iterations ( <em>i-1, j</em> ) and ( <em>i, j-1</em> ) to iteration ( <em>i, j</em> ).   Likewise, the <strong>doacross(sink:j-1,i)</strong> and <strong>doacross(sink:j,i-1)</strong> clauses  in the Fortran code define cross-iteration dependences from iterations  ( <em>j-1, i</em> ) and ( <em>j, i-1</em> ) to iteration ( <em>j, i</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: doacross.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>

<span class="kt">float</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">baz</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">**</span><span class="n">C</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp for ordered(2)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp ordered doacross(sink: i-1,j) doacross(sink: i,j-1)</span>
<span class="w">      </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp ordered doacross(source:)</span>

<span class="w">      </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">baz</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">doacross</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">dimension</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">external</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">baz</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">ordered</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="mi">-1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">source</span><span class="o">:</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">baz</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example shows the incorrect use of the <strong>ordered</strong>  directive with a <strong>doacross</strong> clause.  There are two issues with the code.   The first issue is a missing <strong>ordered</strong> <strong>doacross(source:)</strong> directive, which could cause a deadlock.   The second issue is the <strong>doacross(sink:i+1,j)</strong> and <strong>doacross(sink:i,j+1)</strong>  clauses define dependences on lexicographically later  source iterations ( <em>i+1, j</em> ) and ( <em>i, j+1</em> ), which could cause  a deadlock as well since they may not start to execute until the current iteration completes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: doacross.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#define N 100</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">work_wrong</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="p">[][</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel for ordered(2) private(i,j,k)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp ordered doacross(sink: i-1,j) doacross(sink: i+1,j) \</span>
<span class="cp">                      doacross(sink: i,j-1) doacross(sink: i,j+1)</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">&lt;</span><span class="n">N</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">tmp3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tmp1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tmp2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tmp3</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">6.0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="cm">/* missing #pragma omp ordered doacross(source:) */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">doacross</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">work_wrong</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="n">dimension</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">tmp1</span><span class="p">,</span><span class="w"> </span><span class="n">tmp2</span><span class="p">,</span><span class="w"> </span><span class="n">tmp3</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">ordered</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">tmp1</span><span class="p">,</span><span class="n">tmp2</span><span class="p">,</span><span class="n">tmp3</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="mi">-1</span><span class="w"></span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="mi">-1</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">        </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="mi">-1</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">k</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tmp1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tmp2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tmp3</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">6.0</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">missing</span><span class="w"> </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">source</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example illustrates the use of the <strong>collapse</strong> clause for a  <em>doacross loop nest</em> .  The  <em>i</em>  and  <em>j</em>  loops are the associated loops for the collapsed loop as well as for the  <em>doacross loop nest</em> . The example also shows a compliant usage of the dependence source directive placed before the corresponding sink directive. Checking the completion of computation from previous iterations at the sink point can occur after the source statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: doacross.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>

<span class="kt">double</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">**</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">**</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">**</span><span class="n">C</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.2</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp for collapse(2) ordered(2)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp ordered doacross(source:)</span>

<span class="w">      </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp ordered doacross(sink: i-1,j) doacross(sink: i,j-1)</span>
<span class="w">      </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">doacross</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="n">dimension</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="n">external</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">foo</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.2</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">collapse</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">ordered</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="mi">-1</span><span class="w"></span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="mi">-1</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">source</span><span class="o">:</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="n">doacross</span><span class="p">(</span><span class="n">sink</span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="mi">-1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">               </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="lock-routines">
<h2><span class="section-number">7.11. </span>Lock Routines<a class="headerlink" href="#lock-routines" title="Permalink to this headline">#</a></h2>
<p>This section is about the use of lock routines for synchronization.</p>
<section id="omp-init-lock-routine">
<h3><span class="section-number">7.11.1. </span><strong>omp_init_lock</strong> Routine<a class="headerlink" href="#omp-init-lock-routine" title="Permalink to this headline">#</a></h3>
<p>The following example demonstrates how to initialize an array of locks in a <strong>parallel</strong>  region by using <strong>omp_init_lock</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: init_lock.1</span>
<span class="cm">* type: C++</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="n">omp_lock_t</span><span class="w"> </span><span class="o">*</span><span class="nf">new_locks</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_lock_t</span><span class="w"> </span><span class="o">*</span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">omp_lock_t</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel for private(i)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">omp_init_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">init_lock</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">NEW_LOCKS</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">INCLUDE</span><span class="w"> </span><span class="s">&quot;omp_lib.h&quot;</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">(</span><span class="n">OMP_LOCK_KIND</span><span class="p">),</span><span class="w"> </span><span class="n">DIMENSION</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">NEW_LOCKS</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DO</span><span class="w"> </span><span class="n">PRIVATE</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">OMP_INIT_LOCK</span><span class="p">(</span><span class="n">NEW_LOCKS</span><span class="p">(</span><span class="n">I</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">NEW_LOCKS</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="omp-init-lock-with-hint-routine">
<h3><span class="section-number">7.11.2. </span><strong>omp_init_lock_with_hint</strong> Routine<a class="headerlink" href="#omp-init-lock-with-hint-routine" title="Permalink to this headline">#</a></h3>
<p>The following example demonstrates how to initialize an array of locks in a <strong>parallel</strong> region by using <strong>omp_init_lock_with_hint</strong>. Note, hints are combined with an <strong>|</strong> or <strong>+</strong> operator in C/C++ and a <strong>+</strong> operator in Fortran.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: init_lock_with_hint.1</span>
<span class="cm">* type: C++</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="n">omp_lock_t</span><span class="w"> </span><span class="o">*</span><span class="nf">new_locks</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_lock_t</span><span class="w"> </span><span class="o">*</span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">omp_lock_t</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel for private(i)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">omp_init_lock_with_hint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"></span>
<span class="w">        </span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">omp_lock_hint_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">omp_sync_hint_contended</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">                                     </span><span class="n">omp_sync_hint_speculative</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">init_lock_with_hint</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>
<span class="w">      </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">NEW_LOCKS</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">INCLUDE</span><span class="w"> </span><span class="s">&quot;omp_lib.h&quot;</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="p">(</span><span class="n">OMP_LOCK_KIND</span><span class="p">),</span><span class="w"> </span><span class="n">DIMENSION</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">NEW_LOCKS</span><span class="w"></span>

<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DO</span><span class="w"> </span><span class="n">PRIVATE</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">OMP_INIT_LOCK_WITH_HINT</span><span class="p">(</span><span class="n">NEW_LOCKS</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="w"></span>
<span class="w">     </span><span class="o">&amp;</span><span class="w">             </span><span class="n">OMP_SYNC_HINT_CONTENDED</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">OMP_SYNC_HINT_SPECULATIVE</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">FUNCTION</span><span class="w"> </span><span class="n">NEW_LOCKS</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="ownership-of-locks">
<h3><span class="section-number">7.11.3. </span>Ownership of Locks<a class="headerlink" href="#ownership-of-locks" title="Permalink to this headline">#</a></h3>
<p>Ownership of locks has changed since OpenMP 2.5. In OpenMP 2.5, locks are owned  by threads; so a lock released by the <strong>omp_unset_lock</strong> routine must be  owned by the same thread executing the routine.  Beginning with OpenMP 3.0, locks are owned  by task regions; so a lock released by the <strong>omp_unset_lock</strong> routine in  a task region must be owned by the same task region.</p>
<p>This change in ownership requires extra care when using locks. The following program  is conforming in OpenMP 2.5 because the thread that releases the lock <strong>lck</strong>  in the parallel region is the same thread that acquired the lock in the sequential  part of the program (primary thread of parallel region and the initial thread are  the same). However, it is not conforming beginning with OpenMP 3.0, because the task  region that releases the lock <strong>lck</strong> is different from the task region that  acquires the lock.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: lock_owner.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version:    omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_lock_t</span><span class="w"> </span><span class="n">lck</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">omp_init_lock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_set_lock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp parallel shared (x)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp masked</span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">omp_unset_lock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* Some more stuff. */</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_destroy_lock</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">lock_owner</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.1</span><span class="w"></span>
<span class="w">        </span><span class="n">program</span><span class="w"> </span><span class="n">lock</span><span class="w"></span>
<span class="w">        </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">        </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">        </span><span class="n">integer</span><span class="w"> </span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">omp_lock_kind</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">lck</span><span class="w"></span>

<span class="w">        </span><span class="n">call</span><span class="w"> </span><span class="n">omp_init_lock</span><span class="w"> </span><span class="p">(</span><span class="n">lck</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">call</span><span class="w"> </span><span class="n">omp_set_lock</span><span class="p">(</span><span class="n">lck</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">masked</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="n">call</span><span class="w"> </span><span class="n">omp_unset_lock</span><span class="p">(</span><span class="n">lck</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">masked</span><span class="w"></span>

<span class="o">!</span><span class="w">       </span><span class="n">Some</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">stuff</span><span class="p">.</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="w">        </span><span class="n">call</span><span class="w"> </span><span class="n">omp_destroy_lock</span><span class="p">(</span><span class="n">lck</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">end</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="simple-lock-routines">
<h3><span class="section-number">7.11.4. </span>Simple Lock Routines<a class="headerlink" href="#simple-lock-routines" title="Permalink to this headline">#</a></h3>
<p>In the following example, the lock routines cause the threads to be idle while  waiting for entry to the first critical section, but to do other work while waiting  for entry to the second. The <strong>omp_set_lock</strong> function blocks, but the <strong>omp_test_lock</strong>  function does not, allowing the work in <strong>skip</strong> to be done.</p>
<p>Note that the argument to the lock routines should have type  <strong>omp_lock_t</strong> (or <strong>omp_lock_kind</strong> in Fortran),  and that there is no need to flush the lock variable ( <em>lck</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: simple_lock.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">skip</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_lock_t</span><span class="w"> </span><span class="n">lck</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_init_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel shared(lck) private(id)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">omp_set_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/*  only one thread at a time can execute this printf */</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;My thread id is %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">omp_unset_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">omp_test_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">skip</span><span class="p">(</span><span class="n">id</span><span class="p">);</span><span class="w">   </span><span class="cm">/* we do not yet have the lock,</span>
<span class="cm">                     so we must do something else */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">work</span><span class="p">(</span><span class="n">id</span><span class="p">);</span><span class="w">      </span><span class="cm">/* we now have the lock</span>
<span class="cm">                      and can do the work */</span><span class="w"></span>

<span class="w">    </span><span class="n">omp_unset_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_destroy_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: simple_lock.1
! type: F-fixed
      SUBROUTINE SKIP(ID)
      END SUBROUTINE SKIP

      SUBROUTINE WORK(ID)
      END SUBROUTINE WORK

      PROGRAM SIMPLELOCK

        INCLUDE &quot;omp_lib.h&quot;     ! or USE OMP_LIB

        INTEGER(OMP_LOCK_KIND) LCK
        INTEGER ID

        CALL OMP_INIT_LOCK(LCK)

!$OMP   PARALLEL SHARED(LCK) PRIVATE(ID)
          ID = OMP_GET_THREAD_NUM()
          CALL OMP_SET_LOCK(LCK)
          PRINT *, &#39;My thread id is &#39;, ID
          CALL OMP_UNSET_LOCK(LCK)

          DO WHILE (.NOT. OMP_TEST_LOCK(LCK))
            CALL SKIP(ID)     ! We do not yet have the lock
                              ! so we must do something else
          END DO

          CALL WORK(ID)       ! We now have the lock
                              ! and can do the work

          CALL OMP_UNSET_LOCK( LCK )

!$OMP   END PARALLEL

        CALL OMP_DESTROY_LOCK( LCK )

      END PROGRAM SIMPLELOCK
</pre></div>
</div>
</div>
</div>
</section>
<section id="nestable-lock-routines">
<h3><span class="section-number">7.11.5. </span>Nestable Lock Routines<a class="headerlink" href="#nestable-lock-routines" title="Permalink to this headline">#</a></h3>
<p>The following example demonstrates how a nestable lock can be used to synchronize  updates both to a whole structure and to one of its members.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nestable_lock.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">omp_nest_lock_t</span><span class="w"> </span><span class="n">lck</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">pair</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">work1</span><span class="p">();</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">work2</span><span class="p">();</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">work3</span><span class="p">();</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">incr_a</span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* Called only from incr_pair, no need to lock. */</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">incr_b</span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* Called both from incr_pair and elsewhere, */</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* so need a nestable lock. */</span><span class="w"></span>

<span class="w">  </span><span class="n">omp_set_nest_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_unset_nest_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">incr_pair</span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">omp_set_nest_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">incr_a</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">incr_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_unset_nest_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lck</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">nestlock</span><span class="p">(</span><span class="n">pair</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel sections</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp section</span>
<span class="w">      </span><span class="n">incr_pair</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">work1</span><span class="p">(),</span><span class="w"> </span><span class="n">work2</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp section</span>
<span class="w">      </span><span class="n">incr_b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">work3</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nestable_lock</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">MODULE</span><span class="w"> </span><span class="n">DATA</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="p">,</span><span class="w"> </span><span class="n">ONLY</span><span class="o">:</span><span class="w"> </span><span class="n">OMP_NEST_LOCK_KIND</span><span class="w"></span>
<span class="w">        </span><span class="n">TYPE</span><span class="w"> </span><span class="n">LOCKED_PAIR</span><span class="w"></span>
<span class="w">          </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">A</span><span class="w"></span>
<span class="w">          </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">B</span><span class="w"></span>
<span class="w">          </span><span class="n">INTEGER</span><span class="w"> </span><span class="p">(</span><span class="n">OMP_NEST_LOCK_KIND</span><span class="p">)</span><span class="w"> </span><span class="n">LCK</span><span class="w"></span>
<span class="w">       </span><span class="n">END</span><span class="w"> </span><span class="n">TYPE</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">MODULE</span><span class="w"> </span><span class="n">DATA</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">INCR_A</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">INCR_PAIR</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">need</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">lock</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">DATA</span><span class="w"></span>
<span class="w">        </span><span class="n">TYPE</span><span class="p">(</span><span class="n">LOCKED_PAIR</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">A</span><span class="w"></span>
<span class="w">        </span><span class="n">P</span><span class="o">%</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="o">%</span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">A</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">INCR_A</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">INCR_B</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">both</span><span class="w"> </span><span class="n">INCR_PAIR</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">elsewhere</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">need</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">nestable</span><span class="w"> </span><span class="n">lock</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="w">       </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">INCLUDE</span><span class="w"> </span><span class="s">&quot;omp_lib.h&quot;</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">DATA</span><span class="w"></span>
<span class="w">        </span><span class="n">TYPE</span><span class="p">(</span><span class="n">LOCKED_PAIR</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">B</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">OMP_SET_NEST_LOCK</span><span class="p">(</span><span class="n">P</span><span class="o">%</span><span class="n">LCK</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">P</span><span class="o">%</span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="o">%</span><span class="n">B</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">OMP_UNSET_NEST_LOCK</span><span class="p">(</span><span class="n">P</span><span class="o">%</span><span class="n">LCK</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">INCR_B</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">INCR_PAIR</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">INCLUDE</span><span class="w"> </span><span class="s">&quot;omp_lib.h&quot;</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">DATA</span><span class="w"></span>
<span class="w">        </span><span class="n">TYPE</span><span class="p">(</span><span class="n">LOCKED_PAIR</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">A</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">B</span><span class="w"></span>

<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">OMP_SET_NEST_LOCK</span><span class="p">(</span><span class="n">P</span><span class="o">%</span><span class="n">LCK</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">INCR_A</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">INCR_B</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">CALL</span><span class="w"> </span><span class="n">OMP_UNSET_NEST_LOCK</span><span class="p">(</span><span class="n">P</span><span class="o">%</span><span class="n">LCK</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">INCR_PAIR</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">NESTLOCK</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">INCLUDE</span><span class="w"> </span><span class="s">&quot;omp_lib.h&quot;</span><span class="w"></span>
<span class="w">        </span><span class="n">USE</span><span class="w"> </span><span class="n">DATA</span><span class="w"></span>
<span class="w">        </span><span class="n">TYPE</span><span class="p">(</span><span class="n">LOCKED_PAIR</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">WORK1</span><span class="p">,</span><span class="w"> </span><span class="n">WORK2</span><span class="p">,</span><span class="w"> </span><span class="n">WORK3</span><span class="w"></span>
<span class="w">        </span><span class="n">EXTERNAL</span><span class="w"> </span><span class="n">WORK1</span><span class="p">,</span><span class="w"> </span><span class="n">WORK2</span><span class="p">,</span><span class="w"> </span><span class="n">WORK3</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SECTIONS</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">SECTION</span><span class="w"></span>
<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">INCR_PAIR</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">WORK1</span><span class="p">(),</span><span class="w"> </span><span class="n">WORK2</span><span class="p">())</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">SECTION</span><span class="w"></span>
<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">INCR_B</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">WORK3</span><span class="p">())</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SECTIONS</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">NESTLOCK</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/tmp/tmpo5loiqel.out: /tmp/tmp7pvrmr3d.out: undefined symbol: main
[Native kernel] Executable exited with code 1
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents/Chap_synchronization"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../Chap_loop_transformations/Chap_loop_transformations.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">6. </span>Loop Transformations</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../Chap_data_environment/Chap_data_environment.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8. </span>Data Environment</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The OpenMP Community<br/>
  
      &copy; <a href="../../copyright.html">Copyright</a> 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>