
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>10. Memory Model &#8212; OpenMP Application Programming Interface Examples</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="11. Program Control" href="../Chap_program_control/Chap_program_control.html" />
    <link rel="prev" title="9. Data Environment" href="../Chap_data_environment/Chap_data_environment.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to OMP Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Title_Page.html">
   Cover
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Foreword_Chapt.html">
   Foreword
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_introduction/Chap_introduction.html">
   1. Introduction
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_introduction/Section_Examples_Organization.html">
     1.1. Examples Organization
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_directives/Chap_directives.html">
   2. OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_parallel_execution/Chap_parallel_execution.html">
   3. Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_tasking/Chap_tasking.html">
   4. Tasking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_devices/Chap_devices.html">
   5. Devices
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_SIMD/Chap_SIMD.html">
   6. SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_loop_transformations/Chap_loop_transformations.html">
   7. Loop Transformations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_synchronization/Chap_synchronization.html">
   8. Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_data_environment/Chap_data_environment.html">
   9. Data Environment
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   10. Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_program_control/Chap_program_control.html">
   11. Program Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_ompt_interface/Chap_ompt_interface.html">
   12. OMPT Interface
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_memory_model/Chap_memory_model.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/passlab/Examples"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_memory_model/Chap_memory_model.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../_sources/contents/Chap_memory_model/Chap_memory_model.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#openmp-memory-model">
   10.1. OpenMP Memory Model
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#memory-allocators">
   10.2. Memory Allocators
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#race-conditions-caused-by-implied-copies-of-shared-variables-in-fortran">
   10.3. Race Conditions Caused by Implied Copies of Shared Variables in Fortran
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Memory Model</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#openmp-memory-model">
   10.1. OpenMP Memory Model
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#memory-allocators">
   10.2. Memory Allocators
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#race-conditions-caused-by-implied-copies-of-shared-variables-in-fortran">
   10.3. Race Conditions Caused by Implied Copies of Shared Variables in Fortran
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="memory-model">
<h1><span class="section-number">10. </span>Memory Model<a class="headerlink" href="#memory-model" title="Permalink to this headline">#</a></h1>
<p>OpenMP provides a shared-memory model that allows all threads on a given device shared access to <em>memory</em>. For a given OpenMP region that may be executed by more than one thread or SIMD lane, variables in memory may be <em>shared</em> or <em>private</em> with respect to those threads or SIMD lanes. A variable’s data-sharing attribute indicates whether it is shared (the <em>shared</em> attribute) or private (the <em>private</em>, <em>firstprivate</em>, <em>lastprivate</em>, <em>linear</em>, and <em>reduction</em> attributes) in the data environment of an OpenMP region. While private variables in an OpenMP region are new copies of the original variable (with same name) that may then be concurrently accessed or modified by their respective threads or SIMD lanes, a shared variable in an OpenMP region is the same as the variable of the same name in the enclosing region. Concurrent accesses or modifications to a shared variable may therefore require synchronization to avoid data races.</p>
<p>OpenMP’s memory model also includes a <em>temporary view</em> of memory that is associated with each thread. Two different threads may see different values for a given variable in their respective temporary views. Threads may employ flush operations for the purposes of making their temporary view of a variable consistent with the value of the variable in memory. The effect of a given flush operation is characterized by its flush properties - some combination of <em>strong</em>, <em>release</em>, and <em>acquire</em> - and, for <em>strong</em> flushes, a <em>flush-set</em>.</p>
<p>A <em>strong</em> flush will force consistency between the temporary view and the memory for all variables in its <em>flush-set</em>.  Furthermore, all strong flushes in a program that have intersecting flush-sets will execute in some total order, and within a thread strong flushes may not be reordered with respect to other memory operations on variables in its flush-set. <em>Release</em> and <em>acquire</em> flushes operate in pairs. A release flush may “synchronize’’ with an acquire flush, and when it does so the local memory operations that precede the release flush will appear to have been completed before the local memory operations on the same variables that follow the acquire flush.</p>
<p>Flush operations arise from explicit <strong>flush</strong> directives, implicit <strong>flush</strong> directives, and also from the execution of <strong>atomic</strong> constructs. The <strong>flush</strong> directive forces a  consistent view of local variables of the thread executing the <strong>flush</strong>.  When a list is supplied on the directive, only the items (variables) in the list are guaranteed to be flushed.  Implied flushes exist at prescribed locations of certain constructs. For the complete list of these locations and associated constructs, please refer to the  <em>flush Construct</em>  section of the OpenMP Specifications document.</p>
<p>In this chapter, examples illustrate how race conditions may arise for accesses to variables with a  <em>shared</em>  data-sharing attribute when flush operations are not properly employed.  A race condition can exist when two or more threads are involved in accessing a variable and at least one of the accesses modifies the variable.  In particular, a data race will arise when conflicting accesses do not have a well-defined <em>completion order</em>.  The existence of data races in OpenMP programs result in undefined behavior, and so they should generally be avoided for programs to be correct.  The completion order of accesses to a shared variable is guaranteed in OpenMP through a set of memory consistency rules that are described in the  <em>OpenMP Memory Consistency</em>  section of the OpenMP Specifications document.</p>
<section id="openmp-memory-model">
<h2><span class="section-number">10.1. </span>OpenMP Memory Model<a class="headerlink" href="#openmp-memory-model" title="Permalink to this headline">#</a></h2>
<p>The following examples illustrate two major concerns for concurrent thread execution: ordering of thread execution and memory accesses that may or may not lead to race conditions.</p>
<p>In the following example, at Print 1, the value of <strong>xval</strong> could be either 2 or 5, depending on the timing of the threads. The <strong>atomic</strong> directives are necessary for the accesses to <strong>x</strong> by threads 1 and 2 to avoid a data race. If the atomic write completes before the atomic read, thread 1 is guaranteed to see 5 in <strong>xval</strong>. Otherwise, thread 1 is guaranteed to see 2 in <strong>xval</strong>.</p>
<p><em>flushes!implicit</em> <em>atomic construct <strong>atomic</strong> construct</em> <em>constructs!atomic <strong>atomic</strong></em> The barrier after Print 1 contains implicit flushes on all threads, as well as a thread synchronization, so the programmer is guaranteed that the value 5 will be printed by both Print 2 and Print 3. Since neither Print 2 or Print 3 are modifying <strong>x</strong>, they may concurrently access <strong>x</strong> without requiring <strong>atomic</strong> directives to avoid a data race.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: mem_model.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel num_threads(2) shared(x)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="cp">#pragma omp atomic write</span>
<span class="w">       </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">xval</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp atomic read</span>
<span class="w">      </span><span class="n">xval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Print 1: xval can be 2 or 5 */</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;1: Thread# %d: x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">(),</span><span class="w"> </span><span class="n">xval</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#pragma omp barrier</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Print 2 */</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;2: Thread# %d: x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Print 3 */</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;3: Thread# %d: x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">mem_model</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="n">PROGRAM</span><span class="w"> </span><span class="n">MEMMODEL</span><span class="w"></span>
<span class="w">  </span><span class="n">INCLUDE</span><span class="w"> </span><span class="s">&quot;omp_lib.h&quot;</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="w"></span>
<span class="w">  </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">XVAL</span><span class="w"></span>

<span class="w">  </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">NUM_THREADS</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">SHARED</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">OMP_GET_THREAD_NUM</span><span class="p">()</span><span class="w"> </span><span class="p">.</span><span class="n">EQ</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">WRITE</span><span class="w"></span>
<span class="w">       </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="w">    </span><span class="n">ELSE</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">ATOMIC</span><span class="w"> </span><span class="n">READ</span><span class="w"></span>
<span class="w">      </span><span class="n">XVAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="w"> </span><span class="n">PRINT</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">XVAL</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="w">      </span><span class="n">PRINT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="s">&quot;1: THREAD# &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">OMP_GET_THREAD_NUM</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;X = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">XVAL</span><span class="w"></span>
<span class="w">    </span><span class="n">ENDIF</span><span class="w"></span>

<span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">BARRIER</span><span class="w"></span>

<span class="w">    </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">OMP_GET_THREAD_NUM</span><span class="p">()</span><span class="w"> </span><span class="p">.</span><span class="n">EQ</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="w"> </span><span class="n">PRINT</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">      </span><span class="n">PRINT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="s">&quot;2: THREAD# &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">OMP_GET_THREAD_NUM</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;X = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">    </span><span class="n">ELSE</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="w"> </span><span class="n">PRINT</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">      </span><span class="n">PRINT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="s">&quot;3: THREAD# &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">OMP_GET_THREAD_NUM</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;X = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">    </span><span class="n">ENDIF</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="n">END</span><span class="w"> </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">MEMMODEL</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example demonstrates why synchronization is difficult to perform correctly through variables. The write to <strong>flag</strong> on thread 0 and the read from <strong>flag</strong> in the loop on thread 1 must be atomic to avoid a data race. When thread 1 breaks out of the loop, <strong>flag</strong> will have the value of 1. However, <strong>data</strong> will still be undefined at the first print statement. Only after the flush of both <strong>flag</strong> and <strong>data</strong> after the first print statement will <strong>data</strong> have the well-defined value of 42.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: mem_model.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cm">/* Write to the data buffer that will be</span>
<span class="cm">       * read by thread */</span><span class="w"></span>
<span class="w">          </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="cm">/* Flush data to thread 1 and strictly order</span>
<span class="cm">       * the write to data relative to the write to the flag */</span><span class="w"></span>
<span class="w">          </span><span class="cp">#pragma omp flush(flag, data)</span>
<span class="w">      </span><span class="cm">/* Set flag to release thread 1 */</span><span class="w"></span>
<span class="w">          </span><span class="cp">#pragma omp atomic write</span>
<span class="w">          </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cm">/* Loop until we see the update to the flag */</span><span class="w"></span>
<span class="w">          </span><span class="cp">#pragma omp flush(flag, data)</span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">flag_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">flag_val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="cp">#pragma omp atomic read</span>
<span class="w">             </span><span class="n">flag_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="cm">/* Value of flag is 1; value of data is undefined */</span><span class="w"></span>
<span class="w">          </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;flag=%d data=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="cp">#pragma omp flush(flag, data)</span>
<span class="w">      </span><span class="cm">/* Value of flag is 1; value of data is 42 */</span><span class="w"></span>
<span class="w">          </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;flag=%d data=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: mem_model.2
! type: F-fixed
! version: omp_3.1
       PROGRAM EXAMPLE
       INCLUDE &quot;omp_lib.h&quot; ! or USE OMP_LIB
       INTEGER DATA
       INTEGER FLAG, FLAG_VAL

       FLAG = 0
!$OMP  PARALLEL NUM_THREADS(2)
         IF(OMP_GET_THREAD_NUM() .EQ. 0) THEN
         ! Write to the data buffer that will be read by thread 1
            DATA = 42

         ! Flush DATA to thread 1 and strictly order the write to DATA
         ! relative to the write to the FLAG
!$OMP       FLUSH(FLAG, DATA)

         ! Set FLAG to release thread 1
!$OMP       ATOMIC WRITE
            FLAG = 1

         ELSE IF(OMP_GET_THREAD_NUM() .EQ. 1) THEN
         ! Loop until we see the update to the FLAG
!$OMP       FLUSH(FLAG, DATA)
            FLAG_VAL = 0
            DO WHILE(FLAG_VAL .LT. 1)
!$OMP          ATOMIC READ
               FLAG_VAL = FLAG
            ENDDO

         ! Value of FLAG is 1; value of DATA is undefined
            PRINT *, &#39;FLAG=&#39;, FLAG, &#39; DATA=&#39;, DATA

!$OMP       FLUSH(FLAG, DATA)
         ! Value of FLAG is 1; value of DATA is 42
            PRINT *, &#39;FLAG=&#39;, FLAG, &#39; DATA=&#39;, DATA

         ENDIF
!$OMP  END PARALLEL
       END
</pre></div>
</div>
</div>
</div>
<p>The next example demonstrates why synchronization is difficult to perform correctly through variables. As in the preceding example, the updates to <strong>flag</strong> and the reading of <strong>flag</strong> in the loops on threads 1 and 2 are performed atomically to avoid data races on <strong>flag</strong>. However, the code still contains data race due to the incorrect use of “flush with a list’’ after the assignment to <strong>data1</strong> on thread 1. By not including <strong>flag</strong> in the flush-set of that <strong>flush</strong> directive, the assignment can be reordered with respect to the subsequent atomic update to <strong>flag</strong>. Consequentially, <strong>data1</strong> is undefined at the print statement on thread 2.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: mem_model.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">data0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel num_threads(3)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">data0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp flush</span>
<span class="w">         </span><span class="cm">/* Set flag to release thread 1 */</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp atomic update</span>
<span class="w">         </span><span class="n">flag</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="cm">/* Flush of flag is implied by the atomic directive */</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">flag_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="cm">/* Loop until we see that flag reaches 1*/</span><span class="w"></span>
<span class="w">         </span><span class="k">while</span><span class="p">(</span><span class="n">flag_val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#pragma omp atomic read</span>
<span class="w">            </span><span class="n">flag_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp flush(data0)</span>
<span class="w">         </span><span class="cm">/* data0 is 17 here */</span><span class="w"></span>
<span class="w">         </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread 1 awoken (data0 = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data0</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp flush(data1)</span>
<span class="w">         </span><span class="cm">/* Set flag to release thread 2 */</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp atomic update</span>
<span class="w">         </span><span class="n">flag</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="cm">/* Flush of flag is implied by the atomic directive */</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">flag_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="cm">/* Loop until we see that flag reaches 2 */</span><span class="w"></span>
<span class="w">         </span><span class="k">while</span><span class="p">(</span><span class="n">flag_val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#pragma omp atomic read</span>
<span class="w">            </span><span class="n">flag_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp flush(data0,data1)</span>
<span class="w">         </span><span class="cm">/* there is a data race here;</span>
<span class="cm">            data0 is 17 and data1 is undefined */</span><span class="w"></span>
<span class="w">         </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread 2 awoken (data0 = %d, data1 = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">data0</span><span class="p">,</span><span class="w"> </span><span class="n">data1</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: mem_model.3
! type: F-fixed
! version: omp_3.1
       PROGRAM EXAMPLE
       INCLUDE &quot;omp_lib.h&quot; ! or USE OMP_LIB
       INTEGER FLAG, FLAG_VAL
       INTEGER DATA0, DATA1

       FLAG = 0
!$OMP  PARALLEL NUM_THREADS(3)
         IF(OMP_GET_THREAD_NUM() .EQ. 0) THEN
             DATA0 = 17
!$OMP        FLUSH

         ! Set flag to release thread 1
!$OMP        ATOMIC UPDATE
             FLAG = FLAG + 1
         ! Flush of FLAG is implied by the atomic directive

         ELSE IF(OMP_GET_THREAD_NUM() .EQ. 1) THEN
         ! Loop until we see that FLAG reaches 1
!$OMP        FLUSH(FLAG, DATA)
             FLAG_VAL = 0
             DO WHILE(FLAG_VAL .LT. 1)
!$OMP           ATOMIC READ
                FLAG_VAL = FLAG
             ENDDO
!$OMP        FLUSH

         ! DATA0 is 17 here
             PRINT *, &#39;Thread 1 awoken. DATA0 = &#39;, DATA0

             DATA1 = 42
!$OMP        FLUSH(DATA1)

         ! Set FLAG to release thread 2
!$OMP        ATOMIC UPDATE
             FLAG = FLAG + 1
         ! Flush of FLAG is implied by the atomic directive

         ELSE IF(OMP_GET_THREAD_NUM() .EQ. 2) THEN
         ! Loop until we see that FLAG reaches 2
             FLAG_VAL = 0
             DO WHILE(FLAG_VAL .LT. 2)
!$OMP           ATOMIC READ
                FLAG_VAL = FLAG
             ENDDO
!$OMP        FLUSH(DATA0, DATA1)

         ! There is a data race here; data0 is 17 and data1 is undefined
             PRINT *, &#39;Thread 2 awoken. DATA0 = &#39;, DATA0,
     &amp;                &#39; and DATA1 = &#39;, DATA1

         ENDIF
!$OMP  END PARALLEL
       END
</pre></div>
</div>
</div>
</div>
<p>The following two examples illustrate the ordering properties of  the  <em>flush</em>  operation. The  <em>flush</em>  operations are strong flushes  that are applied to the specified flush lists.  However, use of a <strong>flush</strong> construct with a list is extremely error  prone and users are strongly discouraged from attempting it.  In the codes the programmer intends to prevent simultaneous  execution of the protected section by the two threads. The atomic directives in the codes ensure that the accesses to shared variables  <em>a</em>  and  <em>b</em>  are atomic write and atomic read operations. Otherwise both examples would contain data races and automatically result  in unspecified behavior.</p>
<p>In the following incorrect code example, operations on variables  <em>a</em>  and  <em>b</em>  are not ordered with respect to each other. For instance, nothing prevents the compiler from moving the flush of  <em>b</em>  on thread 0 or the flush of  <em>a</em>  on thread 1 to a position completely after the protected section (assuming that the protected section on thread 0 does not reference  <em>b</em>  and the protected section on thread 1 does not reference  <em>a</em> ). If either re-ordering happens, both threads can simultaneously execute the protected section. Any shared data accessed in the protected section is not guaranteed to  be current or consistent during or after the protected section.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: mem_model.4a</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">flush_incorrect</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">        </span><span class="c1">// thread 0</span>
<span class="w">      </span><span class="cp">#pragma omp atomic write</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp flush(b)    </span><span class="c1">// flushes are not ordered</span>
<span class="w">      </span><span class="cp">#pragma omp flush(a)    </span><span class="c1">// compiler may move them around</span>
<span class="w">      </span><span class="cp">#pragma omp atomic read</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">                    </span><span class="c1">// thread 1</span>
<span class="w">      </span><span class="cp">#pragma omp atomic write</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp flush(a)    </span><span class="c1">// flushes are not ordered</span>
<span class="w">      </span><span class="cp">#pragma omp flush(b)    </span><span class="c1">// compiler may move them around</span>
<span class="w">      </span><span class="cp">#pragma omp atomic read</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">         </span><span class="c1">// exclusive access not guaranteed</span>
<span class="w">      </span><span class="cm">/* protected section */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">mem_model</span><span class="mf">.4</span><span class="n">a</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">flush_incorrect</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">  </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="n">myid</span><span class="w"></span>

<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">myid</span><span class="p">,</span><span class="n">tmp</span><span class="p">)</span><span class="w"> </span><span class="n">num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">myid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w">     </span><span class="o">!</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"></span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w">          </span><span class="o">!</span><span class="w"> </span><span class="n">flushes</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">ordered</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w">          </span><span class="o">!</span><span class="w"> </span><span class="n">compiler</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">them</span><span class="w"> </span><span class="n">around</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">read</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w">                      </span><span class="o">!</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w">          </span><span class="o">!</span><span class="w"> </span><span class="n">flushes</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">ordered</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w">          </span><span class="o">!</span><span class="w"> </span><span class="n">compiler</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">them</span><span class="w"> </span><span class="n">around</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">read</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">    </span><span class="n">endif</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">exclusive</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">guaranteed</span><span class="w"></span>
<span class="w">      </span><span class="o">!!</span><span class="w"> </span><span class="n">protected</span><span class="w"> </span><span class="n">section</span><span class="w"></span>
<span class="w">    </span><span class="n">endif</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following code example correctly ensures that the protected section is executed by only one thread at a time. Execution of the protected section by neither thread is considered correct in this example. This occurs if both flushes complete prior to either thread executing its <strong>if</strong> statement for the protected section. The compiler is prohibited from moving the flush at all for either thread, ensuring that the respective assignment is complete and the data is flushed before the <strong>if</strong> statement is executed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: mem_model.4b</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">flush_correct</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">          </span><span class="c1">// thread 0</span>
<span class="w">      </span><span class="cp">#pragma omp atomic write</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp flush(a,b)    </span><span class="c1">// flushes are ordered</span>
<span class="w">      </span><span class="cp">#pragma omp atomic read</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">                      </span><span class="c1">// thread 1</span>
<span class="w">      </span><span class="cp">#pragma omp atomic write</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp flush(a,b)    </span><span class="c1">// flushes are ordered</span>
<span class="w">      </span><span class="cp">#pragma omp atomic read</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">           </span><span class="c1">// access by single thread</span>
<span class="w">      </span><span class="cm">/* protected section */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">mem_model</span><span class="mf">.4</span><span class="n">b</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">flush_correct</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">  </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="n">myid</span><span class="w"></span>

<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">myid</span><span class="p">,</span><span class="n">tmp</span><span class="p">)</span><span class="w"> </span><span class="n">num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">myid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w">     </span><span class="o">!</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"></span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">flushes</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">ordered</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">read</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w">                      </span><span class="o">!</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">flush</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w">        </span><span class="o">!</span><span class="w"> </span><span class="n">flushes</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">ordered</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">read</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">    </span><span class="n">endif</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="kr">thread</span><span class="w"></span>
<span class="w">      </span><span class="o">!!</span><span class="w"> </span><span class="n">protected</span><span class="w"> </span><span class="n">section</span><span class="w"></span>
<span class="w">    </span><span class="n">endif</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="memory-allocators">
<h2><span class="section-number">10.2. </span>Memory Allocators<a class="headerlink" href="#memory-allocators" title="Permalink to this headline">#</a></h2>
<p>OpenMP memory allocators can be used to allocate memory with specific allocator traits.  In the following example an OpenMP allocator is used to specify an alignment for arrays  <em>x</em>  and  <em>y</em> . The general approach for attributing traits to variables allocated by OpenMP is to create or specify a pre-defined  <em>memory space</em> , create an array of  <em>traits</em> , and then form an  <em>allocator</em>  from the memory space and trait. The allocator is then specified in an OpenMP allocation (using an API  <em>omp_alloc()</em>  function for C/C++ code and an <strong>allocators</strong> directive for Fortran code in the  <em>allocators.1</em>  example).</p>
<p>In the example below the  <em>xy_memspace</em>  variable is declared and assigned the default memory space ( <em>omp_default_mem_space</em> ). Next, an array for  <em>traits</em>  is created. Since only one trait will be used, the array size is  <em>1</em> . A trait is a structure in C/C++ and a derived type in Fortran, containing 2 components: a key and a corresponding value (key-value pair). The trait key used here is  <em>omp_atk_alignment</em>  (an enum for C/C++ and a parameter for Fortran) and the trait value of 64 is specified in the  <em>xy_traits</em>  declaration. These declarations are followed by a call to the  <em>omp_init_allocator()</em>  function to combine the memory space ( <em>xy_memspace</em> ) and the traits ( <em>xy_traits</em> ) to form an allocator ( <em>xy_alloc</em> ).</p>
<p>In the C/C++ code the API   <em>omp_allocate()</em>  function is used to allocate space, similar to  <em>malloc</em> , except that the allocator is specified as the second argument. In Fortran an <strong>allocators</strong> directive is used to specify an allocator for the following Fortran  <em>allocate</em>  statement. A variable list in the <strong>allocate</strong> clause may be supplied if the allocator is to be applied to a subset of variables in the Fortran allocate statement. Here, the  <em>xy_alloc</em>  allocator is specified in the modifier of the <strong>allocator</strong> clause, and the set of all variables used in the  <em>allocate</em>  statement is specified in the list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: allocators.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w">    </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">  </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 1000</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w">  </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">s</span><span class="o">=</span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">omp_memspace_handle_t</span><span class="w">  </span><span class="n">xy_memspace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_default_mem_space</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">omp_alloctrait_t</span><span class="w">       </span><span class="n">xy_traits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">omp_atk_alignment</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="n">omp_allocator_handle_t</span><span class="w"> </span><span class="n">xy_alloc</span><span class="w">    </span><span class="o">=</span><span class="w"></span>
<span class="w">                           </span><span class="n">omp_init_allocator</span><span class="p">(</span><span class="n">xy_memspace</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">xy_traits</span><span class="p">);</span><span class="w"></span>


<span class="w">   </span><span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">omp_alloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">xy_alloc</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">omp_alloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">xy_alloc</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">((</span><span class="kt">intptr_t</span><span class="p">)(</span><span class="n">y</span><span class="p">))</span><span class="o">%</span><span class="mi">64</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">((</span><span class="kt">intptr_t</span><span class="p">)(</span><span class="n">x</span><span class="p">))</span><span class="o">%</span><span class="mi">64</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ERROR: x|y not 64-Byte aligned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp for simd simdlen(16) aligned(x,y:64)</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// initialize</span>

<span class="w">      </span><span class="cp">#pragma omp for simd simdlen(16) aligned(x,y:64)</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;y[0],y[N-1]: %5.0f %5.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="c1">// output y[0],y[N-1]: 3 3000</span>

<span class="w">   </span><span class="n">omp_free</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">xy_alloc</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">omp_free</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">xy_alloc</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">omp_destroy_allocator</span><span class="p">(</span><span class="n">xy_alloc</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: allocators.1
! type: F-free
! version: omp_5.2
program main
 use omp_lib

 integer, parameter :: N=1000
 real, allocatable  :: x(:),y(:)
 real               :: s = 2.0e0
 integer            :: i

 integer(omp_memspace_handle_kind ) :: xy_memspace = omp_default_mem_space
 type(   omp_alloctrait           ) :: xy_traits(1) = &amp;
                                    [omp_alloctrait(omp_atk_alignment,64)]
 integer(omp_allocator_handle_kind) :: xy_alloc

   xy_alloc   =    omp_init_allocator(   xy_memspace, 1, xy_traits)

   !$omp allocators allocate(allocator(xy_alloc): x, y)
   allocate(x(N),y(N))
                         !! loc is non-standard, but found everywhere
                         !! remove these lines if not available
   if(modulo(loc(x),64) /= 0 .and. modulo(loc(y),64) /=0 ) then
      print*,&quot;ERROR: x|y not 64-byte aligned&quot;; stop
   endif

   !$omp parallel

      !$omp do simd simdlen(16) aligned(x,y: 64) !! 64B aligned
      do i=1,N  !! initialize
        x(i)=i
        y(i)=i
      end do

      !$omp do simd simdlen(16) aligned(x,y: 64) !! 64B aligned
      do i = 1,N
         y(i) = s*x(i) + y(i)
      end do

   !$omp end parallel

   write(*,&#39;(&quot;y(1),y(N):&quot;,2f6.0)&#39;) y(1),y(N) !!output: y... 3. 3000.

   deallocate(x,y)
   call omp_destroy_allocator(xy_alloc)

end program
</pre></div>
</div>
</div>
</div>
<p>When using the <strong>allocators</strong> construct with optional clauses in Fortran code,  users should be aware of the behavior of a reallocation.</p>
<p>In the following example, the  <em>a</em>  variable is allocated with 64-byte alignment through the <strong>align</strong> clause of the <strong>allocators</strong> construct. The alignment of the newly allocated object,  <em>a</em> , in the (reallocation) assignment  <em>a = b</em>  will not be reallocated with the 64-byte alignment, but with the 32-byte alignment prescribed by the trait of the  <em>my_alloctr</em>   allocator. It is best to avoid this problem by constructing and using an allocator (not the <strong>align</strong> clause) with the required alignment in  the <strong>allocators</strong> construct. Note that in the subsequent deallocation of  <em>a</em>  the deallocation must precede the destruction of the allocator used in the allocation of  <em>a</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">allocators</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>

<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">align_32</span><span class="o">=</span><span class="mi">32</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">allocatable</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">               </span><span class="o">::</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">integer</span><span class="p">(</span><span class="n">omp_memspace_handle_kind</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">my_memspace</span><span class="w"></span>
<span class="w">   </span><span class="n">type</span><span class="p">(</span><span class="w">   </span><span class="n">omp_alloctrait</span><span class="w">           </span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">my_traits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">(</span><span class="n">omp_allocator_handle_kind</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">my_alloctr</span><span class="w"></span>

<span class="w">   </span><span class="n">my_memspace</span><span class="w">  </span><span class="o">=</span><span class="w">  </span><span class="n">omp_default_mem_space</span><span class="w"></span>
<span class="w">   </span><span class="n">my_traits</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">omp_alloctrait</span><span class="p">(</span><span class="n">omp_atk_alignment</span><span class="p">,</span><span class="n">align_32</span><span class="p">)]</span><span class="w"></span>
<span class="o">!</span><span class="w">                                     </span><span class="n">allocator</span><span class="w"> </span><span class="n">alignment</span><span class="w"> </span><span class="o">^^</span><span class="w"></span>
<span class="w">   </span><span class="n">my_alloctr</span><span class="w">   </span><span class="o">=</span><span class="w">  </span><span class="n">omp_init_allocator</span><span class="p">(</span><span class="n">my_memspace</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">my_traits</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">allocators</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="n">allocator</span><span class="p">(</span><span class="n">my_alloctr</span><span class="p">),</span><span class="w"> </span><span class="n">align</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">allocate</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="n">byte</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="o">&lt;---------^^</span><span class="w"></span>

<span class="w">   </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">reallocation</span><span class="w"> </span><span class="n">occurs</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mi">32</span><span class="o">-</span><span class="n">byte</span><span class="w"> </span><span class="n">alignment</span><span class="w"></span>
<span class="w">          </span><span class="o">!</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">just</span><span class="w"> </span><span class="n">my_alloctr</span><span class="w"> </span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">byte</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">allocator</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">deallocate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">Uses</span><span class="w"> </span><span class="n">my_alloctr</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">deallocation</span><span class="p">.</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">omp_destroy_allocator</span><span class="p">(</span><span class="n">my_alloctr</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>When creating and using an <strong>allocators</strong> construct within a Fortran procedure for allocating storage (and subsequently freeing the allocator storage with an  <strong>omp_destroy_allocator</strong> construct), users should be aware of the necessity of using an explicit Fortran deallocation instead of relying on auto-deallocation.</p>
<p>In the following example, a user-defined allocator is used in the allocation of the  <em>c</em>  variable, and then the allocator is destroyed. Auto-deallocation at the end of the  <em>broken_auto_deallocation</em>  procedure will fail without the allocator, hence an explicit deallocation should be used  (before the <strong>omp_destroy_allocator</strong> construct). Note that an allocator may be specified directly in the <strong>allocate</strong> clause without using the <strong>allocator</strong> complex modifier, so long as no other modifier  is specified in the clause.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">allocators</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">broken_auto_deallocation</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">align_32</span><span class="o">=</span><span class="mi">32</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">allocatable</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">integer</span><span class="p">(</span><span class="n">omp_memspace_handle_kind</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">my_memspace</span><span class="w"></span>
<span class="w">   </span><span class="n">type</span><span class="p">(</span><span class="w">   </span><span class="n">omp_alloctrait</span><span class="w">           </span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">my_traits</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">(</span><span class="n">omp_allocator_handle_kind</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">my_alloctr</span><span class="w"></span>

<span class="w">   </span><span class="n">my_memspace</span><span class="w">  </span><span class="o">=</span><span class="w">  </span><span class="n">omp_default_mem_space</span><span class="w"></span>
<span class="w">   </span><span class="n">my_traits</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">omp_alloctrait</span><span class="p">(</span><span class="n">omp_atk_alignment</span><span class="p">,</span><span class="n">align_32</span><span class="p">)]</span><span class="w"></span>
<span class="w">   </span><span class="n">my_alloctr</span><span class="w">   </span><span class="o">=</span><span class="w">  </span><span class="n">omp_init_allocator</span><span class="p">(</span><span class="n">my_memspace</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">my_traits</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">allocators</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="n">my_alloctr</span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">allocate</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="p">...</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">omp_destroy_allocator</span><span class="p">(</span><span class="n">my_alloctr</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="w"> </span><span class="n">Auto</span><span class="o">-</span><span class="n">deallocation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">fails</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">my_alloctr</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">longer</span><span class="w"> </span><span class="n">available</span><span class="p">.</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The <strong>allocate</strong> directive is a convenient way to apply an OpenMP  allocator to the allocation of declared variables.</p>
<p>This example illustrates the allocation of specific types of storage in a program  for use in libraries, privatized variables, and with offloading.</p>
<p>Two groups of variables, { <em>v1, v2</em> } and { <em>v3, v4</em> }, are used with the <strong>allocate</strong>  directive, and the { <em>v5, v6</em> } pair is used with the <strong>allocate</strong> clause.  Here we explicitly use predefined allocators <strong>omp_high_bw_mem_alloc</strong> and <strong>omp_default_mem_alloc</strong> with the <strong>allocate</strong> directive in CASE 1. Similar effects are achieved for private variables of a task by using the <strong>allocate</strong> clause, as shown in CASE 2.</p>
<p>Note, when the <strong>allocate</strong> directive does not specify an <strong>allocator</strong> clause, an implementation-defined default, stored in the  <em>def-allocator-var</em>  ICV, is used (not illustrated here). Users can set and get the default allocator with the <strong>omp_set_default_allocator</strong> and <strong>omp_get_default_allocator</strong> API routines.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: allocators.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_init</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span>\
<span class="w">             </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lib_saxpy</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">my_gather</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">my_gpu_vxv</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="cp">#pragma omp end  declare target</span>

<span class="cp">#define Nhb 1024*1024      </span><span class="c1">// high bandwith</span>
<span class="cp">#define Nbg 1024*1024*64   </span><span class="c1">// big memory, default</span>
<span class="cp">#define Nll 1024*1024      </span><span class="c1">// low latency memory</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">test_allocate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="kt">double</span><span class="w">  </span><span class="n">v1</span><span class="p">[</span><span class="n">Nhb</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">Nhb</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w">  </span><span class="n">v3</span><span class="p">[</span><span class="n">Nbg</span><span class="p">],</span><span class="w"> </span><span class="n">v4</span><span class="p">[</span><span class="n">Nbg</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w">  </span><span class="n">v5</span><span class="p">[</span><span class="n">Nll</span><span class="p">],</span><span class="w"> </span><span class="n">v6</span><span class="p">[</span><span class="n">Nll</span><span class="p">];</span><span class="w"></span>

<span class="o">/</span><span class="n">_</span><span class="o">*</span><span class="w"> </span><span class="n">CASE</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">USING</span><span class="w"> </span><span class="n">ALLOCATE</span><span class="w"> </span><span class="n">DIRECTIVE</span><span class="w"> </span><span class="n">_</span><span class="o">*/</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp allocate(v1,v2) allocator(omp_high_bw_mem_alloc)</span>
<span class="w">  </span><span class="cp">#pragma omp allocate(v3,v4) allocator(omp_default_mem_alloc)</span>

<span class="w">  </span><span class="n">my_init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">Nhb</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">,</span><span class="n">Nbg</span><span class="p">,</span><span class="w"> </span><span class="n">v5</span><span class="p">,</span><span class="n">v6</span><span class="p">,</span><span class="n">Nll</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">lib_saxpy</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="mf">5.0</span><span class="p">,</span><span class="n">Nhb</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target map(to: v3[0:Nbg], v4[0:Nbg]) map(from:v3[0:Nbg])</span>
<span class="w">  </span><span class="n">my_gpu_vxv</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">,</span><span class="n">Nbg</span><span class="p">);</span><span class="w"></span>

<span class="o">/</span><span class="n">_</span><span class="o">*</span><span class="w"> </span><span class="n">CASE</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">USING</span><span class="w"> </span><span class="n">ALLOCATE</span><span class="w"> </span><span class="n">CLAUSE</span><span class="w"> </span><span class="n">_</span><span class="o">*/</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp task private(v5,v6) \</span>
<span class="cp">                   allocate(allocator(omp_low_lat_mem_alloc): v5,v6)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">my_gather</span><span class="p">(</span><span class="n">v5</span><span class="p">,</span><span class="n">v6</span><span class="p">,</span><span class="n">Nll</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">allocators</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.1</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">test_allocate</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>

<span class="w">   </span><span class="n">interface</span><span class="w"></span>
<span class="w">     </span><span class="n">subroutine</span><span class="w"> </span><span class="n">my_gpu_vxv</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="n">vb</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">     </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">va</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">vb</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">interface</span><span class="w"></span>

<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">Nhb</span><span class="o">=</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span><span class="w">   </span><span class="o">&amp;</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="n">bandwith</span><span class="w"></span>
<span class="w">                        </span><span class="n">Nbg</span><span class="o">=</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">64</span><span class="p">,</span><span class="o">&amp;</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">big</span><span class="w"> </span><span class="n">memory</span><span class="p">,</span><span class="w"> </span><span class="k">default</span><span class="w"></span>
<span class="w">                        </span><span class="n">Nll</span><span class="o">=</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="w">      </span><span class="o">!!</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="n">memory</span><span class="w"></span>

<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w">  </span><span class="o">::</span><span class="w">  </span><span class="n">v1</span><span class="p">(</span><span class="n">Nhb</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">Nhb</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w">  </span><span class="o">::</span><span class="w">  </span><span class="n">v3</span><span class="p">(</span><span class="n">Nbg</span><span class="p">),</span><span class="w"> </span><span class="n">v4</span><span class="p">(</span><span class="n">Nbg</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w">  </span><span class="o">::</span><span class="w">  </span><span class="n">v5</span><span class="p">(</span><span class="n">Nll</span><span class="p">),</span><span class="w"> </span><span class="n">v6</span><span class="p">(</span><span class="n">Nll</span><span class="p">)</span><span class="w"></span>

<span class="w"> </span><span class="o">!</span><span class="n">_</span><span class="o">*</span><span class="w"> </span><span class="n">CASE</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">USING</span><span class="w"> </span><span class="n">ALLOCATE</span><span class="w"> </span><span class="n">DIRECTIVE</span><span class="w"> </span><span class="n">_</span><span class="o">*!</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">allocator</span><span class="p">(</span><span class="n">omp_high_bw_mem_alloc</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">)</span><span class="w"> </span><span class="n">allocator</span><span class="p">(</span><span class="n">omp_default_mem_alloc</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">my_init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">Nhb</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">,</span><span class="n">Nbg</span><span class="p">,</span><span class="w"> </span><span class="n">v5</span><span class="p">,</span><span class="n">v6</span><span class="p">,</span><span class="n">Nll</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">lib_saxpy</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="mf">5.0</span><span class="p">,</span><span class="n">Nhb</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="n">v3</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">my_gpu_vxv</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">,</span><span class="n">Nbg</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w"> </span><span class="o">!</span><span class="n">_</span><span class="o">*</span><span class="w"> </span><span class="n">CASE</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">USING</span><span class="w"> </span><span class="n">ALLOCATE</span><span class="w"> </span><span class="n">CLAUSE</span><span class="w"> </span><span class="n">_</span><span class="o">*!</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">v5</span><span class="p">,</span><span class="n">v6</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">     </span><span class="n">allocate</span><span class="p">(</span><span class="n">allocator</span><span class="p">(</span><span class="n">omp_low_lat_mem_alloc</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">v5</span><span class="p">,</span><span class="n">v6</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">my_gather</span><span class="p">(</span><span class="n">v5</span><span class="p">,</span><span class="n">v6</span><span class="p">,</span><span class="n">Nll</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">test_allocate</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="race-conditions-caused-by-implied-copies-of-shared-variables-in-fortran">
<h2><span class="section-number">10.3. </span>Race Conditions Caused by Implied Copies of Shared Variables in Fortran<a class="headerlink" href="#race-conditions-caused-by-implied-copies-of-shared-variables-in-fortran" title="Permalink to this headline">#</a></h2>
<p>The following example contains a race condition, because the shared variable, which  is an array section, is passed as an actual argument to a routine that has an assumed-size  array as its dummy argument. The subroutine call passing an array section argument  may cause the compiler to copy the argument into a temporary location prior to  the call and copy from the temporary location into the original variable when the  subroutine returns. This copying would cause races in the <strong>parallel</strong> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">fort_race</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SHARED_RACE</span><span class="w"></span>

<span class="w">  </span><span class="n">INCLUDE</span><span class="w"> </span><span class="s">&quot;omp_lib.h&quot;</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">USE</span><span class="w"> </span><span class="n">OMP_LIB</span><span class="w"></span>

<span class="w">  </span><span class="n">REAL</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">MYTHREAD</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SHARED</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">PRIVATE</span><span class="p">(</span><span class="n">MYTHREAD</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">MYTHREAD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OMP_GET_THREAD_NUM</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">MYTHREAD</span><span class="w"> </span><span class="p">.</span><span class="n">EQ</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="w">     </span><span class="n">CALL</span><span class="w"> </span><span class="n">SUB</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">compiler</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="n">introduce</span><span class="w"> </span><span class="n">writes</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">6</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">ELSE</span><span class="w"></span>
<span class="w">     </span><span class="n">A</span><span class="p">(</span><span class="mi">6</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="w"></span>
<span class="w">  </span><span class="n">ENDIF</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SHARED_RACE</span><span class="w"></span>

<span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">REAL</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">SUB</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents/Chap_memory_model"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../Chap_data_environment/Chap_data_environment.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">9. </span>Data Environment</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../Chap_program_control/Chap_program_control.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">11. </span>Program Control</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The OpenMP Community<br/>
  
      &copy; <a href="../../copyright.html">Copyright</a> 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>