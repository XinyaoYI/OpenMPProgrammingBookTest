
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Parallel Execution &#8212; OpenMP Application Programming Interface Examples</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="OpenMP Affinity" href="Chap_affinity.html" />
    <link rel="prev" title="OpenMP Directive Syntax" href="Chap_directives.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Welcome to OMP Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Title_Page.html">
   Cover
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Foreword_Chapt.html">
   Foreword
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_introduction.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_directives.html">
   OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_affinity.html">
   OpenMP Affinity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_tasking.html">
   Tasking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_SIMD.html">
   SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_synchronization.html">
   Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_data_environment.html">
   Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_memory_model.html">
   Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_program_control.html">
   Program Control
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_parallel_execution.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/passlab/Examples"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_parallel_execution.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/contents/Chap_parallel_execution.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-simple-parallel-loop">
   A Simple Parallel Loop
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-construct">
   <strong>
    parallel
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#teams-construct-on-host">
   <strong>
    teams
   </strong>
   Construct on Host
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#controlling-the-number-of-threads-on-multiple-nesting-levels">
   Controlling the Number of Threads on Multiple Nesting Levels
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interaction-between-the-num-threads-clause-and-omp-set-dynamic">
   Interaction Between the
   <strong>
    num_threads
   </strong>
   Clause and
   <strong>
    omp_set_dynamic
   </strong>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fortran-restrictions-on-the-do-construct">
   Fortran Restrictions on the
   <strong>
    do
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nowait-clause">
   <strong>
    nowait
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#collapse-clause">
   <strong>
    collapse
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linear-clause-in-loop-constructs">
   <strong>
    linear
   </strong>
   Clause in Loop Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-sections-construct">
   <strong>
    parallel
   </strong>
   <strong>
    sections
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#firstprivate-clause-and-sections-construct">
   <strong>
    firstprivate
   </strong>
   Clause and
   <strong>
    sections
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#single-construct">
   <strong>
    single
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#workshare-construct">
   <strong>
    workshare
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#masked-construct">
   <strong>
    masked
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loop-construct">
   <strong>
    loop
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-random-access-iterator-loop">
   Parallel Random Access Iterator Loop
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#omp-set-dynamic-and-omp-set-num-threads-routines">
   <strong>
    omp_set_dynamic
   </strong>
   and
   <strong>
    omp_set_num_threads
   </strong>
   Routines
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#omp-get-num-threads-routine">
   <strong>
    omp_get_num_threads
   </strong>
   Routine
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Parallel Execution</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-simple-parallel-loop">
   A Simple Parallel Loop
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-construct">
   <strong>
    parallel
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#teams-construct-on-host">
   <strong>
    teams
   </strong>
   Construct on Host
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#controlling-the-number-of-threads-on-multiple-nesting-levels">
   Controlling the Number of Threads on Multiple Nesting Levels
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interaction-between-the-num-threads-clause-and-omp-set-dynamic">
   Interaction Between the
   <strong>
    num_threads
   </strong>
   Clause and
   <strong>
    omp_set_dynamic
   </strong>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fortran-restrictions-on-the-do-construct">
   Fortran Restrictions on the
   <strong>
    do
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nowait-clause">
   <strong>
    nowait
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#collapse-clause">
   <strong>
    collapse
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linear-clause-in-loop-constructs">
   <strong>
    linear
   </strong>
   Clause in Loop Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-sections-construct">
   <strong>
    parallel
   </strong>
   <strong>
    sections
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#firstprivate-clause-and-sections-construct">
   <strong>
    firstprivate
   </strong>
   Clause and
   <strong>
    sections
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#single-construct">
   <strong>
    single
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#workshare-construct">
   <strong>
    workshare
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#masked-construct">
   <strong>
    masked
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loop-construct">
   <strong>
    loop
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parallel-random-access-iterator-loop">
   Parallel Random Access Iterator Loop
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#omp-set-dynamic-and-omp-set-num-threads-routines">
   <strong>
    omp_set_dynamic
   </strong>
   and
   <strong>
    omp_set_num_threads
   </strong>
   Routines
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#omp-get-num-threads-routine">
   <strong>
    omp_get_num_threads
   </strong>
   Routine
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="parallel-execution">
<h1>Parallel Execution<a class="headerlink" href="#parallel-execution" title="Permalink to this headline">#</a></h1>
<p>A single thread, the  <em>initial thread</em> , begins sequential execution of  an OpenMP enabled program, as if the whole program is in an implicit parallel region consisting of an implicit task executed by the  <em>initial thread</em> .</p>
<p>A <strong>parallel</strong> construct encloses code,  forming a parallel region.  An  <em>initial thread</em>  encountering a <strong>parallel</strong>  region forks (creates) a team of threads at the beginning of the  <strong>parallel</strong> region, and joins them (removes from execution) at the  end of the region.  The initial thread becomes the primary thread of the team in a  <strong>parallel</strong> region with a  <em>thread</em>  number equal to zero, the other  threads are numbered from 1 to number of threads minus 1.  A team may be comprised of just a single thread.</p>
<p>Each thread of a team is assigned an implicit task consisting of code within the  parallel region. The task that creates a parallel region is suspended while the tasks of the team are executed.  A thread is tied to its task; that is, only the thread assigned to the task can execute that task.  After completion  of the <strong>parallel</strong> region, the primary thread resumes execution of the generating task.</p>
<p>Any task within a <strong>parallel</strong> region is allowed to encounter another <strong>parallel</strong> region to form a nested <strong>parallel</strong> region. The  parallelism of a nested <strong>parallel</strong> region (whether it forks additional  threads, or is executed serially by the encountering task) can be controlled by the <strong>OMP_NESTED</strong> environment variable or the <strong>omp_set_nested()</strong>  API routine with arguments indicating true or false.</p>
<p>The number of threads of a <strong>parallel</strong> region can be set by the <strong>OMP_NUM_THREADS</strong> environment variable, the <strong>omp_set_num_threads()</strong> routine, or on the <strong>parallel</strong>  directive with the <strong>num_threads</strong> clause. The routine overrides the environment variable, and the clause overrides all.  Use the <strong>OMP_DYNAMIC</strong> or the <strong>omp_set_dynamic()</strong> function to specify that the OpenMP implementation dynamically adjust the number of threads for <strong>parallel</strong> regions.  The default setting for dynamic adjustment is implementation defined. When dynamic adjustment is on and the number of threads is specified, the number of threads becomes an upper limit for the number of threads to be provided by the OpenMP runtime.</p>
<p>WORKSHARING CONSTRUCTS</p>
<p>A worksharing construct distributes the execution of the associated region among the members of the team that encounter it.  There is an implied barrier at the end of the worksharing region (there is no barrier at the beginning). The worksharing constructs are:</p>
<ul class="simple">
<li><p>loop constructs: <strong>for</strong> and <strong>do</strong></p></li>
<li><p><strong>sections</strong></p></li>
<li><p><strong>single</strong></p></li>
<li><p><strong>workshare</strong></p></li>
</ul>
<p>The <strong>for</strong> and <strong>do</strong> constructs (loop constructs) create a region  consisting of a loop.  A loop controlled by a loop construct is called  an  <em>associated</em>  loop.  Nested loops can form a single region when the  <strong>collapse</strong> clause (with an integer argument) designates the number of   <em>associated</em>  loops to be executed in parallel, by forming a  “single iteration space” for the specified number of nested loops.   The <strong>ordered</strong> clause can also control multiple associated loops.</p>
<p>An associated loop must adhere to a “canonical form” (specified in the   <em>Canonical Loop Form</em>  of the OpenMP Specifications document) which allows the  iteration count (of all associated loops) to be computed before the  (outermost) loop is executed. Most common loops comply with the canonical form, including C++ iterators.</p>
<p>A <strong>single</strong> construct forms a region in which only one thread (any one  of the team) executes the region.  The other threads wait at the implied  barrier at the end, unless the <strong>nowait</strong> clause is specified.</p>
<p>The <strong>sections</strong> construct forms a region that contains one or more  structured blocks.  Each block of a <strong>sections</strong> directive is  constructed with a <strong>section</strong> construct, and executed once by  one of the threads (any one) in the team.  (If only one block is  formed in the region, the <strong>section</strong> construct, which is used to separate blocks, is not required.) The other threads wait at the implied  barrier at the end, unless the <strong>nowait</strong> clause is specified.</p>
<p>The <strong>workshare</strong> construct is a Fortran feature that consists of a region with a single structure block (section of code). Statements in the <strong>workshare</strong> region are divided into units of work, and executed (once) by threads of the team.</p>
<p>MASKED CONSTRUCT</p>
<p>The <strong>masked</strong> construct is not a worksharing construct.  The <strong>masked</strong> region is executed only by the primary thread. There is no implicit barrier (and flush)  at the end of the <strong>masked</strong> region; hence the other threads of the team continue execution beyond code statements beyond the <strong>masked</strong> region. The <strong>master</strong> construct, which has been deprecated in OpenMP 5.1, has identical semantics to the <strong>masked</strong> construct with no <strong>filter</strong> clause.</p>
<section id="a-simple-parallel-loop">
<h2>A Simple Parallel Loop<a class="headerlink" href="#a-simple-parallel-loop" title="Permalink to this headline">#</a></h2>
<p>The following example demonstrates how to parallelize a simple loop  using the parallel worksharing-loop construct. The loop iteration variable is private by default, so it is not  necessary to specify it explicitly in a <strong>private</strong> clause.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: ploop.1
* type: C
*/
void simple(int n, float *a, float *b)
{
    int i;

#pragma omp parallel for
    for (i=1; i&lt;n; i++) /* i is private by default */
        b[i] = (a[i] + a[i-1]) / 2.0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: ploop.1
! type: F-fixed
      SUBROUTINE SIMPLE(N, A, B)

      INTEGER I, N
      REAL B(N), A(N)

!$OMP PARALLEL DO  !I is private by default
      DO I=2,N
          B(I) = (A(I) + A(I-1)) / 2.0
      ENDDO
!$OMP END PARALLEL DO

      END SUBROUTINE SIMPLE

</pre></div>
</div>
</div>
</div>
</section>
<section id="parallel-construct">
<h2><strong>parallel</strong> Construct<a class="headerlink" href="#parallel-construct" title="Permalink to this headline">#</a></h2>
<p>The <strong>parallel</strong> construct  can be used in coarse-grain parallel programs.  In the following example, each thread in the <strong>parallel</strong> region decides what  part of the global array  <em>x</em>  to work on, based on the thread number:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: parallel.1
* type: C
*/
#include &lt;omp.h&gt;

void subdomain(float *x, int istart, int ipoints)
{
  int i;

  for (i = 0; i &lt; ipoints; i++)
      x[istart+i] = 123.456;
}

void sub(float *x, int npoints)
{
    int iam, nt, ipoints, istart;

#pragma omp parallel default(shared) private(iam,nt,ipoints,istart)
    {
        iam = omp_get_thread_num();
        nt =  omp_get_num_threads();
        ipoints = npoints / nt;    /* size of partition */
        istart = iam * ipoints;  /* starting array index */
        if (iam == nt-1)     /* last thread may do more */
          ipoints = npoints - istart;
        subdomain(x, istart, ipoints);
    }
}

int main()
{
    float array[10000];

    sub(array, 10000);

    return 0;
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: parallel.1
! type: F-fixed
      SUBROUTINE SUBDOMAIN(X, ISTART, IPOINTS)
          INTEGER ISTART, IPOINTS
          REAL X(*)

          INTEGER I

          DO 100 I=1,IPOINTS
             X(ISTART+I) = 123.456
 100      CONTINUE

      END SUBROUTINE SUBDOMAIN

      SUBROUTINE SUB(X, NPOINTS)
          INCLUDE &quot;omp_lib.h&quot;     ! or USE OMP_LIB

          REAL X(*)
          INTEGER NPOINTS
          INTEGER IAM, NT, IPOINTS, ISTART

!$OMP PARALLEL DEFAULT(PRIVATE) SHARED(X,NPOINTS)

          IAM = OMP_GET_THREAD_NUM()
          NT =  OMP_GET_NUM_THREADS()
          IPOINTS = NPOINTS/NT
          ISTART = IAM * IPOINTS
          IF (IAM .EQ. NT-1) THEN
              IPOINTS = NPOINTS - ISTART
          ENDIF
          CALL SUBDOMAIN(X,ISTART,IPOINTS)

!$OMP END PARALLEL
      END SUBROUTINE SUB

      PROGRAM PAREXAMPLE
          REAL ARRAY(10000)
          CALL SUB(ARRAY, 10000)
      END PROGRAM PAREXAMPLE

</pre></div>
</div>
</div>
</div>
</section>
<section id="teams-construct-on-host">
<h2><strong>teams</strong> Construct on Host<a class="headerlink" href="#teams-construct-on-host" title="Permalink to this headline">#</a></h2>
<p><strong>constructs!teams <strong>teams</strong></strong> <strong>teams construct <strong>teams</strong> construct</strong></p>
<p>Originally the <strong>teams</strong> construct was created for devices (such as GPUs) for independent executions of a structured block by teams within a league (on SMs). It was only available through offloading with the <strong>target</strong> construct, and the execution of a <strong>teams</strong> region could only be directed to host execution by various means such as <strong>if</strong> and <strong>device</strong> clauses, and the <strong>OMP_TARGET_OFFLOAD</strong> environment variable.</p>
<p>In OpenMP 5.0 the <strong>teams</strong> construct was extended to enable the host to execute a <strong>teams</strong> region (without an associated <strong>target</strong> construct),  with anticipation of further affinity and threading controls in future OpenMP releases.</p>
<p>In the example below the <strong>teams</strong> construct is used to create two teams, one to execute single precision code, and the other to execute double precision code. Two teams are required, and the thread limit for each team is set to 1/2 of the number of  available processors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: host_teams.1
* type: C
* version: omp_5.0
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include  &lt;math.h&gt;
#include   &lt;omp.h&gt;
#define    N 1000

int main(){
   int     nteams_required=2, max_thrds, tm_id;
   float   sp_x[N], sp_y[N], sp_a=0.0001e0;
   double  dp_x[N], dp_y[N], dp_a=0.0001e0;

   max_thrds = omp_get_num_procs()/nteams_required;

   // Create 2 teams, each team works in a different precision
   #pragma omp teams num_teams(nteams_required) \
                     thread_limit(max_thrds)  private(tm_id)
   {
      tm_id = omp_get_team_num();

      if( omp_get_num_teams() != 2 )   //if only getting 1, quit
      { printf(&quot;error: Insufficient teams on host, 2 required\n&quot;);
        exit(0);
      }

      if(tm_id == 0)  // Do Single Precision Work (SAXPY) with this team
      {
         #pragma omp parallel
         {
            #pragma omp for                             //init
            for(int i=0; i&lt;N; i++){sp_x[i] = i*0.0001;  sp_y[i]=i; }

            #pragma omp for simd simdlen(8)
            for(int i=0; i&lt;N; i++){sp_x[i] = sp_a*sp_x[i] + sp_y[i];}
         }
      }

      if(tm_id == 1)  // Do Double Precision Work (DAXPY) with this team
      {
         #pragma omp parallel
         {
            #pragma omp for                             //init
            for(int i=0; i&lt;N; i++){dp_x[i] = i*0.0001;  dp_y[i]=i; }

            #pragma omp for simd simdlen(4)
            for(int i=0; i&lt;N; i++){dp_x[i] = dp_a*dp_x[i] + dp_y[i];}
         }
      }
   }

   printf(&quot;i=%d  sp|dp  %f %f \n&quot;,N-1, sp_x[N-1], dp_x[N-1]);
   printf(&quot;i=%d  sp|dp  %f %f \n&quot;,N/2, sp_x[N/2], dp_x[N/2]);
 //OUTPUT1:i=999  sp|dp  999.000000 999.000010
 //OUTPUT2:i=500  sp|dp  500.000000 500.000005

   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: host_teams.1
! type: F-free
! version: omp_5.0

program main
   use omp_lib
   integer           :: nteams_required=2, max_thrds, tm_id
   integer,parameter ::  N=1000
   real              :: sp_x(N), sp_y(N), sp_a=0.0001e0
   double precision  :: dp_x(N), dp_y(N), dp_a=0.0001d0

   max_thrds = omp_get_num_procs()/nteams_required

   !! Create 2 teams, each team works in a different precision
   !$omp teams num_teams(nteams_required) thread_limit(max_thrds) \
               private(tm_id)

      tm_id = omp_get_team_num()

      if( omp_get_num_teams() /= 2 ) then   !! if only getting 1, quit
         stop &quot;error: Insufficient teams on host, 2 required.&quot;
      endif

      !! Do Single Precision Work (SAXPY) with this team
      if(tm_id == 0) then

         !$omp parallel
            !$omp do         !! init
            do i = 1,N
               sp_x(i) = i*0.0001e0
               sp_y(i) = i
            end do

            !$omp do simd simdlen(8)
            do i = 1,N
               sp_x(i) = sp_a*sp_x(i) + sp_y(i)
            end do
         !$omp end parallel

      endif

      !! Do Double Precision Work (DAXPY) with this team
      if(tm_id == 1) then

         !$omp parallel
            !$omp do         !! init
            do i = 1,N
               dp_x(i) = i*0.0001d0
               dp_y(i) = i
            end do

            !$omp do simd simdlen(4)
            do i = 1,N
               dp_x(i) = dp_a*dp_x(i) + dp_y(i)
            end do
         !$omp end parallel

      endif
   !$omp end teams

   write(*,&#39;( &quot;i=&quot;,i4,&quot; sp|dp= &quot;, e15.7, d25.16  )&#39;) &amp;
            N, sp_x(N), dp_x(N)
   write(*,&#39;( &quot;i=&quot;,i4,&quot; sp|dp= &quot;, e15.7, d25.16  )&#39;) &amp;
            N/2, sp_x(N/2), dp_x(N/2)
            !! i=1000 sp|dp=   0.1000000E+04   0.1000000010000000D+04
            !! i= 500 sp|dp=   0.5000000E+03   0.5000000050000000D+03
end program

</pre></div>
</div>
</div>
</div>
</section>
<section id="controlling-the-number-of-threads-on-multiple-nesting-levels">
<h2>Controlling the Number of Threads on Multiple Nesting Levels<a class="headerlink" href="#controlling-the-number-of-threads-on-multiple-nesting-levels" title="Permalink to this headline">#</a></h2>
<p>The following examples demonstrate how to use the <strong>OMP_NUM_THREADS</strong> environment  variable  to control the number of threads on multiple nesting levels:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nthrs_nesting.1
* type: C
*/
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;
int main (void)
{
   omp_set_nested(1);
   omp_set_dynamic(0);
   #pragma omp parallel
   {
      #pragma omp parallel
      {
         #pragma omp single
         {
         /*
         * If OMP_NUM_THREADS=2,3 was set, the following should print:
         * Inner: num_thds=3
         * Inner: num_thds=3
         *
         * If nesting is not supported, the following should print:
         * Inner: num_thds=1
         * Inner: num_thds=1
         */
            printf (&quot;Inner: num_thds=%d\n&quot;, omp_get_num_threads());
         }
      }
      #pragma omp barrier
      omp_set_nested(0);
      #pragma omp parallel
      {
         #pragma omp single
         {
         /*
         * Even if OMP_NUM_THREADS=2,3 was set, the following should
         * print, because nesting is disabled:
         * Inner: num_thds=1
         * Inner: num_thds=1
         */
            printf (&quot;Inner: num_thds=%d\n&quot;, omp_get_num_threads());
         }
      }
      #pragma omp barrier
      #pragma omp single
      {
         /*
         * If OMP_NUM_THREADS=2,3 was set, the following should print:
         * Outer: num_thds=2
         */
         printf (&quot;Outer: num_thds=%d\n&quot;, omp_get_num_threads());
      }
   }
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: nthrs_nesting.1
! type: F-fixed
 program icv
 use omp_lib
 call omp_set_nested(.true.)
 call omp_set_dynamic(.false.)
!$omp parallel
!$omp parallel
!$omp single
 ! If OMP_NUM_THREADS=2,3 was set, the following should print:
 ! Inner: num_thds= 3
 ! Inner: num_thds= 3
 ! If nesting is not supported, the following should print:
 ! Inner: num_thds= 1
 ! Inner: num_thds= 1
 print *, &quot;Inner: num_thds=&quot;, omp_get_num_threads()
!$omp end single
!$omp end parallel
!$omp barrier
 call omp_set_nested(.false.)
!$omp parallel
!$omp single
 ! Even if OMP_NUM_THREADS=2,3 was set, the following should print,
 ! because nesting is disabled:
 ! Inner: num_thds= 1
 ! Inner: num_thds= 1
 print *, &quot;Inner: num_thds=&quot;, omp_get_num_threads()
!$omp end single
!$omp end parallel
!$omp barrier
!$omp single
 ! If OMP_NUM_THREADS=2,3 was set, the following should print:
 ! Outer: num_thds= 2
 print *, &quot;Outer: num_thds=&quot;, omp_get_num_threads()
!$omp end single
!$omp end parallel
 end

</pre></div>
</div>
</div>
</div>
</section>
<section id="interaction-between-the-num-threads-clause-and-omp-set-dynamic">
<h2>Interaction Between the <strong>num_threads</strong> Clause and <strong>omp_set_dynamic</strong><a class="headerlink" href="#interaction-between-the-num-threads-clause-and-omp-set-dynamic" title="Permalink to this headline">#</a></h2>
<p>The following example demonstrates the <strong>num_threads</strong> clause  and the effect  of the  <strong>omp_set_dynamic</strong> routine  on it.</p>
<p>The call to the <strong>omp_set_dynamic</strong> routine with argument <strong>0</strong> in  C/C++, or <strong>.FALSE.</strong> in Fortran, disables the dynamic adjustment of the number  of threads in OpenMP implementations that support it. In this case, 10 threads  are provided. Note that in case of an error the OpenMP implementation is free to  abort the program or to supply any number of threads available.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nthrs_dynamic.1
* type: C
*/
#include &lt;omp.h&gt;
int main()
{
  omp_set_dynamic(0);
  #pragma omp parallel num_threads(10)
  {
    /* do work here */
  }
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: nthrs_dynamic.1
! type: F-fixed
      PROGRAM EXAMPLE
        INCLUDE &quot;omp_lib.h&quot;      ! or USE OMP_LIB
        CALL OMP_SET_DYNAMIC(.FALSE.)
!$OMP     PARALLEL NUM_THREADS(10)
            ! do work here
!$OMP     END PARALLEL
      END PROGRAM EXAMPLE
</pre></div>
</div>
</div>
</div>
<p>The call to the <strong>omp_set_dynamic</strong> routine with a non-zero argument in  C/C++, or <strong>.TRUE.</strong> in Fortran, allows the OpenMP implementation to choose  any number of threads between 1 and 10.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nthrs_dynamic.2
* type: C
*/
#include &lt;omp.h&gt;
int main()
{
  omp_set_dynamic(1);
  #pragma omp parallel num_threads(10)
  {
    /* do work here */
  }
  return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: nthrs_dynamic.2
! type: F-fixed
      PROGRAM EXAMPLE
        INCLUDE &quot;omp_lib.h&quot;      ! or USE OMP_LIB
        CALL OMP_SET_DYNAMIC(.TRUE.)
!$OMP     PARALLEL NUM_THREADS(10)
            ! do work here
!$OMP     END PARALLEL
      END PROGRAM EXAMPLE
</pre></div>
</div>
</div>
</div>
<p>It is good practice to set the  <em>dyn-var</em>  ICV explicitly by calling the <strong>omp_set_dynamic</strong>  routine, as its default setting is implementation defined.</p>
</section>
<section id="fortran-restrictions-on-the-do-construct">
<h2>Fortran Restrictions on the <strong>do</strong> Construct<a class="headerlink" href="#fortran-restrictions-on-the-do-construct" title="Permalink to this headline">#</a></h2>
<p>If an <strong>end do</strong> directive follows a  <em>do-construct</em>   in which several  <strong>DO</strong> statements share a <strong>DO</strong> termination statement, then a  <strong>do</strong>  directive can only be specified for the outermost of these <strong>DO</strong> statements.  The following example contains correct usages of loop constructs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: fort_do.1
! type: F-fixed
      SUBROUTINE WORK(I, J)
      INTEGER I,J
      END SUBROUTINE WORK

      SUBROUTINE DO_GOOD()
        INTEGER I, J
        REAL A(1000)

        DO 100 I = 1,10
!$OMP     DO
          DO 100 J = 1,10
            CALL WORK(I,J)
100     CONTINUE      !  !$OMP ENDDO implied here

!$OMP   DO
        DO 200 J = 1,10
200       A(I) = I + 1
!$OMP   ENDDO

!$OMP   DO
        DO 300 I = 1,10
          DO 300 J = 1,10
            CALL WORK(I,J)
300     CONTINUE
!$OMP   ENDDO
      END SUBROUTINE DO_GOOD

</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because the matching <strong>do</strong> directive  for the <strong>end do</strong> does not precede the outermost loop:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: fort_do.2
! type: F-fixed
      SUBROUTINE WORK(I, J)
      INTEGER I,J
      END SUBROUTINE WORK

      SUBROUTINE DO_WRONG
        INTEGER I, J

        DO 100 I = 1,10
!$OMP     DO
          DO 100 J = 1,10
            CALL WORK(I,J)
100     CONTINUE
!$OMP   ENDDO
      END SUBROUTINE DO_WRONG
</pre></div>
</div>
</div>
</div>
</section>
<section id="nowait-clause">
<h2><strong>nowait</strong> Clause<a class="headerlink" href="#nowait-clause" title="Permalink to this headline">#</a></h2>
<p><strong>clauses!nowait <strong>nowait</strong></strong> <strong>nowait clause <strong>nowait</strong> clause</strong></p>
<p>If there are multiple independent loops within a <strong>parallel</strong> region, you  can use the <strong>nowait</strong> clause to avoid the implied barrier at the end of the  loop construct, as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nowait.1
* type: C
*/
#include &lt;math.h&gt;

void nowait_example(int n, int m, float *a, float *b, float *y, float *z)
{
  int i;
  #pragma omp parallel
  {
    #pragma omp for nowait
      for (i=1; i&lt;n; i++)
        b[i] = (a[i] + a[i-1]) / 2.0;

    #pragma omp for nowait
      for (i=0; i&lt;m; i++)
        y[i] = sqrt(z[i]);
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: nowait.1
! type: F-fixed
        SUBROUTINE NOWAIT_EXAMPLE(N, M, A, B, Y, Z)

        INTEGER N, M
        REAL A(*), B(*), Y(*), Z(*)

        INTEGER I

!$OMP PARALLEL

!$OMP DO
        DO I=2,N
          B(I) = (A(I) + A(I-1)) / 2.0
        ENDDO
!$OMP END DO NOWAIT

!$OMP DO
        DO I=1,M
          Y(I) = SQRT(Z(I))
        ENDDO
!$OMP END DO NOWAIT

!$OMP END PARALLEL

        END SUBROUTINE NOWAIT_EXAMPLE
</pre></div>
</div>
</div>
</div>
<p>In the following example, static scheduling distributes the same logical iteration  numbers to the threads that execute the three loop regions. This allows the <strong>nowait</strong>  clause to be used, even though there is a data dependence between the loops. The  dependence is satisfied as long the same thread executes the same logical iteration  numbers in each loop.</p>
<p>Note that the iteration count of the loops must be the same. The example satisfies  this requirement, since the iteration space of the first two loops is from <strong>0</strong>  to <strong>n-1</strong> (from <strong>1</strong> to <strong>N</strong> in the Fortran version), while the  iteration space of the last loop is from <strong>1</strong> to <strong>n</strong> (<strong>2</strong> to  <strong>N+1</strong> in the Fortran version).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: nowait.2
* type: C
*/

#include &lt;math.h&gt;
void nowait_example2(int n, float *a, float *b, float *c, float *y, float
*z)
{
   int i;
#pragma omp parallel
   {
#pragma omp for schedule(static) nowait
   for (i=0; i&lt;n; i++)
      c[i] = (a[i] + b[i]) / 2.0f;
#pragma omp for schedule(static) nowait
   for (i=0; i&lt;n; i++)
      z[i] = sqrtf(c[i]);
#pragma omp for schedule(static) nowait
   for (i=1; i&lt;=n; i++)
      y[i] = z[i-1] + a[i];
   }
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: nowait.2
! type: F-free
   SUBROUTINE NOWAIT_EXAMPLE2(N, A, B, C, Y, Z)
   INTEGER N
   REAL A(*), B(*), C(*), Y(*), Z(*)
   INTEGER I
!$OMP PARALLEL
!$OMP DO SCHEDULE(STATIC)
   DO I=1,N
      C(I) = (A(I) + B(I)) / 2.0
   ENDDO
!$OMP END DO NOWAIT
!$OMP DO SCHEDULE(STATIC)
   DO I=1,N
      Z(I) = SQRT(C(I))
   ENDDO
!$OMP END DO NOWAIT
!$OMP DO SCHEDULE(STATIC)
   DO I=2,N+1
      Y(I) = Z(I-1) + A(I)
   ENDDO
!$OMP END DO NOWAIT
!$OMP END PARALLEL
   END SUBROUTINE NOWAIT_EXAMPLE2
</pre></div>
</div>
</div>
</div>
</section>
<section id="collapse-clause">
<h2><strong>collapse</strong> Clause<a class="headerlink" href="#collapse-clause" title="Permalink to this headline">#</a></h2>
<p>In the following example, the <strong>k</strong> and <strong>j</strong> loops are associated with  the loop construct. So the iterations of the <strong>k</strong> and <strong>j</strong> loops are  collapsed into one loop with a larger iteration space, and that loop is then divided  among the threads in the current team. Since the <strong>i</strong> loop is not associated  with the loop construct, it is not collapsed, and the <strong>i</strong> loop is executed  sequentially in its entirety in every iteration of the collapsed <strong>k</strong> and  <strong>j</strong> loop.</p>
<p>The variable <strong>j</strong> can be omitted from the <strong>private</strong>  clause when the  <strong>collapse</strong> clause is used since it is implicitly private. However, if the  <strong>collapse</strong> clause is omitted then <strong>j</strong> will be shared if it is omitted  from the <strong>private</strong> clause. In either case, <strong>k</strong> is implicitly private  and could be omitted from the <strong>private</strong>  clause.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: collapse.1
* type: C
* version: omp_3.0
*/

void bar(float *a, int i, int j, int k);

int kl, ku, ks, jl, ju, js, il, iu,is;

void sub(float *a)
{
    int i, j, k;

    #pragma omp for collapse(2) private(i, k, j)
    for (k=kl; k&lt;=ku; k+=ks)
       for (j=jl; j&lt;=ju; j+=js)
          for (i=il; i&lt;=iu; i+=is)
             bar(a,i,j,k);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: collapse.1
! type: F-fixed
! version: omp_3.0

      subroutine sub(a)

      real a(*)
      integer kl, ku, ks, jl, ju, js, il, iu, is
      common /csub/ kl, ku, ks, jl, ju, js, il, iu, is
      integer i, j, k

!$omp do collapse(2) private(i,j,k)
       do k = kl, ku, ks
         do j = jl, ju, js
           do i = il, iu, is
             call bar(a,i,j,k)
          enddo
        enddo
      enddo
!$omp end do

      end subroutine

</pre></div>
</div>
</div>
</div>
<p>In the next example, the <strong>k</strong> and <strong>j</strong> loops are associated with the  loop construct. So the iterations of the <strong>k</strong> and <strong>j</strong> loops are collapsed  into one loop with a larger iteration space, and that loop is then divided among  the threads in the current team.</p>
<p>The sequential execution of the iterations in the <strong>k</strong> and <strong>j</strong> loops  determines the order of the iterations in the collapsed iteration space. This implies  that in the sequentially last iteration of the collapsed iteration space, <strong>k</strong>  will have the value <strong>2</strong> and <strong>j</strong> will have the value <strong>3</strong>. Since  <strong>klast</strong> and <strong>jlast</strong> are <strong>lastprivate</strong>, their values are assigned  by the sequentially last iteration of the collapsed <strong>k</strong> and <strong>j</strong> loop.  This example prints: <strong>2 3</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: collapse.2
* type: C
* version: omp_3.0
*/

#include &lt;stdio.h&gt;
void test()
{
   int j, k, jlast, klast;
   #pragma omp parallel
   {
      #pragma omp for collapse(2) lastprivate(jlast, klast)
      for (k=1; k&lt;=2; k++)
         for (j=1; j&lt;=3; j++)
         {
            jlast=j;
            klast=k;
         }
      #pragma omp single
      printf(&quot;%d %d\n&quot;, klast, jlast);
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: collapse.2
! type: F-fixed
! version: omp_3.0

      program test
!$omp parallel
!$omp do private(j,k) collapse(2) lastprivate(jlast, klast)
      do k = 1,2
        do j = 1,3
          jlast=j
          klast=k
        enddo
      enddo
!$omp end do
!$omp single
      print *, klast, jlast
!$omp end single
!$omp end parallel
      end program test
</pre></div>
</div>
</div>
</div>
<p>The next example illustrates the interaction of the <strong>collapse</strong> and <strong>ordered</strong>   clauses.</p>
<p>In the example, the loop construct has both a <strong>collapse</strong> clause and an <strong>ordered</strong>  clause. The <strong>collapse</strong> clause causes the iterations of the <strong>k</strong> and  <strong>j</strong> loops to be collapsed into one loop with a larger iteration space, and  that loop is divided among the threads in the current team. An <strong>ordered</strong>  clause is added to the loop construct because an ordered region binds to the loop  region arising from the loop construct.</p>
<p>According to Section 2.12.8 of the OpenMP 4.0 specification,  a thread must not execute more than one ordered region that binds  to the same loop region. So the <strong>collapse</strong> clause is required for the example  to be conforming. With the <strong>collapse</strong> clause, the iterations of the <strong>k</strong>  and <strong>j</strong> loops are collapsed into one loop, and therefore only one ordered  region will bind to the collapsed <strong>k</strong> and <strong>j</strong> loop. Without the <strong>collapse</strong>  clause, there would be two ordered regions that bind to each iteration of the <strong>k</strong>  loop (one arising from the first iteration of the <strong>j</strong> loop, and the other  arising from the second iteration of the <strong>j</strong> loop).</p>
<p>The code prints</p>
<p><strong>0 1 1</strong> <br> <strong>0 1 2</strong> <br> <strong>0 2 1</strong> <br> <strong>1 2 2</strong> <br> <strong>1 3 1</strong> <br> <strong>1 3 2</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: collapse.3
* type: C
* version: omp_3.0
*/
#include &lt;omp.h&gt;
#include &lt;stdio.h&gt;
void work(int a, int j, int k);
void sub()
{
   int j, k, a;
   #pragma omp parallel num_threads(2)
   {
      #pragma omp for collapse(2) ordered private(j,k) schedule(static,3)
      for (k=1; k&lt;=3; k++)
         for (j=1; j&lt;=2; j++)
         {
            #pragma omp ordered
            printf(&quot;%d %d %d\n&quot;, omp_get_thread_num(), k, j);
            /* end ordered */
            work(a,j,k);
         }
   }
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: collapse.3
! type: F-fixed
! version: omp_3.0
      program test
      include &#39;omp_lib.h&#39;
!$omp parallel num_threads(2)
!$omp do collapse(2) ordered private(j,k) schedule(static,3)
      do k = 1,3
        do j = 1,2
!$omp ordered
          print *, omp_get_thread_num(), k, j
!$omp end ordered
          call work(a,j,k)
        enddo
      enddo
!$omp end do
!$omp end parallel
      end program test
</pre></div>
</div>
</div>
</div>
<p>The following example illustrates the collapse of a non-rectangular loop nest, a new feature in OpenMP 5.0. In a loop nest, a non-rectangular loop has a loop bound that references the iteration variable of an enclosing loop.</p>
<p>The motivation for this feature is illustrated in the example below that creates a symmetric correlation matrix for a set of variables. Note that the initial value of the second loop depends on the index variable of the first loop for the loops to be collapsed. Here the data are represented by a 2D array, each row corresponds to a variable and each column corresponds to a sample of the variable - the last two columns are the sample mean and standard deviation (for Fortran, rows and columns are swapped).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: collapse.4
* type: C
* version: omp_5.0
*/
#include &lt;stdio.h&gt;
#define N 20
#define M 10

// routine to calculate a
// For variable a[i]:
// a[i][0],...,a[i][n-1]   contains the n samples
// a[i][n]                 contains the sample mean
// a[i][n+1]               contains the standard deviation
extern void calc_a(int n,int m, float a[][N+2]);

int main(){
  float a[M][N+2], b[M][M];

  calc_a(N,M,a);

  #pragma omp parallel for collapse(2)
  for (int i = 0; i &lt; M; i++)
     for (int j = i; j &lt; M; j++)
     {
        float temp = 0.0f;
        for (int k = 0; k &lt; N; k++)
           temp += (a[i][k]-a[i][N])*(a[j][k]-a[j][N]);

        b[i][j] = temp / (a[i][N+1] * a[j][N+1] * (N - 1));
        b[j][i] = b[i][j];
     }

  printf(&quot;b[0][0] = %f, b[M-1][M-1] = %f\n&quot;, b[0][0], b[M-1][M-1]);

  return 0;
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: collapse.4
! type: F-free
! version: omp_5.0
module calc_m
  interface
  subroutine calc_a(n, m, a)
  integer n, m
  real a(n+2,m)
  ! routine to calculate a
  ! For variable a(*,j):
  ! a(1,j),...,a(n,j)  contains the n samples
  ! a(n+1,j)           contains the sample mean
  ! a(n+2,j)           contains the standard deviation
  end subroutine
  end interface
end module

program main
  use calc_m
  integer, parameter :: N=20, M=10
  real a(N+2,M), b(M,M)
  real temp
  integer i, j, k

  call calc_a(N,M,a)

  !$omp parallel do collapse(2) private(k,temp)
  do i = 1, M
     do j = i, M
        temp = 0.0
        do k = 1, N
           temp = temp + (a(k,i)-a(N+1,i))*(a(k,j)-a(N+1,j))
        end do

        b(i,j) = temp / (a(N+2,i) * a(N+2,j) * (N - 1))
        b(j,i) = b(i,j)
     end do
  end do

  print *,&quot;b(1,1) = &quot;,b(1,1),&quot;, b(M,M) = &quot;,b(M,M)

end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="linear-clause-in-loop-constructs">
<h2><strong>linear</strong> Clause in Loop Constructs<a class="headerlink" href="#linear-clause-in-loop-constructs" title="Permalink to this headline">#</a></h2>
<p>The following example shows the use of the <strong>linear</strong> clause in a loop  construct to allow the proper parallelization of a loop that contains  an induction variable ( <em>j</em> ).  At the end of the execution of  the loop construct, the original variable  <em>j</em>  is updated with  the value  <em>N/2</em>  from the last iteration of the loop.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: linear_in_loop.1
* type: C
* version: omp_4.5
*/
#include &lt;stdio.h&gt;

#define N 100
int main(void)
{
   float a[N], b[N/2];
   int i, j;

   for ( i = 0; i &lt; N; i++ )
      a[i] = i + 1;

   j = 0;
   #pragma omp parallel
   #pragma omp for linear(j:1)
   for ( i = 0; i &lt; N; i += 2 ) {
      b[j] = a[i] * 2.0f;
      j++;
   }

   printf( &quot;%d %f %f\n&quot;, j, b[0], b[j-1] );
   /* print out: 50 2.0 198.0 */

   return 0;
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: linear_in_loop.1
! type: F-free
! version:    omp_4.5
program linear_loop
   implicit none
   integer, parameter :: N = 100
   real :: a(N), b(N/2)
   integer :: i, j

   do i = 1, N
      a(i) = i
   end do

   j = 0
   !$omp parallel
   !$omp do linear(j:1)
   do i = 1, N, 2
      j = j + 1
      b(j) = a(i) * 2.0
   end do
   !$omp end parallel

   print *, j, b(1), b(j)
   ! print out: 50 2.0 198.0

end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="parallel-sections-construct">
<h2><strong>parallel</strong> <strong>sections</strong> Construct<a class="headerlink" href="#parallel-sections-construct" title="Permalink to this headline">#</a></h2>
<p>In the following example routines <strong>XAXIS</strong>, <strong>YAXIS</strong>, and <strong>ZAXIS</strong> can  be executed concurrently. The first <strong>section</strong> directive is optional. Note  that all <strong>section</strong> directives need to appear in the  <strong>parallel</strong> <strong>sections</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: psections.1
* type: C
*/
void XAXIS();
void YAXIS();
void ZAXIS();

void sect_example()
{
  #pragma omp parallel sections
  {
    #pragma omp section
      XAXIS();

    #pragma omp section
      YAXIS();

    #pragma omp section
      ZAXIS();
  }
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: psections.1
! type: F-fixed
      SUBROUTINE SECT_EXAMPLE()
!$OMP PARALLEL SECTIONS
!$OMP SECTION
        CALL XAXIS()
!$OMP SECTION
        CALL YAXIS()

!$OMP SECTION
        CALL ZAXIS()

!$OMP END PARALLEL SECTIONS
      END SUBROUTINE SECT_EXAMPLE
</pre></div>
</div>
</div>
</div>
</section>
<section id="firstprivate-clause-and-sections-construct">
<h2><strong>firstprivate</strong> Clause and <strong>sections</strong> Construct<a class="headerlink" href="#firstprivate-clause-and-sections-construct" title="Permalink to this headline">#</a></h2>
<p>In the following example of the <strong>sections</strong> construct  the <strong>firstprivate</strong>  clause is used to initialize the private copy of <strong>section_count</strong> of each  thread. The problem is that the <strong>section</strong> constructs modify <strong>section_count</strong>,  which breaks the independence of the <strong>section</strong> constructs. When different  threads execute each section, both sections will print the value 1. When the same  thread executes the two sections, one section will print the value 1 and the other  will print the value 2. Since the order of execution of the two sections in this  case is unspecified, it is unspecified which section prints which value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: fpriv_sections.1
* type: C
*/
#include &lt;omp.h&gt;
#include &lt;stdio.h&gt;
#define NT 4
int main( ) {
    int section_count = 0;
    omp_set_dynamic(0);
    omp_set_num_threads(NT);
#pragma omp parallel
#pragma omp sections firstprivate( section_count )
{
#pragma omp section
    {
        section_count++;
        /* may print the number one or two */
        printf( &quot;section_count %d\n&quot;, section_count );
    }
#pragma omp section
    {
        section_count++;
        /* may print the number one or two */
        printf( &quot;section_count %d\n&quot;, section_count );
    }
}
    return 0;
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: fpriv_sections.1
! type: F-free
program section
    use omp_lib
    integer :: section_count = 0
    integer, parameter :: NT = 4
    call omp_set_dynamic(.false.)
    call omp_set_num_threads(NT)
!$omp parallel
!$omp sections firstprivate ( section_count )
!$omp section
    section_count = section_count + 1
! may print the number one or two
    print *, &#39;section_count&#39;, section_count
!$omp section
    section_count = section_count + 1
! may print the number one or two
    print *, &#39;section_count&#39;, section_count
!$omp end sections
!$omp end parallel
end program section
</pre></div>
</div>
</div>
</div>
</section>
<section id="single-construct">
<h2><strong>single</strong> Construct<a class="headerlink" href="#single-construct" title="Permalink to this headline">#</a></h2>
<p>The following example demonstrates the <strong>single</strong> construct. In the example,  only one thread prints each of the progress messages. All other threads will skip  the <strong>single</strong> region and stop at the barrier at the end of the <strong>single</strong>  construct until all threads in the team have reached the barrier. If other threads  can proceed without waiting for the thread executing the <strong>single</strong> region,  a <strong>nowait</strong> clause can be specified, as is done in the third <strong>single</strong>  construct in this example. The user must not make any assumptions as to which thread  will execute a <strong>single</strong> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: single.1
* type: C
*/
#include &lt;stdio.h&gt;

void work1() {}
void work2() {}

void single_example()
{
  #pragma omp parallel
  {
    #pragma omp single
      printf(&quot;Beginning work1.\n&quot;);

    work1();

    #pragma omp single
      printf(&quot;Finishing work1.\n&quot;);

    #pragma omp single nowait
      printf(&quot;Finished work1 and beginning work2.\n&quot;);

    work2();
  }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: single.1
! type: F-fixed
      SUBROUTINE WORK1()
      END SUBROUTINE WORK1

      SUBROUTINE WORK2()
      END SUBROUTINE WORK2

      PROGRAM SINGLE_EXAMPLE
!$OMP PARALLEL

!$OMP SINGLE
        print *, &quot;Beginning work1.&quot;
!$OMP END SINGLE

        CALL WORK1()

!$OMP SINGLE
        print *, &quot;Finishing work1.&quot;
!$OMP END SINGLE

!$OMP SINGLE
        print *, &quot;Finished work1 and beginning work2.&quot;
!$OMP END SINGLE NOWAIT

        CALL WORK2()

!$OMP END PARALLEL

      END PROGRAM SINGLE_EXAMPLE
</pre></div>
</div>
</div>
</div>
</section>
<section id="workshare-construct">
<h2><strong>workshare</strong> Construct<a class="headerlink" href="#workshare-construct" title="Permalink to this headline">#</a></h2>
<p>The following are examples of the <strong>workshare</strong> construct.</p>
<p>In the following example, <strong>workshare</strong> spreads work across the threads executing  the <strong>parallel</strong> region, and there is a barrier after the last statement.  Implementations must enforce Fortran execution rules inside of the <strong>workshare</strong>  block.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: workshare.1
! type: F-fixed
      SUBROUTINE WSHARE1(AA, BB, CC, DD, EE, FF, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N), EE(N,N), FF(N,N)

!$OMP    PARALLEL
!$OMP     WORKSHARE
            AA = BB
            CC = DD
            EE = FF
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE1
</pre></div>
</div>
</div>
</div>
<p>In the following example, the barrier at the end of the first <strong>workshare</strong>  region is eliminated with a <strong>nowait</strong> clause. Threads doing <strong>CC =  DD</strong> immediately begin work on <strong>EE = FF</strong> when they are done with <strong>CC  = DD</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: workshare.2
! type: F-fixed
      SUBROUTINE WSHARE2(AA, BB, CC, DD, EE, FF, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N)
      REAL DD(N,N), EE(N,N), FF(N,N)

!$OMP   PARALLEL
!$OMP     WORKSHARE
            AA = BB
            CC = DD
!$OMP     END WORKSHARE NOWAIT
!$OMP     WORKSHARE
            EE = FF
!$OMP     END WORKSHARE
!$OMP   END PARALLEL
       END SUBROUTINE WSHARE2
</pre></div>
</div>
</div>
</div>
<p>The following example shows the use of an <strong>atomic</strong> directive inside a <strong>workshare</strong>  construct. The computation of <strong>SUM(AA)</strong> is workshared, but the update to  <strong>R</strong> is atomic.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: workshare.3
! type: F-fixed
      SUBROUTINE WSHARE3(AA, BB, CC, DD, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)
      REAL R
        R=0
!$OMP   PARALLEL
!$OMP     WORKSHARE
            AA = BB
!$OMP       ATOMIC UPDATE
              R = R + SUM(AA)
            CC = DD
!$OMP     END WORKSHARE
!$OMP   END PARALLEL
      END SUBROUTINE WSHARE3
</pre></div>
</div>
</div>
</div>
<p>Fortran <strong>WHERE</strong> and <strong>FORALL</strong> statements are <strong>compound statements</strong>,  made up of a <strong>control</strong> part and a <strong>statement</strong> part. When <strong>workshare</strong>  is applied to one of these compound statements, both the control and the statement  parts are workshared. The following example shows the use of a <strong>WHERE</strong> statement  in a <strong>workshare</strong> construct.</p>
<p>Each task gets worked on in order by the threads:</p>
<p><strong>AA = BB</strong> then <br> <strong>CC = DD</strong> then <br> <strong>EE .ne. 0</strong> then <br> <strong>FF = 1 / EE</strong> then <br> <strong>GG = HH</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: workshare.4
! type: F-fixed
      SUBROUTINE WSHARE4(AA, BB, CC, DD, EE, FF, GG, HH, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N)
      REAL DD(N,N), EE(N,N), FF(N,N)
      REAL GG(N,N), HH(N,N)

!$OMP   PARALLEL
!$OMP     WORKSHARE
            AA = BB
            CC = DD
            WHERE (EE .ne. 0) FF = 1 / EE
            GG = HH
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE4
</pre></div>
</div>
</div>
</div>
<p>In the following example, an assignment to a shared scalar variable is performed  by one thread in a <strong>workshare</strong> while all other threads in the team wait.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: workshare.5
! type: F-fixed
      SUBROUTINE WSHARE5(AA, BB, CC, DD, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)

        INTEGER SHR

!$OMP   PARALLEL SHARED(SHR)
!$OMP     WORKSHARE
            AA = BB
            SHR = 1
            CC = DD * SHR
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE5
</pre></div>
</div>
</div>
</div>
<p>The following example contains an assignment to a private scalar variable, which  is performed by one thread in a <strong>workshare</strong> while all other threads wait.  It is non-conforming because the private scalar variable is undefined after the  assignment statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: workshare.6
! type: F-fixed
      SUBROUTINE WSHARE6_WRONG(AA, BB, CC, DD, N)
      INTEGER N
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)

        INTEGER PRI

!$OMP   PARALLEL PRIVATE(PRI)
!$OMP     WORKSHARE
            AA = BB
            PRI = 1
            CC = DD * PRI
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE6_WRONG
</pre></div>
</div>
</div>
</div>
<p>Fortran execution rules must be enforced inside a <strong>workshare</strong> construct.  In the following example, the same result is produced in the following program  fragment regardless of whether the code is executed sequentially or inside an OpenMP  program with multiple threads:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: workshare.7
! type: F-fixed
      SUBROUTINE WSHARE7(AA, BB, CC, N)
      INTEGER N
      REAL AA(N), BB(N), CC(N)

!$OMP   PARALLEL
!$OMP     WORKSHARE
            AA(1:50)  = BB(11:60)
            CC(11:20) = AA(1:10)
!$OMP     END WORKSHARE
!$OMP   END PARALLEL

      END SUBROUTINE WSHARE7
</pre></div>
</div>
</div>
</div>
</section>
<section id="masked-construct">
<h2><strong>masked</strong> Construct<a class="headerlink" href="#masked-construct" title="Permalink to this headline">#</a></h2>
<p>The following example demonstrates the <strong>masked</strong> construct.  In the example, the primary thread (thread number 0)  keeps track of how many iterations have been executed and prints out  a progress report in the iteration loop. The other threads skip the <strong>masked</strong> region without waiting.  The <strong>filter</strong> clause can be used to specify a thread number other  than the primary thread to execute a structured block, as illustrated by the second <strong>masked</strong> construct after the iteration loop. If the thread specified in a <strong>filter</strong> clause does not exist  in the team then the structured block is not executed by any thread.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: masked.1
* type: C
* version:    omp_5.1
*/
#include &lt;stdio.h&gt;

extern float average(float,float,float);

void masked_example( float* x, float* xold, int n, float tol )
{
  int c, i, toobig;
  float error, y;
  c = 0;
  #pragma omp parallel
  {
    do {
      #pragma omp for private(i)
      for( i = 1; i &lt; n-1; ++i ){
        xold[i] = x[i];
      }
      #pragma omp single
      {
        toobig = 0;
      }
      #pragma omp for private(i,y,error) reduction(+:toobig)
      for( i = 1; i &lt; n-1; ++i ){
        y = x[i];
        x[i] = average( xold[i-1], x[i], xold[i+1] );
        error = y - x[i];
        if( error &gt; tol || error &lt; -tol ) ++toobig;
      }
      #pragma omp masked          // primary thread (thread 0)
      {
        ++c;
        printf( &quot;iteration %d, toobig=%d\n&quot;, c, toobig );
      }
    } while( toobig &gt; 0 );
    #pragma omp barrier
    #pragma omp masked filter(1)  // thread 1
    {
      // The printf statement will not be executed
      // if the number of threads is less than 2.
      printf( &quot;total number of iterations = %d\n&quot;, c );
    }
  }
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: masked.1
! type: F-fixed
! version:    omp_5.1
      SUBROUTINE MASKED_EXAMPLE( X, XOLD, N, TOL )
      REAL X(*), XOLD(*), TOL
      INTEGER N
      INTEGER C, I, TOOBIG
      REAL ERROR, Y, AVERAGE
      EXTERNAL AVERAGE
      C = 0
      TOOBIG = 1
!$OMP PARALLEL
        DO WHILE( TOOBIG &gt; 0 )
!$OMP     DO PRIVATE(I)
            DO I = 2, N-1
              XOLD(I) = X(I)
            ENDDO
!$OMP     SINGLE
            TOOBIG = 0
!$OMP     END SINGLE
!$OMP     DO PRIVATE(I,Y,ERROR), REDUCTION(+:TOOBIG)
            DO I = 2, N-1
              Y = X(I)
              X(I) = AVERAGE( XOLD(I-1), X(I), XOLD(I+1) )
              ERROR = Y-X(I)
              IF( ERROR &gt; TOL .OR. ERROR &lt; -TOL ) TOOBIG = TOOBIG+1
            ENDDO
!$OMP     MASKED            ! primary thread (thread 0)
            C = C + 1
            PRINT *, &#39;Iteration &#39;, C, &#39;TOOBIG=&#39;, TOOBIG
!$OMP     END MASKED
        ENDDO
!$OMP   BARRIER
!$OMP   MASKED FILTER(1)    ! thread 1
          ! The print statement will not be executed
          ! if the number of threads is less than 2.
          PRINT *, &#39;Total number of iterations =&#39;, C
!$OMP   END MASKED
!$OMP END PARALLEL
      END SUBROUTINE MASKED_EXAMPLE
</pre></div>
</div>
</div>
</div>
</section>
<section id="loop-construct">
<h2><strong>loop</strong> Construct<a class="headerlink" href="#loop-construct" title="Permalink to this headline">#</a></h2>
<p>The following example illustrates the use of the OpenMP 5.0 <strong>loop</strong> construct for the execution of a loop. The <strong>loop</strong> construct asserts to the compiler that the iterations  of the loop are free of data dependencies and may be executed concurrently. It allows the compiler to use heuristics to select the parallelization scheme and compiler-level optimizations for the concurrency.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: loop.1
* type: C
* version: omp_5.0
*/
#include  &lt;stdio.h&gt;
#define N 100
int main()
{
  float x[N], y[N];
  float a = 2.0;
  for(int i=0;i&lt;N;i++){ x[i]=i; y[i]=0;}   // initialize

  #pragma omp parallel
  {
    #pragma omp loop
    for(int i = 0; i &lt; N; ++i) y[i] = a*x[i] + y[i];
  }
  if(y[N-1] != (N-1)*2.0) printf(&quot;Error: 2*(N-1) != y[N-1]=%f&quot;,y[N-1]);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       loop.1
! type:       F-free
! version:    omp_5.0

program main
  integer, parameter :: N=100
  real :: x(N), y(N)
  real :: a = 2.0e0

  x=(/ (i,i=1,N) /); y=1.0e0                    !! initialize

  !$omp parallel
    !$omp loop
       do i=1,N; y(i) = a*x(i) + y(i); enddo
  !$omp end parallel

  if(y(N) /= N*2.0e0) print*,&quot;Error: 2*N /= y(N); y(N)=&quot;,y(N)
end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="parallel-random-access-iterator-loop">
<h2>Parallel Random Access Iterator Loop<a class="headerlink" href="#parallel-random-access-iterator-loop" title="Permalink to this headline">#</a></h2>
<p>The following example shows a parallel random access iterator loop.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: pra_iterator.1
* type: C++
* version: omp_3.0
*/
#include &lt;vector&gt;
void iterator_example()
{
  std::vector&lt;int&gt; vec(23);
  std::vector&lt;int&gt;::iterator it;
#pragma omp parallel for default(none) shared(vec)
  for (it = vec.begin(); it &lt; vec.end(); it++)
  {
    // do work with *it //
  }
}
</pre></div>
</div>
</div>
</div>
</section>
<section id="omp-set-dynamic-and-omp-set-num-threads-routines">
<h2><strong>omp_set_dynamic</strong> and  <strong>omp_set_num_threads</strong> Routines<a class="headerlink" href="#omp-set-dynamic-and-omp-set-num-threads-routines" title="Permalink to this headline">#</a></h2>
<p>Some programs rely on a fixed, prespecified number of threads to execute correctly.  Because the default setting for the dynamic adjustment of the number of threads  is implementation defined, such programs can choose to turn off the dynamic threads  capability and set the number of threads explicitly to ensure portability. The  following example shows how to do this using <strong>omp_set_dynamic</strong>, and <strong>omp_set_num_threads</strong>.</p>
<p>In this example, the program executes correctly only if it is executed by 16 threads.  If the implementation is not capable of supporting 16 threads, the behavior of  this example is implementation defined. Note that the number of threads executing  a <strong>parallel</strong> region remains constant during the region, regardless of the  dynamic threads setting. The dynamic threads mechanism determines the number of  threads to use at the start of the <strong>parallel</strong> region and keeps it constant  for the duration of the region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: set_dynamic_nthrs.1
* type: C
*/
#include &lt;omp.h&gt;
#include &lt;stdlib.h&gt;

void do_by_16(float *x, int iam, int ipoints) {}

void dynthreads(float *x, int npoints)
{
  int iam, ipoints;

  omp_set_dynamic(0);
  omp_set_num_threads(16);

  #pragma omp parallel shared(x, npoints) private(iam, ipoints)
  {
    if (omp_get_num_threads() != 16)
      abort();

    iam = omp_get_thread_num();
    ipoints = npoints/16;
    do_by_16(x, iam, ipoints);
  }
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: set_dynamic_nthrs.1
! type: F-fixed
      SUBROUTINE DO_BY_16(X, IAM, IPOINTS)
        REAL X(*)
        INTEGER IAM, IPOINTS
      END SUBROUTINE DO_BY_16

      SUBROUTINE DYNTHREADS(X, NPOINTS)

        INCLUDE &quot;omp_lib.h&quot;      ! or USE OMP_LIB

        INTEGER NPOINTS
        REAL X(NPOINTS)

        INTEGER IAM, IPOINTS

        CALL OMP_SET_DYNAMIC(.FALSE.)
        CALL OMP_SET_NUM_THREADS(16)

!$OMP   PARALLEL SHARED(X,NPOINTS) PRIVATE(IAM, IPOINTS)

          IF (OMP_GET_NUM_THREADS() .NE. 16) THEN
            STOP
          ENDIF

          IAM = OMP_GET_THREAD_NUM()
          IPOINTS = NPOINTS/16
          CALL DO_BY_16(X,IAM,IPOINTS)

!$OMP   END PARALLEL

      END SUBROUTINE DYNTHREADS
</pre></div>
</div>
</div>
</div>
</section>
<section id="omp-get-num-threads-routine">
<h2><strong>omp_get_num_threads</strong> Routine<a class="headerlink" href="#omp-get-num-threads-routine" title="Permalink to this headline">#</a></h2>
<p>In the following example, the <strong>omp_get_num_threads</strong> call returns 1 in  the sequential part of the code, so <strong>np</strong> will always be equal to 1. To determine  the number of threads that will be deployed for the <strong>parallel</strong> region, the  call should be inside the <strong>parallel</strong> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: get_nthrs.1
* type: C
*/
#include &lt;omp.h&gt;
void work(int i);

void incorrect() {
  int np, i;

  np = omp_get_num_threads();  /* misplaced */

  #pragma omp parallel for schedule(static)
  for (i=0; i &lt; np; i++)
    work(i);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: get_nthrs.1
! type: F-fixed
      SUBROUTINE WORK(I)
      INTEGER I
        I = I + 1
      END SUBROUTINE WORK

      SUBROUTINE INCORRECT()
        INCLUDE &quot;omp_lib.h&quot;      ! or USE OMP_LIB
        INTEGER I, NP

        NP = OMP_GET_NUM_THREADS()   !misplaced: will return 1
!$OMP   PARALLEL DO SCHEDULE(STATIC)
          DO I = 0, NP-1
            CALL WORK(I)
          ENDDO
!$OMP   END PARALLEL DO
      END SUBROUTINE INCORRECT
</pre></div>
</div>
</div>
</div>
<p>The following example shows how to rewrite this program without including a query  for the number of threads:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: get_nthrs.2
* type: C
*/
#include &lt;omp.h&gt;
void work(int i);

void correct()
{
  int i;

  #pragma omp parallel private(i)
  {
    i = omp_get_thread_num();
    work(i);
  }
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: get_nthrs.2
! type: F-fixed
      SUBROUTINE WORK(I)
        INTEGER I

        I = I + 1

      END SUBROUTINE WORK

      SUBROUTINE CORRECT()
        INCLUDE &quot;omp_lib.h&quot;     ! or USE OMP_LIB
        INTEGER I

!$OMP    PARALLEL PRIVATE(I)
          I = OMP_GET_THREAD_NUM()
          CALL WORK(I)
!$OMP   END PARALLEL

      END SUBROUTINE CORRECT
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="Chap_directives.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">OpenMP Directive Syntax</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Chap_affinity.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">OpenMP Affinity</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The OpenMP Community<br/>
  
      &copy; <a href="../copyright.html">Copyright</a> 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>