
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Pointer Mapping &#8212; OpenMP Application Programming Interface Examples</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to OMP Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Title_Page.html">
   Cover
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Foreword_Chapt.html">
   Foreword
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_introduction/0_Chap_introduction.html">
   1. Introduction
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_introduction/1_Examples_Organization.html">
     1.1. Examples Organization
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_directives/0_Chap_directives.html">
   2. OpenMP Directive Syntax
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_directives/1_C_C%2B%2B_Pragmas.html">
     2.1. C/C++ Pragmas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_directives/2_C%2B%2B_Attributes.html">
     2.2. C++ Attributes
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_directives/3_Fortran_Comments_Fixed_Source_Form.html">
     2.3. Fortran Comments (Fixed Source Form)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_directives/4_Fortran_Comments_Free_Source_Form.html">
     2.4. Fortran Comments (Free Source Form)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_parallel_execution/0_Chap_parallel_execution.html">
   3. Parallel Execution
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/1_A_Simple_Parallel_Loop.html">
     3.1. A Simple Parallel Loop
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/2_parallel_Construct.html">
     3.2.
     <strong>
      parallel
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/3_teams_Construct_on_Host.html">
     3.3.
     <strong>
      teams
     </strong>
     Construct on Host
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/4_Controlling_the_Number_of_Threads_on_Multiple_Nesting_Levels.html">
     3.4. Controlling the Number of Threads on Multiple Nesting Levels
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/5_Interaction_Between_the_num_threads_Clause_and_omp_set_dynamic.html">
     3.5. Interaction Between the
     <strong>
      num_threads
     </strong>
     Clause and
     <strong>
      omp_set_dynamic
     </strong>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/6_Fortran_Restrictions_on_the_do_Construct.html">
     3.6. Fortran Restrictions on the
     <strong>
      do
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/7_nowait_Clause.html">
     3.7.
     <strong>
      nowait
     </strong>
     Clause
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/8_collapse_Clause.html">
     3.8.
     <strong>
      collapse
     </strong>
     Clause
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/9_linear_Clause_in_Loop_Constructs.html">
     3.9.
     <strong>
      linear
     </strong>
     Clause in Loop Constructs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/10_parallel_sections_Construct.html">
     3.10.
     <strong>
      parallel
     </strong>
     <strong>
      sections
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/11_firstprivate_Clause_and_sections_Construct.html">
     3.11.
     <strong>
      firstprivate
     </strong>
     Clause and
     <strong>
      sections
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/12_single_Construct.html">
     3.12.
     <strong>
      single
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/13_workshare_Construct.html">
     3.13.
     <strong>
      workshare
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/14_masked_Construct.html">
     3.14.
     <strong>
      masked
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/15_loop_Construct.html">
     3.15.
     <strong>
      loop
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/16_Parallel_Random_Access_Iterator_Loop.html">
     3.16. Parallel Random Access Iterator Loop
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/17_omp_set_dynamic_and_omp_set_num_threads_Routines.html">
     3.17.
     <strong>
      omp_set_dynamic
     </strong>
     and
     <strong>
      omp_set_num_threads
     </strong>
     Routines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/18_omp_get_num_threads_Routine.html">
     3.18.
     <strong>
      omp_get_num_threads
     </strong>
     Routine
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_affinity/0_Chap_affinity.html">
   4. OpenMP Affinity
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_affinity/1_proc_bind_Clause.html">
     4.1.
     <strong>
      proc_bind
     </strong>
     Clause
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_affinity/2_Task_Affinity.html">
     4.2. Task Affinity
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_affinity/3_Affinity_Display.html">
     4.3. Affinity Display
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_affinity/4_Affinity_Query_Func.html">
     4.4. Affinity Query Functions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_tasking/0_Chap_tasking.html">
   5. Tasking
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/1_task_and_taskwait_Constructs.html">
     5.1.
     <strong>
      task
     </strong>
     and
     <strong>
      taskwait
     </strong>
     Constructs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/2_Task_Priority.html">
     5.2. Task Priority
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/3_Task_Dependences.html">
     5.3. Task Dependences
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/4_Task_Detachment.html">
     5.4. Task Detachment
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/5_taskgroup_Construct.html">
     5.5.
     <strong>
      taskgroup
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/6_taskyield_Construct.html">
     5.6.
     <strong>
      taskyield
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/7_taskloop_Construct.html">
     5.7.
     <strong>
      taskloop
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/8_Combined_parallel_masked_and_taskloop_Constructs.html">
     5.8. Combined
     <strong>
      parallel
     </strong>
     <strong>
      masked
     </strong>
     and
     <strong>
      taskloop
     </strong>
     Constructs
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="0_Chap_devices.html">
   6. Devices
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="simple">
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_SIMD/0_Chap_SIMD.html">
   7. SIMD
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_SIMD/1_simd_and_declare_simd_Directives.html">
     7.1.
     <strong>
      simd
     </strong>
     and
     <strong>
      declare
     </strong>
     <strong>
      simd
     </strong>
     Directives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_SIMD/2_inbranch_and_notinbranch_Clauses.html">
     7.2.
     <strong>
      inbranch
     </strong>
     and
     <strong>
      notinbranch
     </strong>
     Clauses
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_SIMD/3_Loop-Carried_Lexical_Forward_Dependence.html">
     7.3. Loop-Carried Lexical Forward Dependence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_SIMD/4_ref_val_uvalModifiers_for_linear_Clause.html">
     7.4.
     <strong>
      ref
     </strong>
     ,
     <strong>
      val
     </strong>
     ,
     <strong>
      uval
     </strong>
     Modifiers for
     <strong>
      linear
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_loop_transformations/Chap_loop_transformations.html">
   8. Loop Transformations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_synchronization/Chap_synchronization.html">
   9. Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_data_environment/Chap_data_environment.html">
   10. Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_memory_model/Chap_memory_model.html">
   11. Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_program_control/Chap_program_control.html">
   12. Program Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_ompt_interface/Chap_ompt_interface.html">
   13. OMPT Interface
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_devices/3_Pointer_Mapping.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/passlab/Examples"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_devices/3_Pointer_Mapping.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../_sources/contents/Chap_devices/3_Pointer_Mapping.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Pointer Mapping</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="pointer-mapping">
<h1>Pointer Mapping<a class="headerlink" href="#pointer-mapping" title="Permalink to this headline">#</a></h1>
<p>Pointers that contain host addresses require that those addresses are translated to device addresses for them to be useful in the context of a device data environment. Broadly speaking, there are two scenarios where this is important.</p>
<p>The first scenario is where the pointer is mapped to the device data environment, such that references to the pointer inside a <strong>target</strong> region are to the corresponding pointer. Pointer attachment ensures that the corresponding pointer will contain a device address when all of the following conditions are true:</p>
<ul class="simple">
<li><p>the pointer is mapped by directive  A  to a device;</p></li>
<li><p>a list item that uses the pointer as its base pointer (call it the <em>pointee</em>) is mapped, to the same device, by directive  B , which may be the same as  A ;</p></li>
<li><p>the effect of directive  B  is to create either the corresponding pointer or pointee in the device data environment of the device.</p></li>
</ul>
<p>Given the above conditions, pointer attachment is initiated as a result of directive  B  and subsequent references to the pointee list item in a target region that use the pointer will access the corresponding pointee. The corresponding pointer remains in this <em>attached</em> state until it is removed from the device data environment.</p>
<p>The second scenario, which is only applicable for C/C++, is where the pointer is implicitly privatized inside a <strong>target</strong> construct when it appears as the base pointer to a list item on the construct and does not appear explicitly as a list item in a <strong>map</strong> clause, <strong>is_device_ptr</strong> clause, or data-sharing attribute clause. This scenario can be further split into two cases: the list item is a zero-length array section (e.g.,  <em>p[:0]</em> ) or it is not.</p>
<p>If it is a zero-length array section, this will trigger a runtime check on entry to the <strong>target</strong> region for a previously mapped list item where the value of the pointer falls within the range of its base address and ending address. If such a match is found the private pointer is initialized to the device address corresponding to the value of the original pointer, and otherwise it is initialized to NULL (or retains its original value if the <strong>unified_address</strong> requirement is specified for that compilation unit).</p>
<p>If the list item (again, call it the <em>pointee</em>) is not a zero-length array section, the private pointer will be initialized such that references in the <strong>target</strong> region to the pointee list item that use the pointer will access the corresponding pointee.</p>
<p>The following example shows the basics of mapping pointers with and without associated storage on the host.</p>
<p>Storage for pointers  <em>ptr1</em>  and  <em>ptr2</em>  is created on the host.  To map storage that is associated with a pointer on the host, the data can be explicitly mapped as an array section so that the compiler knows  the amount of data to be assigned in the device (to the “corresponding” data storage area). On the <strong>target</strong> construct array sections are mapped; however, the pointer  <em>ptr1</em>  is mapped, while  <em>ptr2</em>  is not. Since  <em>ptr2</em>  is not explicitly mapped, it is firstprivate.  This creates a subtle difference in the way these pointers can be used.</p>
<p>As a firstprivate pointer,  <em>ptr2</em>  can be manipulated on the device; however, as an explicitly mapped pointer,   <em>ptr1</em>  becomes an <em>attached</em> pointer and cannot be manipulated. In both cases the host pointer is not updated with the device pointer  address—as one would expect for distributed memory.  The storage data on the host is updated from the corresponding device data at the end of the <strong>target</strong> region.</p>
<p>As a comparison, note that the  <em>aray</em>  array is automatically mapped,  since the compiler knows the extent of the array.</p>
<p>The pointer  <em>ptr3</em>  is used inside the <strong>target</strong> construct, but it does not appear in a data-mapping or data-sharing clause. Nor is there a <strong>defaultmap</strong> clause on the construct to indicate what its implicit data-mapping or data-sharing attribute should be. For such a case,  <em>ptr3</em>  will be implicitly privatized within the construct and there will be a runtime check to see if the host memory to which it is pointing has corresponding memory in the device data environment. If this runtime check passes, the private  <em>ptr3</em>  would be initialized to point to the corresponding memory. But in this case the check does not pass and so it is initialized to null. Since  <em>ptr3</em>  is private, the value to which it is assigned in the <strong>target</strong> region is not returned into the original  <em>ptr3</em>  on the host.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.1</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">aray</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target map(ptr1, ptr1[:N]) map(ptr2[:N] )</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">ptr1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">ptr2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">aray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">//*(++ptr1) = 9;  //NOT ALLOWED since ptr1 is an attached pointer</span>
<span class="w">     </span><span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">ptr2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w">  </span><span class="c1">//    allowed since ptr2 is firstprivate</span>

<span class="w">     </span><span class="n">ptr3</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"> </span><span class="c1">// ptr3 is firstprivate</span>
<span class="w">                                        </span><span class="c1">// ptr3 value not returned</span>
<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">ptr3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">ptr1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ptr3</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">     </span><span class="n">free</span><span class="p">(</span><span class="n">ptr3</span><span class="p">);</span><span class="w">     </span><span class="c1">// explicitly free allocated storage on device</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ptr1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ptr2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="c1">//        6  9</span>

<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">ptr2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the following example the global pointer  <em>p</em>  appears in a declare target directive.  Hence, the pointer  <em>p</em>  will  persist on the device throughout executions in all <strong>target</strong> regions.</p>
<p>The pointer is also used in an array section of a <strong>map</strong> clause on  a <strong>target</strong> construct.  When the pointer of storage associated with  a declare target directive is mapped, as for the array section  <em>p[:N]</em>  in the <strong>target</strong> construct, the array section on the device is <em>attached</em> to the device pointer  <em>p</em>  on entry to the construct, and the value of the device pointer  <em>p</em>  becomes undefined on exit.  (Of course, storage allocation for the array section on the device will occur before the  pointer on the device is <em>attached</em>.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.2</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>

<span class="cp">#pragma omp begin declare target</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">use_arg_p</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">use_global_p</span><span class="p">(</span><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target map(p[:N])  </span><span class="c1">// device p attached to array section</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">use_arg_p</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">use_global_p</span><span class="p">(</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w">                              </span><span class="c1">// value of host p is preserved</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %3.3d %3.3d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">         </span><span class="c1">// 003   297   &lt;- output</span>

<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// A #pragma omp begin declare target is optional here</span>
<span class="c1">// because of prototype spec</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">use_arg_p</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">use_global_p</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">   </span><span class="c1">// valid since p is in declare target and called from</span>
<span class="w">                 </span><span class="c1">// inside target region where p was attached to</span>
<span class="w">                 </span><span class="c1">// valid memory</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// A #pragma omp end declare target is optional here</span>
<span class="c1">// because of prototype spec</span>
</pre></div>
</div>
</div>
</div>
<p>The following two examples illustrate subtle differences in pointer attachment to device address because of the order of data mapping.</p>
<p>In example  <em>target_ptr_map.3a</em>   the global pointer  <em>p1</em>  points to array  <em>x</em>  and  <em>p2</em>  points to array  <em>y</em>  on the host. The array section  <em>x[:N]</em>  is mapped by the <strong>target</strong> <strong>enter</strong> <strong>data</strong> directive while array  <em>y</em>  is mapped on the <strong>target</strong> construct.  Since the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> directive is applied to the declaration of  <em>p1</em> ,  <em>p1</em>  is a treated like a mapped variable on the <strong>target</strong> construct and references to  <em>p1</em>  inside the construct will be to the corresponding  <em>p1</em>  that exists on the device.  However, the corresponding  <em>p1</em>  will be undefined since there is no pointer attachment for it. Pointer attachment for  <em>p1</em>  would require that (1)  <em>p1</em>  (or an lvalue expression that refers to the same storage as  <em>p1</em> ) appears as a base pointer to a list item in a <strong>map</strong> clause, and (2) the construct that has the <strong>map</strong> clause causes the list item to transition from <strong>not mapped</strong> to <strong>mapped</strong>. The conditions are clearly not satisfied for this example.</p>
<p>The problem for  <em>p2</em>  in this example is also subtle. It will be privatized inside the <strong>target</strong> construct, with a runtime check for whether the memory to which it is pointing has corresponding memory that is accessible on the device. If this check is successful, then the  <em>p2</em>  inside the construct would be appropriately initialized to point to that corresponding memory. Unfortunately, despite there being an implicit map of the array  <em>y</em>  (to which  <em>p2</em>  is pointing) on the construct, the order of this map relative to the initialization of  <em>p2</em>  is unspecified. Therefore, the initial value of  <em>p2</em>  will also be undefined.</p>
<p>Thus, referencing values via either  <em>p1</em>  or  <em>p2</em>  inside the <strong>target</strong> region would be invalid.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.3a</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 100</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="cp">#pragma omp begin declare target</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Explicitly map array section x[:N]</span>
<span class="w">  </span><span class="cp">#pragma omp target enter data map(x[:N])</span>

<span class="w">  </span><span class="cp">#pragma omp target  </span><span class="c1">// as if .. map(p1) map(p1[:0]) map(p2[:0]) map(y)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Accessing the mapped arrays x,y is OK here.</span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Pointer attachment for p1 does not occur here</span>
<span class="w">    </span><span class="c1">//   because p1[:0] does not allocate a new array section and</span>
<span class="w">    </span><span class="c1">//   array x is present on the target construct as it was mapped</span>
<span class="w">    </span><span class="c1">//   before by the target enter data directive.</span>
<span class="w">    </span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">      </span><span class="c1">// accessing p1 is undefined</span>

<span class="w">    </span><span class="c1">// The initial value of p2 in the target region is undefined</span>
<span class="w">    </span><span class="c1">//   because map(y) may occur after map(p2[:0]).</span>
<span class="w">    </span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">      </span><span class="c1">// accessing p2 is undefined</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In example  <em>target_ptr_map.3b</em>  the mapping orders for arrays  <em>x</em>  and  <em>y</em>  were rearranged to allow proper pointer attachments. On the <strong>target</strong> construct, the <strong>map(x)</strong> clause triggers pointer attachment for  <em>p1</em>  to the device address of  <em>x</em> .  Pointer  <em>p2</em>  is assigned the device address of the previously mapped  array  <em>y</em> . Referencing values via either  <em>p1</em>  or  <em>p2</em>  inside the <strong>target</strong> region is now valid.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.3b</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 100</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="cp">#pragma omp begin declare target</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Explicitly map array section y[:N]</span>
<span class="w">  </span><span class="cp">#pragma omp target enter data map(y[:N])</span>

<span class="w">  </span><span class="cp">#pragma omp target map(x[:N]) map(p1[:N]) map(p2[:0])</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Accessing the mapped arrays x,y is OK here.</span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Pointer attachment for p1 occurs here when array x is mapped</span>
<span class="w">    </span><span class="c1">//   on the target construct (as p1 = &amp;x[0] on the device)</span>
<span class="w">    </span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">      </span><span class="c1">// accessing p1 is OK</span>

<span class="w">    </span><span class="c1">// p2 in the target region is initialized to &amp;y[0]</span>
<span class="w">    </span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">      </span><span class="c1">// accessing p2 is OK</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the following example, storage allocated on the host is not mapped in a <strong>target</strong> region if it is determined that the host memory is accessible from the device. On platforms that support host memory access from a target device,  it may be more efficient to omit map clauses and avoid the potential memory allocation  and data transfers that may result from the map. The <strong>omp_target_is_accessible</strong> API routine is used to determine if the  host storage of size  <em>buf_size</em>  is accessible on the device, and a metadirective is used to select the directive variant (a <strong>target</strong> with/without a <strong>map</strong> clause).</p>
<p>The <strong>omp_target_is_accessible</strong> routine will return true if the storage indicated  by the first and second arguments is accessible on the target device. In this case,  the host pointer  <em>ptr</em>  may be directly dereferenced in the subsequent  <strong>target</strong> region to access this storage, rather than mapping an array section based  off the pointer. By explicitly specifying the host pointer in a <strong>firstprivate</strong>  clause on the construct, its original value will be used directly in the <strong>target</strong> region.  In OpenMP 5.1, removing the <strong>firstprivate</strong> clause will result in an implicit presence  check of the storage to which  <em>ptr</em>  points, and since this storage is not mapped by the  program,  <em>ptr</em>  will be NULL-initialized in the <strong>target</strong> region.  In the next version of the OpenMP Specification, a false presence check without  the <strong>firstprivate</strong> clause will cause the pointer to retain its original value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.4</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">do_work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buf_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">buf_size</span><span class="p">);</span><span class="w"> </span><span class="c1">// possibly compiled on</span>
<span class="w">                                        </span><span class="c1">// Unified Shared Memory system</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">accessible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_is_accessible</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">buf_size</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">      when(user={condition(accessible)}: target firstprivate(ptr) ) \</span>
<span class="cp">      otherwise(                         target map(ptr[:n])      )</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">do_work</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

</pre></div>
</div>
</div>
</div>
<p>Similar to the previous example, the <strong>omp_target_is_accessible</strong> routine is used to discover if a deep copy is required for the platform.  Here, the  <em>deep_copy</em>  map, defined in the <strong>declare</strong> <strong>mapper</strong> directive, is used if the host storage referenced by   <em>s.ptr</em>  (or  <em>sptr</em>  in Fortran) is not accessible from the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.5</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">buf_size</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp declare mapper(deep_copy: T s) map(s, s.ptr[:s.buf_size])</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">do_work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buf_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">T</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">buf_size</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">s</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">buf_size</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">accessible</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">omp_target_is_accessible</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">buf_size</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">      when(user={condition(accessible)}: target) \</span>
<span class="cp">      otherwise(target map(mapper(deep_copy),tofrom:s) )</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">do_work</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w">       </span><span class="n">target_ptr_map</span><span class="mf">.5</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w">       </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>

<span class="w">   </span><span class="n">use</span><span class="p">,</span><span class="w"> </span><span class="n">intrinsic</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">iso_c_binding</span><span class="p">,</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c_loc</span><span class="p">,</span><span class="w"> </span><span class="n">c_size_t</span><span class="p">,</span><span class="w"> </span><span class="n">c_sizeof</span><span class="p">,</span><span class="w"> </span><span class="n">c_int</span><span class="w"></span>
<span class="w">   </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">   </span><span class="n">external</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">do_work</span><span class="w"></span>

<span class="w">   </span><span class="n">type</span><span class="w"> </span><span class="n">T</span><span class="w"></span>
<span class="w">     </span><span class="n">integer</span><span class="p">,</span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">ptr</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">integer</span><span class="w">         </span><span class="o">::</span><span class="w"> </span><span class="n">buf_size</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">type</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">mapper</span><span class="p">(</span><span class="n">deep_copy</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">(</span><span class="o">:</span><span class="n">s</span><span class="o">%</span><span class="n">buf_size</span><span class="p">))</span><span class="w"></span>

<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">accessible</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">(</span><span class="n">c_size_t</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">buf_size</span><span class="w"></span>

<span class="w">   </span><span class="n">type</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="w">   </span><span class="n">allocate</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="w"></span>

<span class="w">   </span><span class="n">buf_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">n</span><span class="w"></span>
<span class="w">   </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">()</span><span class="w"></span>

<span class="w">   </span><span class="n">accessible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_is_accessible</span><span class="p">(</span><span class="n">c_loc</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="w"> </span><span class="n">buf_size</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">begin</span><span class="w"> </span><span class="n">metadirective</span><span class="w">                              </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">when</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="p">{</span><span class="n">condition</span><span class="p">(</span><span class="n">accessible</span><span class="p">)}</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">otherwise</span><span class="p">(</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">(</span><span class="n">deep_copy</span><span class="p">),</span><span class="n">tofrom</span><span class="o">:</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">do_work</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">end</span><span class="w">   </span><span class="n">metadirective</span><span class="w"></span>

<span class="w">   </span><span class="n">deallocate</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents/Chap_devices"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The OpenMP Community<br/>
  
      &copy; <a href="../../copyright.html">Copyright</a> 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>