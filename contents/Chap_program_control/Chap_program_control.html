
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>12. Program Control &#8212; OpenMP Application Programming Interface Examples</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="13. OMPT Interface" href="../Chap_ompt_interface/Chap_ompt_interface.html" />
    <link rel="prev" title="11. Memory Model" href="../Chap_memory_model/Chap_memory_model.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Welcome to OMP Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Title_Page.html">
   Cover
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Foreword_Chapt.html">
   Foreword
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_introduction/0_Chap_introduction.html">
   1. Introduction
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_introduction/1_Section_Examples_Organization.html">
     1.1. Examples Organization
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_directives/0_Chap_directives.html">
   2. OpenMP Directive Syntax
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_directives/1_C_C%2B%2B_Pragmas.html">
     2.1. C/C++ Pragmas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_directives/2_C%2B%2B_Attributes.html">
     2.2. C++ Attributes
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_directives/3_Fortran_Comments_Fixed_Source_Form.html">
     2.3. Fortran Comments (Fixed Source Form)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_directives/4_Fortran_Comments_Free_Source_Form.html">
     2.4. Fortran Comments (Free Source Form)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_parallel_execution/0_Chap_parallel_execution.html">
   3. Parallel Execution
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/1_A_Simple_Parallel_Loop.html">
     3.1. A Simple Parallel Loop
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/2_parallel_Construct.html">
     3.2.
     <strong>
      parallel
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/3_teams_Construct_on_Host.html">
     3.3.
     <strong>
      teams
     </strong>
     Construct on Host
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/4_Controlling_the_Number_of_Threads_on_Multiple_Nesting_Levels.html">
     3.4. Controlling the Number of Threads on Multiple Nesting Levels
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/5_Interaction_Between_the_num_threads_Clause_and_omp_set_dynamic.html">
     3.5. Interaction Between the
     <strong>
      num_threads
     </strong>
     Clause and
     <strong>
      omp_set_dynamic
     </strong>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/6_Fortran_Restrictions_on_the_do_Construct.html">
     3.6. Fortran Restrictions on the
     <strong>
      do
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/7_nowait_Clause.html">
     3.7.
     <strong>
      nowait
     </strong>
     Clause
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/8_collapse_Clause.html">
     3.8.
     <strong>
      collapse
     </strong>
     Clause
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/9_linear_Clause_in_Loop_Constructs.html">
     3.9.
     <strong>
      linear
     </strong>
     Clause in Loop Constructs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/10_parallel_sections_Construct.html">
     3.10.
     <strong>
      parallel
     </strong>
     <strong>
      sections
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/11_firstprivate_Clause_and_sections_Construct.html">
     3.11.
     <strong>
      firstprivate
     </strong>
     Clause and
     <strong>
      sections
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/12_single_Construct.html">
     3.12.
     <strong>
      single
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/13_workshare_Construct.html">
     3.13.
     <strong>
      workshare
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/14_masked_Construct.html">
     3.14.
     <strong>
      masked
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/15_loop_Construct.html">
     3.15.
     <strong>
      loop
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/16_Parallel_Random_Access_Iterator_Loop.html">
     3.16. Parallel Random Access Iterator Loop
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/17_omp_set_dynamic_and_omp_set_num_threads_Routines.html">
     3.17.
     <strong>
      omp_set_dynamic
     </strong>
     and
     <strong>
      omp_set_num_threads
     </strong>
     Routines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_parallel_execution/18_omp_get_num_threads_Routine.html">
     3.18.
     <strong>
      omp_get_num_threads
     </strong>
     Routine
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_affinity/0_Chap_affinity.html">
   4. OpenMP Affinity
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_affinity/1_Section_proc_bind_Clause.html">
     4.1.
     <strong>
      proc_bind
     </strong>
     Clause
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_affinity/2_Section_Task_Affinity.html">
     4.2. Task Affinity
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_affinity/3_Section_Affinity_Display.html">
     4.3. Affinity Display
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_affinity/4_Section_Affinity_Query_Func.html">
     4.4. Affinity Query Functions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Chap_tasking/0_Chap_tasking.html">
   5. Tasking
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/1_task_and_taskwait_Constructs.html">
     5.1.
     <strong>
      task
     </strong>
     and
     <strong>
      taskwait
     </strong>
     Constructs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/2_Task_Priority.html">
     5.2. Task Priority
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/3_Task_Dependences.html">
     5.3. Task Dependences
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/4_Task_Detachment.html">
     5.4. Task Detachment
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/5_taskgroup_Construct.html">
     5.5.
     <strong>
      taskgroup
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/6_taskyield_Construct.html">
     5.6.
     <strong>
      taskyield
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/7_taskloop_Construct.html">
     5.7.
     <strong>
      taskloop
     </strong>
     Construct
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Chap_tasking/8_Combined_parallel_masked_and_taskloop_Constructs.html">
     5.8. Combined
     <strong>
      parallel
     </strong>
     <strong>
      masked
     </strong>
     and
     <strong>
      taskloop
     </strong>
     Constructs
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_devices/Chap_devices.html">
   6. Devices
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_SIMD/Chap_SIMD.html">
   7. SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_loop_transformations/Chap_loop_transformations.html">
   8. Loop Transformations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_synchronization/Chap_synchronization.html">
   9. Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_data_environment/Chap_data_environment.html">
   10. Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_memory_model/Chap_memory_model.html">
   11. Memory Model
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   12. Program Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Chap_ompt_interface/Chap_ompt_interface.html">
   13. OMPT Interface
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_program_control/Chap_program_control.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/passlab/Examples"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_program_control/Chap_program_control.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../_sources/contents/Chap_program_control/Chap_program_control.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conditional-compilation">
   12.1. Conditional Compilation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#internal-control-variables-icvs">
   12.2. Internal Control Variables (ICVs)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#placement-of-flush-barrier-taskwait-and-taskyield-directives">
   12.3. Placement of
   <strong>
    flush
   </strong>
   ,
   <strong>
    barrier
   </strong>
   ,
   <strong>
    taskwait
   </strong>
   and
   <strong>
    taskyield
   </strong>
   Directives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cancellation-constructs">
   12.4. Cancellation Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#requires-directive">
   12.5.
   <strong>
    requires
   </strong>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-variant-directive">
   12.6.
   <strong>
    declare
   </strong>
   <strong>
    variant
   </strong>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metadirectives">
   12.7. Metadirectives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nested-loop-constructs">
   12.8. Nested Loop Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#restrictions-on-nesting-of-regions">
   12.9. Restrictions on Nesting of Regions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-offload">
   12.10. Target Offload
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#controlling-concurrency-and-reproducibility-with-the-order-clause">
   12.11. Controlling Concurrency and Reproducibility with  the
   <strong>
    order
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interop-construct">
   12.12.
   <strong>
    interop
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#utilities">
   12.13. Utilities
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#timing-routines">
     12.13.1. Timing Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#environment-display">
     12.13.2. Environment Display
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#error-directive">
     12.13.3.
     <strong>
      error
     </strong>
     Directive
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Program Control</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conditional-compilation">
   12.1. Conditional Compilation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#internal-control-variables-icvs">
   12.2. Internal Control Variables (ICVs)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#placement-of-flush-barrier-taskwait-and-taskyield-directives">
   12.3. Placement of
   <strong>
    flush
   </strong>
   ,
   <strong>
    barrier
   </strong>
   ,
   <strong>
    taskwait
   </strong>
   and
   <strong>
    taskyield
   </strong>
   Directives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cancellation-constructs">
   12.4. Cancellation Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#requires-directive">
   12.5.
   <strong>
    requires
   </strong>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-variant-directive">
   12.6.
   <strong>
    declare
   </strong>
   <strong>
    variant
   </strong>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metadirectives">
   12.7. Metadirectives
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nested-loop-constructs">
   12.8. Nested Loop Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#restrictions-on-nesting-of-regions">
   12.9. Restrictions on Nesting of Regions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-offload">
   12.10. Target Offload
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#controlling-concurrency-and-reproducibility-with-the-order-clause">
   12.11. Controlling Concurrency and Reproducibility with  the
   <strong>
    order
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interop-construct">
   12.12.
   <strong>
    interop
   </strong>
   Construct
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#utilities">
   12.13. Utilities
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#timing-routines">
     12.13.1. Timing Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#environment-display">
     12.13.2. Environment Display
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#error-directive">
     12.13.3.
     <strong>
      error
     </strong>
     Directive
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="program-control">
<h1><span class="section-number">12. </span>Program Control<a class="headerlink" href="#program-control" title="Permalink to this headline">#</a></h1>
<p>Basic concepts and mechanisms for directing and controlling a program compilation and execution are provided in this introduction and illustrated in subsequent examples.</p>
<p>CONDITIONAL COMPILATION and EXECUTION</p>
<p>Conditional compilation can be performed with conventional #ifdef directives in C, C++, and Fortran, and additionally with OpenMP sentinel (<strong>!$</strong>) in Fortran.  The <strong>if</strong> clause on some directives can direct the runtime to ignore or alter the behavior of the construct. Of course, the base-language <strong>if</strong> statements can be used to control the execution of stand-alone directives (such as <strong>flush</strong>, <strong>barrier</strong>, <strong>taskwait</strong>,  and  <strong>taskyield</strong>). However, the directives must appear in a block structure, and not as a substatement. The <strong>metadirective</strong> and <strong>declare</strong> <strong>variant</strong> directives provide conditional  selection of directives and routines for compilation (and use), respectively. The <strong>assume</strong> and <strong>requires</strong> directives provide invariants for optimizing compilation, and essential features for compilation  and correct execution, respectively.</p>
<p>CANCELLATION</p>
<p>Cancellation (termination) of the normal sequence of execution for the threads in an OpenMP region can be  accomplished with the <strong>cancel</strong> construct.  The construct uses a  <em>construct-type-clause</em>  to set the region-type to activate for the cancellation.  That is, inclusion  of one of the  <em>construct-type-clause</em>  names <strong>parallel</strong>, <strong>for</strong>,  <strong>do</strong>, <strong>sections</strong> or <strong>taskgroup</strong> on the directive line  activates the corresponding region.   The <strong>cancel</strong> construct is activated by the first encountering thread,  and it continues execution at the end of the named region. The <strong>cancel</strong> construct is also a cancellation point for any other thread of the team  to also continue execution at the end of the named region.</p>
<p>Also, once the specified region has been activated for cancellation any thread that encounnters  a <strong>cancellation</strong> <strong>point</strong> construct with the same named region ( <em>construct-type-clause</em> ), continues execution at the end of the region.</p>
<p>For an activated <strong>cancel taskgroup</strong> construct, the tasks that belong to the taskgroup set of the innermost enclosing taskgroup region will be canceled.</p>
<p>A task that encounters a <strong>cancel</strong> <strong>taskgroup</strong> construct continues execution at the end of its task region. Any task of the taskgroup that has already begun execution will run to completion, unless it encounters a <strong>cancellation</strong> <strong>point</strong>; tasks that have not begun execution may be discarded as completed tasks.</p>
<p>CONTROL VARIABLES</p>
<p>Internal control variables (ICV) are used by implementations to hold values which control the execution   of OpenMP regions.  Control (and hence the ICVs) may be set as implementation defaults,    or set and adjusted through environment variables, clauses, and API functions.      Initial ICV values are reported by the runtime   if the <strong>OMP_DISPLAY_ENV</strong> environment variable has been set to <strong>TRUE</strong> or <strong>VERBOSE</strong>.</p>
<p>NESTED CONSTRUCTS</p>
<p>Certain combinations of nested constructs are permitted, giving rise to  <em>combined</em>  constructs consisting of two or more directives.  These can be used when the two (or several) constructs would be used immediately in succession (closely nested). A  <em>combined</em>  construct can use the clauses of the component constructs without restrictions. A  <em>composite</em>  construct is a combined construct which has one or more clauses with (an often obviously) modified or restricted meaning, relative to when the constructs are uncombined.</p>
<p>Certain nestings are forbidden, and often the reasoning is obvious.  For example, worksharing constructs cannot be nested, and the <strong>barrier</strong> construct cannot be nested inside a worksharing construct, or a <strong>critical</strong> construct.  Also, <strong>target</strong> constructs cannot be nested, unless the nested target is a reverse offload.</p>
<p>The <strong>parallel</strong> construct can be nested, as well as the <strong>task</strong> construct.   The parallel execution in the nested parallel construct(s) is controlled by the  <strong>OMP_MAX_ACTIVE_LEVELS</strong> environment variable, and the <strong>omp_set_max_active_levels</strong> routine.  Use the <strong>omp_get_max_active_levels</strong> routine to determine the maximum levels provided by an implementation. As of OpenMP 5.0, use of the <strong>OMP_NESTED</strong> environment variable and the <strong>omp_set_nested</strong> routine  has been deprecated.</p>
<p>More details on nesting can be found in the  <em>Nesting of Regions</em>  of the  <em>Directives</em>   chapter in the OpenMP Specifications document.</p>
<section id="conditional-compilation">
<h2><span class="section-number">12.1. </span>Conditional Compilation<a class="headerlink" href="#conditional-compilation" title="Permalink to this headline">#</a></h2>
<p>The following example illustrates the use of conditional compilation using the  OpenMP macro _<strong>OPENMP</strong>. With OpenMP compilation, the _<strong>OPENMP</strong>  macro becomes defined.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: cond_comp.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="cp"># ifdef _OPENMP</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Compiled by an OpenMP-compliant implementation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="cp"># endif</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example illustrates the use of the conditional compilation sentinel.  With OpenMP compilation, the conditional compilation sentinel <strong>!$</strong> is recognized  and treated as two spaces. In fixed form source, statements guarded by the sentinel  must start after column 6.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">cond_comp</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">EXAMPLE</span><span class="w"></span>

<span class="n">C234567890</span><span class="w"></span>
<span class="o">!</span><span class="n">$</span><span class="w">    </span><span class="n">PRINT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Compiled by an OpenMP-compliant implementation.&quot;</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">PROGRAM</span><span class="w"> </span><span class="n">EXAMPLE</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="internal-control-variables-icvs">
<h2><span class="section-number">12.2. </span>Internal Control Variables (ICVs)<a class="headerlink" href="#internal-control-variables-icvs" title="Permalink to this headline">#</a></h2>
<p>According to Section 2.3 of the OpenMP 4.0 specification, an OpenMP implementation must act as if there are ICVs that control  the behavior of the program.  This example illustrates two ICVs,  <em>nthreads-var</em>   and  <em>max-active-levels-var</em> . The  <em>nthreads-var</em>  ICV controls the  number of threads requested for encountered parallel regions; there is one copy  of this ICV per task. The  <em>max-active-levels-var</em>  ICV controls the maximum  number of nested active parallel regions; there is one copy of this ICV for the  whole program.</p>
<p>In the following example, the  <em>nest-var</em> ,  <em>max-active-levels-var</em> ,   <em>dyn-var</em> , and  <em>nthreads-var</em>  ICVs are modified through calls to  the runtime library routines <strong>omp_set_nested</strong>, <strong>omp_set_max_active_levels</strong>, <strong>omp_set_dynamic</strong>, and <strong>omp_set_num_threads</strong> respectively. These ICVs  affect the operation of <strong>parallel</strong> regions. Each implicit task generated  by a <strong>parallel</strong> region has its own copy of the  <em>nest-var, dyn-var</em> ,  and  <em>nthreads-var</em>  ICVs.</p>
<p>In the following example, the new value of  <em>nthreads-var</em>  applies only to  the implicit tasks that execute the call to <strong>omp_set_num_threads</strong>. There  is one copy of the  <em>max-active-levels-var</em>  ICV for the whole program and  its value is the same for all tasks. This example assumes that nested parallelism  is supported.</p>
<p>The outer <strong>parallel</strong> region creates a team of two threads; each of the threads  will execute one of the two implicit tasks generated by the outer <strong>parallel</strong>  region.</p>
<p>Each implicit task generated by the outer <strong>parallel</strong> region calls <strong>omp_set_num_threads(3)</strong>,  assigning the value 3 to its respective copy of  <em>nthreads-var</em> . Then each  implicit task encounters an inner <strong>parallel</strong> region that creates a team  of three threads; each of the threads will execute one of the three implicit tasks  generated by that inner <strong>parallel</strong> region.</p>
<p>Since the outer <strong>parallel</strong> region is executed by 2 threads, and the inner  by 3, there will be a total of 6 implicit tasks generated by the two inner <strong>parallel</strong>  regions.</p>
<p>Each implicit task generated by an inner <strong>parallel</strong> region will execute  the call to <strong>omp_set_num_threads(4)</strong>, assigning the value 4 to its respective  copy of  <em>nthreads-var</em> .</p>
<p>The print statement in the outer <strong>parallel</strong> region is executed by only one  of the threads in the team. So it will be executed only once.</p>
<p>The print statement in an inner <strong>parallel</strong> region is also executed by only  one of the threads in the team. Since we have a total of two inner <strong>parallel</strong>  regions, the print statement will be executed twice - once per inner <strong>parallel</strong>  region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: icv.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_set_nested</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_set_max_active_levels</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_set_dynamic</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_set_num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">omp_set_num_threads</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="cp">#pragma omp parallel</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">omp_set_num_threads</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="cp">#pragma omp single</span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                 </span><span class="c1">// The following should print:</span>
<span class="w">                 </span><span class="c1">// Inner: max_act_lev=8, num_thds=3, max_thds=4</span>
<span class="w">                 </span><span class="c1">// Inner: max_act_lev=8, num_thds=3, max_thds=4</span>
<span class="w">              </span><span class="n">printf</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Inner: max_act_lev=%d, num_thds=%d, max_thds=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">omp_get_max_active_levels</span><span class="p">(),</span><span class="w"> </span><span class="n">omp_get_num_threads</span><span class="p">(),</span><span class="w"></span>
<span class="w">              </span><span class="n">omp_get_max_threads</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="cp">#pragma omp barrier</span>
<span class="w">      </span><span class="cp">#pragma omp single</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">                 </span><span class="c1">// The following should print:</span>
<span class="w">                 </span><span class="c1">// Outer: max_act_lev=8, num_thds=2, max_thds=3</span>
<span class="w">          </span><span class="n">printf</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Outer: max_act_lev=%d, num_thds=%d, max_thds=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">omp_get_max_active_levels</span><span class="p">(),</span><span class="w"> </span><span class="n">omp_get_num_threads</span><span class="p">(),</span><span class="w"></span>
<span class="w">                  </span><span class="n">omp_get_max_threads</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">icv</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">program</span><span class="w"> </span><span class="n">icv</span><span class="w"></span>
<span class="w">      </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>

<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">omp_set_nested</span><span class="p">(.</span><span class="nb">true</span><span class="p">.)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">omp_set_max_active_levels</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">omp_set_dynamic</span><span class="p">(.</span><span class="nb">false</span><span class="p">.)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">omp_set_num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">omp_set_num_threads</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">omp_set_num_threads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">single</span><span class="w"></span>
<span class="o">!</span><span class="w">      </span><span class="n">The</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">print</span><span class="o">:</span><span class="w"></span>
<span class="o">!</span><span class="w">      </span><span class="n">Inner</span><span class="o">:</span><span class="w"> </span><span class="n">max_act_lev</span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">num_thds</span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">max_thds</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="o">!</span><span class="w">      </span><span class="n">Inner</span><span class="o">:</span><span class="w"> </span><span class="n">max_act_lev</span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">num_thds</span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">max_thds</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="w">       </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Inner: max_act_lev=&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_max_active_levels</span><span class="p">(),</span><span class="w"></span>
<span class="w">     </span><span class="o">&amp;</span><span class="w">           </span><span class="s">&quot;, num_thds=&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_num_threads</span><span class="p">(),</span><span class="w"></span>
<span class="w">     </span><span class="o">&amp;</span><span class="w">           </span><span class="s">&quot;, max_thds=&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_max_threads</span><span class="p">()</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">single</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">barrier</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">single</span><span class="w"></span>
<span class="o">!</span><span class="w">      </span><span class="n">The</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">print</span><span class="o">:</span><span class="w"></span>
<span class="o">!</span><span class="w">      </span><span class="n">Outer</span><span class="o">:</span><span class="w"> </span><span class="n">max_act_lev</span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">num_thds</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">max_thds</span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">       </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Outer: max_act_lev=&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_max_active_levels</span><span class="p">(),</span><span class="w"></span>
<span class="w">     </span><span class="o">&amp;</span><span class="w">           </span><span class="s">&quot;, num_thds=&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_num_threads</span><span class="p">(),</span><span class="w"></span>
<span class="w">     </span><span class="o">&amp;</span><span class="w">           </span><span class="s">&quot;, max_thds=&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_max_threads</span><span class="p">()</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">single</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="placement-of-flush-barrier-taskwait-and-taskyield-directives">
<h2><span class="section-number">12.3. </span>Placement of <strong>flush</strong>, <strong>barrier</strong>, <strong>taskwait</strong>  and <strong>taskyield</strong> Directives<a class="headerlink" href="#placement-of-flush-barrier-taskwait-and-taskyield-directives" title="Permalink to this headline">#</a></h2>
<p>The following example is non-conforming, because the <strong>flush</strong>, <strong>barrier</strong>,  <strong>taskwait</strong>, and <strong>taskyield</strong>  directives are stand-alone directives  and cannot be the immediate substatement of an <strong>if</strong> statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: standalone.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">standalone_wrong</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp flush(a)</span>
<span class="cm">/* incorrect as flush cannot be immediate substatement</span>
<span class="cm">   of if statement */</span><span class="w"></span>

<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp barrier</span>
<span class="cm">/* incorrect as barrier cannot be immediate substatement</span>
<span class="cm">   of if statement */</span><span class="w"></span>

<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp taskyield</span>
<span class="cm">/* incorrect as taskyield cannot be immediate substatement of if statement</span>
<span class="cm">*/</span><span class="w"></span>

<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp taskwait</span>
<span class="cm">/* incorrect as taskwait cannot be immediate substatement</span>
<span class="cm">   of if statement */</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming, because the <strong>flush</strong>, <strong>barrier</strong>,  <strong>taskwait</strong>, and <strong>taskyield</strong>  directives are stand-alone directives  and cannot be the action statement of an <strong>if</strong> statement or a labeled branch  target.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">standalone</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">     </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>


<span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">STANDALONE_WRONG</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="n">INTEGER</span><span class="w">  </span><span class="n">A</span><span class="w"></span>

<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">FLUSH</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">.</span><span class="n">NE</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">FLUSH</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">BARRIER</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">.</span><span class="n">NE</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">BARRIER</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">TASKWAIT</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">.</span><span class="n">NE</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">TASKWAIT</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">TASKYIELD</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">.</span><span class="n">NE</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">TASKYIELD</span><span class="w"></span>

<span class="w">  </span><span class="n">GOTO</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">FLUSH</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">labeled</span><span class="w"> </span><span class="n">branch</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="mi">100</span><span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">FLUSH</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">GOTO</span><span class="w"> </span><span class="mi">200</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">BARRIER</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">labeled</span><span class="w"> </span><span class="n">branch</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="mi">200</span><span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">  </span><span class="n">GOTO</span><span class="w"> </span><span class="mi">300</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">TASKWAIT</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">labeled</span><span class="w"> </span><span class="n">branch</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="mi">300</span><span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">TASKWAIT</span><span class="w"></span>
<span class="w">  </span><span class="n">GOTO</span><span class="w"> </span><span class="mi">400</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">TASKYIELD</span><span class="w"> </span><span class="n">directive</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">labeled</span><span class="w"> </span><span class="n">branch</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">statement</span><span class="w"></span>
<span class="w">  </span><span class="mi">400</span><span class="w"> </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">TASKYIELD</span><span class="w"></span>

<span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following version of the above example is conforming because the <strong>flush</strong>,  <strong>barrier</strong>, <strong>taskwait</strong>, and <strong>taskyield</strong> directives are enclosed  in a compound statement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: standalone.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_3.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">standalone_ok</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp flush(a)</span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp barrier</span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp taskwait</span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp taskyield</span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is conforming because the <strong>flush</strong>, <strong>barrier</strong>,  <strong>taskwait</strong>, and <strong>taskyield</strong> directives are enclosed in an <strong>if</strong>  construct or follow the labeled branch target.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">standalone</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">     </span><span class="n">omp_3</span><span class="mf">.1</span><span class="w"></span>
<span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">STANDALONE_OK</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">INTEGER</span><span class="w">  </span><span class="n">A</span><span class="w"></span>
<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">.</span><span class="n">NE</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">FLUSH</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">ENDIF</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">.</span><span class="n">NE</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">  </span><span class="n">ENDIF</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">.</span><span class="n">NE</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">TASKWAIT</span><span class="w"></span>
<span class="w">  </span><span class="n">ENDIF</span><span class="w"></span>
<span class="w">  </span><span class="n">IF</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="p">.</span><span class="n">NE</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">THEN</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">TASKYIELD</span><span class="w"></span>
<span class="w">  </span><span class="n">ENDIF</span><span class="w"></span>
<span class="w">  </span><span class="n">GOTO</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">  </span><span class="mi">100</span><span class="w"> </span><span class="n">CONTINUE</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">FLUSH</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">GOTO</span><span class="w"> </span><span class="mi">200</span><span class="w"></span>
<span class="w">  </span><span class="mi">200</span><span class="w"> </span><span class="n">CONTINUE</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">  </span><span class="n">GOTO</span><span class="w"> </span><span class="mi">300</span><span class="w"></span>
<span class="w">  </span><span class="mi">300</span><span class="w"> </span><span class="n">CONTINUE</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">TASKWAIT</span><span class="w"></span>
<span class="w">  </span><span class="n">GOTO</span><span class="w"> </span><span class="mi">400</span><span class="w"></span>
<span class="w">  </span><span class="mi">400</span><span class="w"> </span><span class="n">CONTINUE</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">TASKYIELD</span><span class="w"></span>
<span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="cancellation-constructs">
<h2><span class="section-number">12.4. </span>Cancellation Constructs<a class="headerlink" href="#cancellation-constructs" title="Permalink to this headline">#</a></h2>
<p>The following example shows how the <strong>cancel</strong> directive can be used to terminate  an OpenMP region. Although the <strong>cancel</strong> construct terminates the OpenMP  worksharing region, programmers must still track the exception through the pointer  ex and issue a cancellation for the <strong>parallel</strong> region if an exception has  been raised. The primary thread checks the exception pointer to make sure that the  exception is properly handled in the sequential part. If cancellation of the <strong>parallel</strong>  region has been requested, some threads might have executed <strong>phase_1()</strong>.  However, it is guaranteed that none of the threads executed <strong>phase_2()</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: cancellation.1</span>
<span class="cm">* type: C++</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>

<span class="cp">#define N 10000</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">causes_an_exception</span><span class="p">();</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">phase_1</span><span class="p">();</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">phase_2</span><span class="p">();</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="w"> </span><span class="o">*</span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp parallel shared(ex)</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp for</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// no &#39;if&#39; that prevents compiler optimizations</span>
<span class="w">            </span><span class="n">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">causes_an_exception</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">catch</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// still must remember exception for later handling</span>
<span class="cp">#pragma omp atomic write</span>
<span class="w">                </span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// cancel worksharing construct</span>
<span class="cp">#pragma omp cancel for</span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// if an exception has been raised, cancel parallel region</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp cancel parallel</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">phase_1</span><span class="p">();</span><span class="w"></span>
<span class="cp">#pragma omp barrier</span>
<span class="w">        </span><span class="n">phase_2</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// continue here if an exception has been thrown in</span>
<span class="w">    </span><span class="c1">// the worksharing loop</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// handle exception stored in ex</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example illustrates the use of the <strong>cancel</strong> construct in error  handling. If there is an error condition from the <strong>allocate</strong> statement,  the cancellation is activated. The encountering thread sets the shared variable  <strong>err</strong> and other threads of the binding thread set proceed to the end of  the worksharing construct after the cancellation has been activated.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">cancellation</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">example</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">allocatable</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">shared</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">cancellation</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">    </span><span class="n">allocate</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">dim</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span><span class="w"> </span><span class="n">stat</span><span class="o">=</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="p">.</span><span class="n">gt</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">atomic</span><span class="w"> </span><span class="n">write</span><span class="w"></span>
<span class="w">      </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">cancel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">    </span><span class="n">endif</span><span class="w"></span>
<span class="o">!</span><span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">deallocate</span><span class="w"> </span><span class="n">private</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">B</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">allocated</span><span class="p">(</span><span class="n">B</span><span class="p">))</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">      </span><span class="n">deallocate</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">endif</span><span class="w"></span>
<span class="w">  </span><span class="n">enddo</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example shows how to cancel a parallel search on a binary tree as  soon as the search value has been detected. The code creates a task to descend  into the child nodes of the current tree node. If the search value has been found,  the code remembers the tree node with the found value through an <strong>atomic</strong>  write to the result variable and then cancels execution of all search tasks. The  function <strong>search_tree_parallel</strong> groups all search tasks into a single  task group to control the effect of the <strong>cancel taskgroup</strong> directive. The   <em>level</em>  argument is used to create undeferred tasks after the first ten  levels of the tree.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: cancellation.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">binary_tree_s</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">binary_tree_s</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">right</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">binary_tree_t</span><span class="p">;</span><span class="w"></span>

<span class="n">binary_tree_t</span><span class="w"> </span><span class="o">*</span><span class="nf">search_tree</span><span class="p">(</span><span class="n">binary_tree_t</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">binary_tree_t</span><span class="w"> </span><span class="o">*</span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp task shared(found) if(level &lt; 10)</span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">binary_tree_t</span><span class="w"> </span><span class="o">*</span><span class="n">found_left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">found_left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">search_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found_left</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp atomic write</span>
<span class="w">                    </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">found_left</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp cancel taskgroup</span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp task shared(found) if(level &lt; 10)</span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">binary_tree_t</span><span class="w"> </span><span class="o">*</span><span class="n">found_right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">found_right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">search_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found_right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp atomic write</span>
<span class="w">                    </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">found_right</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp cancel taskgroup</span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp taskwait</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">found</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">binary_tree_t</span><span class="w"> </span><span class="o">*</span><span class="nf">search_tree_parallel</span><span class="p">(</span><span class="n">binary_tree_t</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">binary_tree_t</span><span class="w"> </span><span class="o">*</span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp parallel shared(found, tree, value)</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp masked</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp taskgroup</span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">search_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">found</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following is the equivalent parallel search example in Fortran.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">cancellation</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.1</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">parallel_search</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="w"> </span><span class="n">binary_tree</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="n">type</span><span class="p">(</span><span class="n">binary_tree</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
<span class="w">    </span><span class="n">type</span><span class="p">(</span><span class="n">binary_tree</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">left</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">type</span><span class="w"></span>

<span class="n">contains</span><span class="w"></span>
<span class="w">  </span><span class="n">recursive</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">search_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">type</span><span class="p">(</span><span class="n">binary_tree</span><span class="p">),</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">tree</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="w"></span>
<span class="w">    </span><span class="n">type</span><span class="p">(</span><span class="n">binary_tree</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">found</span><span class="w"></span>
<span class="w">    </span><span class="n">type</span><span class="p">(</span><span class="n">binary_tree</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">found_left</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">NULL</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">                                  </span><span class="n">found_right</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">NULL</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">associated</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tree</span><span class="o">%</span><span class="n">value</span><span class="w"> </span><span class="p">.</span><span class="n">eq</span><span class="p">.</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">tree</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">shared</span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">level</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">call</span><span class="w"> </span><span class="n">search_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">%</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">found_left</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">associated</span><span class="p">(</span><span class="n">found_left</span><span class="p">))</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">          </span><span class="n">found</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">found_left</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">cancel</span><span class="w"> </span><span class="n">taskgroup</span><span class="w"></span>
<span class="w">        </span><span class="n">endif</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">shared</span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">level</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">call</span><span class="w"> </span><span class="n">search_tree</span><span class="p">(</span><span class="n">tree</span><span class="o">%</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">found_right</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">associated</span><span class="p">(</span><span class="n">found_right</span><span class="p">))</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>
<span class="w">          </span><span class="n">found</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">found_right</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">critical</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">cancel</span><span class="w"> </span><span class="n">taskgroup</span><span class="w"></span>
<span class="w">        </span><span class="n">endif</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">taskwait</span><span class="w"></span>
<span class="w">      </span><span class="n">endif</span><span class="w"></span>
<span class="w">    </span><span class="n">endif</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="w">  </span><span class="n">subroutine</span><span class="w"> </span><span class="n">search_tree_parallel</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">type</span><span class="p">(</span><span class="n">binary_tree</span><span class="p">),</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">tree</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="n">type</span><span class="p">(</span><span class="n">binary_tree</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">found</span><span class="w"></span>

<span class="w">    </span><span class="n">found</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">NULL</span><span class="p">()</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">shared</span><span class="p">(</span><span class="n">found</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">masked</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">taskgroup</span><span class="w"></span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">search_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">taskgroup</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">masked</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="n">parallel_search</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="requires-directive">
<h2><span class="section-number">12.5. </span><strong>requires</strong> Directive<a class="headerlink" href="#requires-directive" title="Permalink to this headline">#</a></h2>
<p>The declarative <strong>requires</strong> directive can be used to  specify features that an implementation must provide to compile and  execute correctly.</p>
<p>In the following example the <strong>unified_shared_memory</strong> clause of the <strong>requires</strong> directive ensures that the host and all  devices accessible through OpenMP provide a  <em>unified address</em>  space for memory that is shared by all devices.</p>
<p>The example illustrates the use of the <strong>requires</strong> directive specifying  <em>unified shared memory</em>  in file scope, before any device  directives or device routines. No <strong>map</strong> clause is needed for the  <em>p</em>  structure on the device (and its address  <em>&amp;p</em> , for the C++ code, is the same address on the host and device). However, scalar variables referenced within the <strong>target</strong> construct still have a default data-sharing attribute of firstprivate. The  <em>q</em>  scalar is incremented on the device, and its change is not updated on the host.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       requires.1</span>
<span class="cm">* type:       C++</span>
<span class="cm">* version:    omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="n">using</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">std</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp requires unified_shared_memory</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mypoints</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">500</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">mypoints_t</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">do_something_with_p</span><span class="p">(</span><span class="n">mypoints_t</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">mypoints_t</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target </span><span class="c1">// no map clauses needed</span>
<span class="w">  </span><span class="p">{</span><span class="w">                  </span><span class="c1">// q is firstprivate</span>
<span class="w">     </span><span class="n">q</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="n">do_something_with_p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">res</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// output 1 0</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">do_something_with_p</span><span class="p">(</span><span class="n">mypoints_t</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       requires.1
! type:       F-free
! version:    omp_5.0

module data
!$omp requires unified_shared_memory
  type,public :: mypoints
     double precision :: res
     double precision :: data(500)
  end type
end module

program main
  use data
  type(mypoints) :: p
  integer        :: q=0

  !$omp target    !! no map clauses needed
     q = q + 1    !! q is firstprivate
     call do_something_with_p(p,q)
  !$omp end target

  write(*,&#39;(f5.0,i5)&#39;) p%res, q    !! output 1.   0

end program

subroutine do_something_with_p(p,q)
  use data
  type(mypoints) :: p
  integer        :: q

  p%res = q;
  do i=1,size(p%data)
     p%data(i)=q*i
  enddo

end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-variant-directive">
<h2><span class="section-number">12.6. </span><strong>declare</strong> <strong>variant</strong> Directive<a class="headerlink" href="#declare-variant-directive" title="Permalink to this headline">#</a></h2>
<p>A <strong>declare</strong> <strong>variant</strong> directive specifies an alternate function,   <em>function variant</em> , to be used in place of the  <em>base function</em>   when the trait within the <strong>match</strong> clause matches the OpenMP context at a given call site. The base function follows the directive in the C and C++ languages. In Fortran, either a subroutine or function may be used as the  <em>base function</em> , and the <strong>declare</strong> <strong>variant</strong> directive must be in the specification  part of a subroutine or function (unless a  <em>base-proc-name</em>  modifier is used, as in the case of a procedure declaration statement). See the OpenMP 5.0 Specification for details on the modifier.</p>
<p>When multiple <strong>declare</strong> <strong>variant</strong> directives are used  a function variant becomes a candidate for replacing the base function if the context at the base function call matches the traits of all selectors in the <strong>match</strong> clause. If there are multiple candidates, a score is assigned with rules for each of the selector traits. The scoring algorithm can be found in the OpenMP 5.0 Specification.</p>
<p>In the first example the  <em>vxv()</em>  function is called within a <strong>parallel</strong> region, a <strong>target</strong> region, and in a sequential part of the program.  Two function variants,  <em>p_vxv()</em>  and  <em>t_vxv()</em> , are defined for the first two regions by using  <em>parallel</em>  and  <em>target</em>  selectors (within the  <em>construct</em>  trait set) in a <strong>match</strong> clause.  The  <em>p_vxv()</em>  function variant includes a <strong>for</strong> construct (<strong>do</strong> construct for Fortran) for the <strong>parallel</strong> region,  while  <em>t_vxv()</em>  includes a <strong>distribute</strong> <strong>simd</strong> construct for the <strong>target</strong> region. The  <em>t_vxv()</em>  function is explicitly compiled for the device using a declare target directive.</p>
<p>Since the two <strong>declare</strong> <strong>variant</strong> directives have no selectors that match traits for the context of the base function call in the sequential part of the program, the base  <em>vxv()</em>  function is used there,  as expected. (The vectors in the  <em>p_vxv</em>  and  <em>t_vxv</em>  functions have been multiplied by 3 and 2, respectively, for checking the validity of the replacement. Normally the purpose of a function variant is to produce the same results by a different method.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: declare_variant.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#define N 100</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">p_vxv</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v3</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">t_vxv</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v3</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>

<span class="cp">#pragma omp declare variant( p_vxv ) match( construct={parallel} )</span>
<span class="cp">#pragma omp declare variant( t_vxv ) match( construct={target}   )</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vxv</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v3</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">     </span><span class="c1">// base function</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">  </span><span class="n">v3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">p_vxv</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v3</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">   </span><span class="c1">// function variant</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">  </span><span class="n">v3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">t_vxv</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v3</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">   </span><span class="c1">// function variant</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp distribute simd</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">  </span><span class="n">v3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v3</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">v3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">//init</span>

<span class="w">   </span><span class="cp">#pragma omp parallel</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">v3</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"> </span><span class="c1">//from p_vxv --  output: -3  -30000</span>

<span class="w">   </span><span class="cp">#pragma omp target teams map(to: v1[:N],v2[:N]) map(from: v3[:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">v3</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"> </span><span class="c1">//from t_vxv --  output: -2  -20000</span>

<span class="w">   </span><span class="n">vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">v3</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"> </span><span class="c1">//from   vxv --  output: -1  -10000</span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">declare_variant</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>

<span class="n">module</span><span class="w"> </span><span class="n">subs</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="w">   </span><span class="n">subroutine</span><span class="w"> </span><span class="n">vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">)</span><span class="w">             </span><span class="o">!!</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">function</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="p">,</span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="o">:</span><span class="p">),</span><span class="n">v2</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="p">,</span><span class="n">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="w">             </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">declare</span><span class="w"> </span><span class="n">variant</span><span class="p">(</span><span class="w"> </span><span class="n">p_vxv</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">match</span><span class="p">(</span><span class="w"> </span><span class="n">construct</span><span class="o">=</span><span class="p">{</span><span class="n">parallel</span><span class="p">}</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">declare</span><span class="w"> </span><span class="n">variant</span><span class="p">(</span><span class="w"> </span><span class="n">t_vxv</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">match</span><span class="p">(</span><span class="w"> </span><span class="n">construct</span><span class="o">=</span><span class="p">{</span><span class="n">target</span><span class="p">}</span><span class="w">   </span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="n">n</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">enddo</span><span class="w"></span>

<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="w">   </span><span class="n">subroutine</span><span class="w"> </span><span class="n">p_vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">)</span><span class="w">            </span><span class="o">!!</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">variant</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="p">,</span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="o">:</span><span class="p">),</span><span class="n">v2</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="p">,</span><span class="n">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="w">             </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="w"></span>
<span class="w">      </span><span class="n">n</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">enddo</span><span class="w"></span>

<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="w">   </span><span class="n">subroutine</span><span class="w"> </span><span class="n">t_vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">)</span><span class="w">            </span><span class="o">!!</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">variant</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="p">,</span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="o">:</span><span class="p">),</span><span class="n">v2</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="p">,</span><span class="n">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="w">             </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">n</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">distribute</span><span class="w"> </span><span class="n">simd</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">enddo</span><span class="w"></span>

<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="n">subs</span><span class="w"></span>


<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">subs</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w">           </span><span class="o">::</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">enddo</span><span class="w">  </span><span class="o">!!</span><span class="w"> </span><span class="n">init</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">   </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">v3</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w">    </span><span class="o">!!</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">p_vxv</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">output</span><span class="o">:</span><span class="w"> </span><span class="mi">-3</span><span class="w">  </span><span class="mi">-30000</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">v3</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"></span>
<span class="w">   </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">v3</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w">    </span><span class="o">!!</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">t_vxv</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">output</span><span class="o">:</span><span class="w"> </span><span class="mi">-2</span><span class="w">  </span><span class="mi">-20000</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">vxv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">v3</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w">    </span><span class="o">!!</span><span class="w"> </span><span class="n">from</span><span class="w">   </span><span class="n">vxv</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">output</span><span class="o">:</span><span class="w"> </span><span class="mi">-1</span><span class="w">  </span><span class="mi">-10000</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In this example, traits from the  <em>device</em>  set are used to select a function variant. In the <strong>declare</strong> <strong>variant</strong> directive, an  <em>isa</em>  selector specifies that if the implementation of the ” <em>core-avx512</em> ‘’  instruction set is detected at compile time the  <em>avx512_saxpy()</em>  variant function is used for the call to  <em>base_saxpy()</em> .</p>
<p>A compilation of  <em>avx512_saxpy()</em>  is aware of the AVX-512 instruction set that supports 512-bit vector extensions (for Xeon or Xeon Phi architectures).  Within  <em>avx512_saxpy()</em> , the <strong>parallel</strong> <strong>for</strong> <strong>simd</strong> construct performs parallel execution, and takes advantage of 64-byte data alignment.  When the  <em>avx512_saxpy()</em>  function variant is not selected, the base  <em>base_saxpy()</em>  function variant containing only a basic <strong>parallel</strong> <strong>for</strong> construct is used for the call to  <em>base_saxpy()</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: declare_variant.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w">   </span><span class="nf">base_saxpy</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">avx512_saxpy</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>

<span class="cp">#pragma omp declare variant( avx512_saxpy ) \</span>
<span class="cp">                      match( device={isa(&quot;core-avx512&quot;)} )</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">base_saxpy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w">   </span><span class="c1">// base function</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">avx512_saxpy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="c1">//function variant</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">//assume 64-byte alignment for AVX-512</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for simd simdlen(16) aligned(x,y:64)</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Above may be in another file scope.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 1000</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">64</span><span class="p">)));</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">s</span><span class="o">=</span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">                         </span><span class="c1">// Check for 64-byte aligned</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="p">((</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">y</span><span class="p">)</span><span class="o">%</span><span class="mi">64</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">((</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">x</span><span class="p">)</span><span class="o">%</span><span class="mi">64</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ERROR: x|y not 64-Byte aligned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// initialize</span>

<span class="w">   </span><span class="n">base_saxpy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;y[0],y[N-1]: %5.0f %5.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="c1">//output: y[0],y[N-1]: 3  3000</span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: declare_variant.2
! type: F-free
! version: omp_5.0

module subs
  use omp_lib
contains

   subroutine base_saxpy(s,x,y)              !! base function
      real,intent(inout) :: s,x(:),y(:)
     !$omp  declare variant( avx512_saxpy ) &amp;
     !$omp&amp;           match( device={isa(&quot;core-avx512&quot;)} )

      y = s*x + y

   end subroutine

   subroutine avx512_saxpy(s,x,y)               !! function variant
      real,intent(inout) :: s,x(:),y(:)
      integer            :: i,n
      n=size(x)
                             !!assume 64-byte alignment for AVX-512
      !$omp parallel do simd simdlen(16) aligned(x,y: 64)
      do i = 1,n
         y(i) = s*x(i) + y(i)
      end do

   end subroutine

end module subs


program main
   use omp_lib
   use subs

   integer, parameter :: N=1000, align=64
   real, allocatable  :: x(:),y(:)
   real               :: s = 2.0e0
   integer            :: i

   allocate(x(N),y(N))   !! Assumes allocation is 64-byte aligned
                         !! (using compiler options, or another
                         !! allocation method).

                         !! loc is non-standard, but found everywhere
                         !! remove these lines if not available
   if(modulo(loc(x),align) /= 0 .and. modulo(loc(y),align) /=0 ) then
      print*,&quot;ERROR: x|y not 64-byte aligned&quot;; stop
   endif

   do i=1,N  !! initialize
     x(i)=i
     y(i)=i
   end do

   call base_saxpy(s,x,y)

   write(*,&#39;(&quot;y(1),y(N):&quot;,2f6.0)&#39;) y(1),y(N) !!output: y... 3. 3000.

   deallocate(x,y)

end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="metadirectives">
<h2><span class="section-number">12.7. </span>Metadirectives<a class="headerlink" href="#metadirectives" title="Permalink to this headline">#</a></h2>
<p>A <strong>metadirective</strong> directive provides a mechanism to select a directive in a <strong>when</strong> clause to be used, depending upon one or more contexts:   implementation, available devices and the present enclosing construct.  The directive in an <strong>otherwise</strong> clause is used when a directive of the  <strong>when</strong> clause is not selected.</p>
<p>In the <strong>when</strong> clause the  <em>context selector</em>  (or just  <em>selector</em> ) defines traits that are evaluated for selection of the directive that follows the selector.  This “selectable” directive is called a  <em>directive variant</em> . Traits are grouped by  <em>construct</em> ,  <em>implementation</em>  and   <em>device</em>   <em>sets</em>  to be used by a selector of the same name.</p>
<p>In the first example the architecture trait  <em>arch</em>  of the   <em>device</em>  selector set specifies that if an  <em>nvptx</em>  architecture is active in the OpenMP context, then the <strong>teams</strong> <strong>loop</strong>   <em>directive variant</em>  is selected as the directive; otherwise, the <strong>parallel</strong> <strong>loop</strong>  <em>directive variant</em>  of the <strong>otherwise</strong> clause is selected as the directive. That is, if a  <em>device</em>  of  <em>nvptx</em>  architecture is supported by the implementation within the enclosing <strong>target</strong> construct, its  <em>directive variant</em>  is selected. The architecture names, such as  <em>nvptx</em> , are implementation defined. Also, note that  <em>device</em>  as used in a <strong>target</strong> construct specifies a device number, while  <em>device</em> , as used in the <strong>metadirective</strong> directive as selector set, has traits of  <em>kind</em> ,  <em>isa</em>  and  <em>arch</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: metadirective.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#define N 100</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v3</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target map(to:v1,v2) map(from:v3) device(0)</span>
<span class="w">   </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">                   when(     device={arch(&quot;nvptx&quot;)}: teams loop) \</span>
<span class="cp">                   otherwise(                     parallel loop)</span>
<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">  </span><span class="n">v3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">v3</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"> </span><span class="c1">//output: -1  -10000</span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">metadirective</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">;</span><span class="w">  </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">=-</span><span class="n">i</span><span class="p">;</span><span class="w">  </span><span class="n">enddo</span><span class="w">   </span><span class="o">!</span><span class="w"> </span><span class="n">initialize</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="n">v3</span><span class="p">)</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">metadirective</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">     </span><span class="n">when</span><span class="p">(</span><span class="w">     </span><span class="n">device</span><span class="o">=</span><span class="p">{</span><span class="n">arch</span><span class="p">(</span><span class="s">&quot;nvptx&quot;</span><span class="p">)}</span><span class="o">:</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">loop</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">     </span><span class="n">otherwise</span><span class="p">(</span><span class="w">                     </span><span class="n">parallel</span><span class="w"> </span><span class="n">loop</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">enddo</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">   </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">v3</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">!!</span><span class="n">output</span><span class="o">:</span><span class="w"> </span><span class="mi">-1</span><span class="w">  </span><span class="mi">-10000</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the second example, the  <em>implementation</em>  selector set is specified in the <strong>when</strong> clause to distinguish between platforms.  Additionally, specific architectures are specified with the  <em>device</em>   selector set.</p>
<p>In the code, different <strong>teams</strong> constructs are employed as determined by the <strong>metadirective</strong> directive. The number of teams is restricted by a <strong>num_teams</strong> clause and a thread limit is also set by a <strong>thread_limit</strong> clause for   <em>vendor</em>  platforms and specific architecture traits.  Otherwise, just the <strong>teams</strong> construct is used without any clauses, as prescribed by the <strong>otherwise</strong> clause.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: metadirective.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 100</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">work_on_chunk</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">idev</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w">                    </span><span class="c1">//Driver</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">idev</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">idev</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">idev</span><span class="o">&lt;</span><span class="n">omp_get_num_devices</span><span class="p">();</span><span class="w"> </span><span class="n">idev</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target device(idev)</span>
<span class="w">      </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">               when( implementation={vendor(nvidia)},            \</span>
<span class="cp">                                       device={arch(&quot;kepler&quot;)}:  \</span>
<span class="cp">                     teams num_teams(512) thread_limit(32) )     \</span>
<span class="cp">               when( implementation={vendor(amd)},               \</span>
<span class="cp">                                       device={arch(&quot;fiji&quot;  )}:  \</span>
<span class="cp">                     teams num_teams(512) thread_limit(64) )     \</span>
<span class="cp">               otherwise(                                        \</span>
<span class="cp">                     teams)</span>
<span class="w">      </span><span class="cp">#pragma omp distribute parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">work_on_chunk</span><span class="p">(</span><span class="n">idev</span><span class="p">,</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">metadirective</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w">                    </span><span class="o">!!</span><span class="n">Driver</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">  </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="w"></span>
<span class="w">  </span><span class="n">external</span><span class="w">           </span><span class="o">::</span><span class="w"> </span><span class="n">work_on_chunk</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w">            </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">idev</span><span class="w"></span>

<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="n">idev</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">omp_get_num_devices</span><span class="p">()</span><span class="mi">-1</span><span class="w"></span>

<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="n">idev</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="n">metadirective</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="w"> </span><span class="n">implementation</span><span class="o">=</span><span class="p">{</span><span class="n">vendor</span><span class="p">(</span><span class="n">nvidia</span><span class="p">)},</span><span class="w">        </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">           </span><span class="n">device</span><span class="o">=</span><span class="p">{</span><span class="n">arch</span><span class="p">(</span><span class="s">&quot;kepler&quot;</span><span class="p">)}</span><span class="o">:</span><span class="w">             </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">        </span><span class="n">teams</span><span class="w"> </span><span class="n">num_teams</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span><span class="w"> </span><span class="n">thread_limit</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="w"> </span><span class="n">implementation</span><span class="o">=</span><span class="p">{</span><span class="n">vendor</span><span class="p">(</span><span class="n">amd</span><span class="p">)},</span><span class="w">           </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">           </span><span class="n">device</span><span class="o">=</span><span class="p">{</span><span class="n">arch</span><span class="p">(</span><span class="s">&quot;fiji&quot;</span><span class="w">  </span><span class="p">)}</span><span class="o">:</span><span class="w">             </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">        </span><span class="n">teams</span><span class="w"> </span><span class="n">num_teams</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span><span class="w"> </span><span class="n">thread_limit</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">  </span><span class="n">otherwise</span><span class="p">(</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">distribute</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">       </span><span class="n">call</span><span class="w"> </span><span class="n">work_on_chunk</span><span class="p">(</span><span class="n">idev</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">metadirective</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the third example, a  <em>construct</em>  selector set is specified in the <strong>when</strong> clause.   Here, a <strong>metadirective</strong> directive is used within a function that is also compiled as a function for a target device as directed by a declare target directive. The  <em>target</em>  directive name of the <strong>construct</strong> selector ensures that the <strong>distribute</strong> <strong>parallel</strong> <strong>for/do</strong> construct is employed for the target compilation. Otherwise, for the host-compiled version the <strong>parallel</strong> <strong>for/do</strong> <strong>simd</strong> construct is used.</p>
<p>In the first call to the  <em>exp_pi_diff()</em>  routine the context is a <strong>target</strong> <strong>teams</strong> construct and the <strong>distribute</strong> <strong>parallel</strong> <strong>for/do</strong> construct version of the function is invoked, while in the second call the <strong>parallel</strong> <strong>for/do</strong> <strong>simd</strong> construct version is used.</p>
<p>This case illustrates an important point for users that may want to hoist the  <strong>target</strong> directive out of a function that contains the usual  <strong>target</strong> <strong>teams</strong> <strong>distribute</strong> <strong>parallel</strong> <strong>for/do</strong> construct (for providing alternate constructs through the <strong>metadirective</strong> directive as here). While this combined construct can be decomposed into a <strong>target</strong> and <strong>teams distribute parallel for/do</strong> constructs, the OpenMP 5.0 specification has the restriction: “If a <strong>teams</strong> construct is nested within a <strong>target</strong> construct, that <strong>target</strong> construct must contain no statements, declarations or directives outside of the <strong>teams</strong> construct’’. So, the <strong>teams</strong> construct must immediately follow the <strong>target</strong> construct without any intervening code statements (which includes function calls).   Since the <strong>target</strong> construct alone cannot be hoisted out of a function,  the <strong>target</strong> <strong>teams</strong> construct has been hoisted out of the function, and the  <strong>distribute</strong> <strong>parallel</strong> <strong>for/do</strong> construct is used as the  <em>variant</em>  directive of the <strong>metadirective</strong> directive within the function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: metadirective.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">  </span><span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>
<span class="cp">#define      N 1000</span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">exp_pi_diff</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">my_pi</span><span class="p">){</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">               when(   construct={target}: distribute parallel for ) \</span>
<span class="cp">               otherwise(                  parallel for simd )</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">M_PI</span><span class="o">-</span><span class="n">my_pi</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//Calculates sequence of exponentials: (M_PI-my_pi) * index</span>
<span class="w">  </span><span class="c1">//M_PI is from math.h, and my_pi is user provided.</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">my_pi</span><span class="o">=</span><span class="mf">3.14159265358979e0</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="cp">#pragma omp target teams map(tofrom: d[0:N])</span>
<span class="w">      </span><span class="n">exp_pi_diff</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">my_pi</span><span class="p">);</span><span class="w"></span>
<span class="w">                                           </span><span class="c1">// value should be near 1</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;d[N-1] = %20.14f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ...= 1.00000000000311</span>

<span class="w">      </span><span class="n">exp_pi_diff</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">my_pi</span><span class="p">);</span><span class="w">                </span><span class="c1">// value should be near 1</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;d[N-1] = %20.14f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ...= 1.00000000000311</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">metadirective</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="w"></span>
<span class="w">   </span><span class="n">DOUBLE</span><span class="w"> </span><span class="n">PRECISION</span><span class="p">,</span><span class="w"> </span><span class="n">PARAMETER</span><span class="o">::</span><span class="n">M_PI</span><span class="o">=</span><span class="mf">4.0</span><span class="n">d0</span><span class="o">*</span><span class="n">DATAN</span><span class="p">(</span><span class="mf">1.0</span><span class="n">d0</span><span class="p">)</span><span class="w"></span>
<span class="w">                                     </span><span class="o">!</span><span class="w"> </span><span class="mf">3.1415926535897932</span><span class="n">_8</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>


<span class="n">subroutine</span><span class="w"> </span><span class="n">exp_pi_diff</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w">    </span><span class="n">my_pi</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">  </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="w">          </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">d</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">my_pi</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w">   </span><span class="n">metadirective</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="w"> </span><span class="n">construct</span><span class="o">=</span><span class="p">{</span><span class="n">target</span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="n">distribute</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="p">)</span><span class="w">  </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">      </span><span class="n">otherwise</span><span class="p">(</span><span class="w">                </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">simd</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">M_PI</span><span class="o">-</span><span class="n">my_pi</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">Calculates</span><span class="w"> </span><span class="n">sequence</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">exponentials</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">M_PI</span><span class="o">-</span><span class="n">my_pi</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">M_PI</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">usual</span><span class="w"> </span><span class="n">way</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">my_pi</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">provided</span><span class="p">.</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">Fortran</span><span class="w"> </span><span class="n">Standard</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">provide</span><span class="w"> </span><span class="n">PI</span><span class="w"></span>

<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">  </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w">   </span><span class="o">::</span><span class="w"> </span><span class="n">d</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w">   </span><span class="o">::</span><span class="w"> </span><span class="n">my_pi</span><span class="o">=</span><span class="mf">3.14159265358979</span><span class="n">d0</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">exp_pi_diff</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">my_pi</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"></span>
<span class="w">                                  </span><span class="o">!</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d(N) = &quot;</span><span class="p">,</span><span class="n">d</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="mf">1.00000000000311</span><span class="w"></span>

<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">exp_pi_diff</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">my_pi</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d(N) = &quot;</span><span class="p">,</span><span class="n">d</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="mf">1.00000000000311</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The <strong>user</strong> selector set can be used in a metadirective to select directives at execution time when the  <strong>condition(</strong>  <em>boolean-expr</em>  <strong>)</strong> selector expression is not a constant expression. In this case it is a  <em>dynamic</em>  trait set, and the selection is made at run time, rather than at compile time.</p>
<p>In the following example the  <em>foo</em>  function employs the <strong>condition</strong> selector to choose a device for execution at run time.  In the  <em>bar</em>  routine metadirectives are nested. At the outer level a selection between serial and parallel execution in performed at run time, followed by another run time selection on the schedule kind in the inner level when the active  <em>construct</em>  trait is <strong>parallel</strong>.</p>
<p>(Note, the variable  <em>b</em>  in two of the “selected’’ constructs is declared private for the sole purpose  of detecting and reporting that the construct is used. Since the variable is private, its value  is unchanged outside of the construct region, whereas it is changed if the “unselected’’ construct is used.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       metadirective.4</span>
<span class="cm">* type:       C</span>
<span class="cm">* version:    omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 100</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdbool.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">   </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">     </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_gpu</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="c1">//  use b to detect if run on gpu</span>

<span class="w">   </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">               when( user={condition(use_gpu)}:           \</span>
<span class="cp">                     target teams distribute parallel for \</span>
<span class="cp">                     private(b) map(from:a[0:n]) )        \</span>
<span class="cp">               otherwise(                                 \</span>
<span class="cp">                     parallel for )</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">n</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">;}</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;PASSED 1 of 3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">run_parallel</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">unbalanced</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">               when(user={condition(run_parallel)}: parallel)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">omp_in_parallel</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;PASSED 2 of 3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);}</span><span class="w"></span>

<span class="w">      </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">          when( construct={parallel}, \</span>
<span class="cp">                user={condition(unbalanced)}: for schedule(guided) \</span>
<span class="cp">                                                  private(b)) \</span>
<span class="cp">          when( construct={parallel}        : for schedule(static))</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">n</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">;}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="c1">// if guided b=0, because b is private</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;PASSED 3 of 3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_gpu</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">run_parallel</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">unbalanced</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="c1">// App normally sets these, dependent on input parameters</span>
<span class="w">   </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_gpu</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">run_parallel</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">unbalanced</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Testing: set Env Var MK_FAIL to anything to fail tests</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;MK_FAIL&quot;</span><span class="p">)</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">use_gpu</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="n">run_parallel</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="n">unbalanced</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">foo</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">use_gpu</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">bar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">run_parallel</span><span class="p">,</span><span class="n">unbalanced</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: metadirective.4
! type: F-free
! version: omp_5.2
subroutine foo(a, n, use_gpu)
   integer :: n, a(n)
   logical :: use_gpu

   integer :: b=0   !! use b to detect if run on gpu

   !$omp metadirective &amp;
   !$omp&amp;            when(user={condition(use_gpu)}:           &amp;
   !$omp&amp;                 target teams distribute parallel for &amp;
   !$omp&amp;                 private(b) map(from:a(1:n)) )        &amp;
   !$omp&amp;            otherwise(                                &amp;
   !$omp&amp;                 parallel do)
   do i = 1,n; a(i)=i; if(i==n) b=1; end do

   if(b==0) print *, &quot;PASSED 1 of 3&quot;  ! bc b is firstprivate for gpu run
end subroutine

subroutine bar (a, n, run_parallel, unbalanced)
   use omp_lib, only : omp_get_thread_num
   integer :: n, a(n)
   logical :: run_parallel, unbalanced

   integer :: b=0
   !$omp begin metadirective when(user={condition(run_parallel)}: parallel)

    if(omp_in_parallel() == 1 .and. omp_get_thread_num() == 0) &amp;
       print *,&quot;PASSED 2 of 3&quot;

    !$omp metadirective &amp;
    !$omp&amp;  when(construct={parallel}, user={condition(unbalanced)}: &amp;
    !$omp&amp;         for schedule(guided) private(b)) &amp;
    !$omp&amp;  when(construct={parallel}: for schedule(static))
    do i = 1,n; a(i)=i; if(i==n) b=1; end do

   !$omp end metadirective

   if(b==0) print *, &quot;PASSED 3 of 3&quot;   !!if guided, b=0 since b is private
end subroutine

program meta
   use omp_lib
   integer, parameter :: N=100
   integer :: p(N)
   integer :: env_stat
                !! App normally sets these, dependent on input parameters
   logical ::  use_gpu=.true., run_parallel=.true., unbalanced=.true.

                !! Testing: set Env Var MK_FAIL to anything to fail tests
   call get_environment_variable(&#39;MK_FAIL&#39;,status=env_stat)
   if(env_stat /= 1) then                ! status =1 when not set!
      use_gpu=.false.; run_parallel=.false.; unbalanced=.false.
   endif


   call foo(p, N, use_gpu)
   call bar(p, N, run_parallel,unbalanced)

end program
</pre></div>
</div>
</div>
</div>
<p>Metadirectives can be used in conjunction with templates as shown in the C++ code below. Here the template definition generates two versions of the Fibonacci function. The  <em>tasking</em>  boolean is used in the <strong>condition</strong> selector to enable tasking. The true form implements a parallel version with <strong>task</strong> and <strong>taskwait</strong> constructs as in the  <em>tasking.4.c</em>  code in Section 5.1.  The false form implements a serial version without any tasking constructs. Note that the serial version is used in the parallel function for optimally processing numbers less than 8.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       metadirective.5</span>
<span class="cm">* type:       C++</span>
<span class="cm">* version:    omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="c1">// revised Fibonacci from tasking.4.c example</span>

<span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">tasking</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">tasking</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="mi">8</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// serial/taskless cutoff for n&lt;8</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fib</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">                when(user={condition(tasking)}: task shared(i))</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">i</span><span class="o">=</span><span class="n">fib</span><span class="o">&lt;</span><span class="n">tasking</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">                when(user={condition(tasking)}: task shared(j))</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">j</span><span class="o">=</span><span class="n">fib</span><span class="o">&lt;</span><span class="n">tasking</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="mi">-2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">                when(user={condition(tasking)}: taskwait)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel</span>
<span class="w">  </span><span class="cp">#pragma omp single</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;fib(%i) = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">fib</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// OUTPUT:</span>
<span class="c1">// fib(15) = 610</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="nested-loop-constructs">
<h2><span class="section-number">12.8. </span>Nested Loop Constructs<a class="headerlink" href="#nested-loop-constructs" title="Permalink to this headline">#</a></h2>
<p>The following example of loop construct nesting is conforming because the inner  and outer loop regions bind to different <strong>parallel</strong> regions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nested_loop.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">good_nesting</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel default(shared)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp parallel shared(i, n)</span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#pragma omp for</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nested_loop</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">J</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">GOOD_NESTING</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">DO</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">SHARED</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">         </span><span class="n">DO</span><span class="w"></span>
<span class="w">              </span><span class="n">DO</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">                </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">GOOD_NESTING</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following variation of the preceding example is also conforming:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nested_loop.2</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>


<span class="kt">void</span><span class="w"> </span><span class="nf">work1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel default(shared)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="kt">void</span><span class="w"> </span><span class="nf">good_nesting2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel default(shared)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">work1</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nested_loop</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">J</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">J</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="w">        </span><span class="n">DO</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK1</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">GOOD_NESTING2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="w">      </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">         </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">GOOD_NESTING2</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="restrictions-on-nesting-of-regions">
<h2><span class="section-number">12.9. </span>Restrictions on Nesting of Regions<a class="headerlink" href="#restrictions-on-nesting-of-regions" title="Permalink to this headline">#</a></h2>
<p>The examples in this section illustrate the region nesting rules.</p>
<p>The following example is non-conforming because the inner and outer loop regions  are closely nested:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nesting_restrict.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">wrong1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel default(shared)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="cm">/* incorrect nesting of loop regions */</span><span class="w"></span>
<span class="w">       </span><span class="cp">#pragma omp for</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nesting_restrict</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">J</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK</span><span class="w"></span>

<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG1</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">DO</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">DO</span><span class="w">             </span><span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">nesting</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="n">regions</span><span class="w"></span>
<span class="w">            </span><span class="n">DO</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">              </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>

<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG1</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following orphaned version of the preceding example is also non-conforming:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nesting_restrict.2</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="cm">/* incorrect nesting of loop regions */</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp for</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">wrong2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel default(shared)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">work1</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nesting_restrict</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">       </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">       </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">J</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">DO</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">nesting</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="n">regions</span><span class="w"></span>
<span class="w">        </span><span class="n">DO</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">          </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="w">       </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WORK1</span><span class="w"></span>
<span class="w">       </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">       </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">DO</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">       </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG2</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because the loop and <strong>single</strong> regions  are closely nested:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nesting_restrict.3</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wrong3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel default(shared)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cm">/* incorrect nesting of regions */</span><span class="w"></span>
<span class="w">        </span><span class="cp">#pragma omp single</span>
<span class="w">          </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nesting_restrict</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG3</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">DO</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">SINGLE</span><span class="w">            </span><span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">nesting</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">regions</span><span class="w"></span>
<span class="w">              </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">END</span><span class="w"> </span><span class="n">SINGLE</span><span class="w"></span>
<span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG3</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because a <strong>barrier</strong> region cannot  be closely nested inside a loop region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nesting_restrict.4</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wrong4</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel default(shared)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* incorrect nesting of barrier region in a loop region */</span><span class="w"></span>
<span class="w">        </span><span class="cp">#pragma omp barrier</span>
<span class="w">        </span><span class="n">work</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nesting_restrict</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG4</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="w">        </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">I</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">DO</span><span class="w"></span>
<span class="w">          </span><span class="n">DO</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">nesting</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">region</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="n">region</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">DO</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG4</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because the <strong>barrier</strong> region cannot  be closely nested inside the <strong>critical</strong> region. If this were permitted,  it would result in deadlock due to the fact that only one thread at a time can  enter the <strong>critical</strong> region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nesting_restrict.5</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wrong5</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp critical</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">work</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* incorrect nesting of barrier region in a critical region */</span><span class="w"></span>
<span class="w">       </span><span class="cp">#pragma omp barrier</span>
<span class="w">       </span><span class="n">work</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nesting_restrict</span><span class="mf">.5</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG5</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">CRITICAL</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">nesting</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">region</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">critical</span><span class="w"> </span><span class="n">region</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">END</span><span class="w"> </span><span class="n">CRITICAL</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG5</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is non-conforming because the <strong>barrier</strong> region cannot  be closely nested inside the <strong>single</strong> region. If this were permitted, it  would result in deadlock due to the fact that only one thread executes the <strong>single</strong>  region:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: nesting_restrict.6</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wrong6</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp single</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">work</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* incorrect nesting of barrier region in a single region */</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp barrier</span>
<span class="w">      </span><span class="n">work</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nesting_restrict</span><span class="mf">.6</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">fixed</span><span class="w"></span>
<span class="w">      </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG6</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">INTEGER</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">PARALLEL</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">(</span><span class="n">SHARED</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">SINGLE</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">nesting</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">region</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">region</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">       </span><span class="n">BARRIER</span><span class="w"></span>
<span class="w">            </span><span class="n">CALL</span><span class="w"> </span><span class="n">WORK</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">     </span><span class="n">END</span><span class="w"> </span><span class="n">SINGLE</span><span class="w"></span>
<span class="o">!</span><span class="n">$OMP</span><span class="w">   </span><span class="n">END</span><span class="w"> </span><span class="n">PARALLEL</span><span class="w"></span>
<span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">SUBROUTINE</span><span class="w"> </span><span class="n">WRONG6</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-offload">
<h2><span class="section-number">12.10. </span>Target Offload<a class="headerlink" href="#target-offload" title="Permalink to this headline">#</a></h2>
<p>In the OpenMP 5.0 implementation the <strong>OMP_TARGET_OFFLOAD</strong> environment variable was defined to change  <em>default</em>  offload behavior.  By  <em>default</em>  the target code (region) is executed on the host if the target device  does not exist or the implementation does not support the target device.</p>
<p>In an OpenMP 5.0 compliant implementation, setting the  <strong>OMP_TARGET_OFFLOAD</strong> variable to <strong>MANDATORY</strong> will  force the program to terminate execution when a <strong>target</strong>  construct is encountered and the target device is not supported or is not available. With a value <strong>DEFAULT</strong> the target region will execute on a device if the  device exists and is supported by the implementation, otherwise it will execute on the host. Support for the <strong>DISABLED</strong> value is optional; when it is supported the behavior is as if only the  host device exists (other devices are considered non-existent to the runtime),  and target regions are executed on the host.</p>
<p>The following example reports execution behavior for different  values of the <strong>OMP_TARGET_OFFLOAD</strong> variable. A handy routine  for extracting the <strong>OMP_TARGET_OFFLOAD</strong> environment variable value is deployed here, because the OpenMP API does not have a routine  for obtaining the value.</p>
<p>Note:  The example issues a warning when a pre-5.0 implementation is used, indicating that the <strong>OMP_TARGET_OFFLOAD</strong> is ignored. The value of the <strong>OMP_TARGET_OFFLOAD</strong> variable is reported  when the <strong>OMP_DISPLAY_ENV</strong>  environment variable is set to <strong>TRUE</strong> or <strong>VERBOSE</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_offload_control.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w">    </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">  </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">  </span><span class="cpf">&lt;ctype.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">offload_policy</span><span class="w"></span>
<span class="p">{</span><span class="n">MANDATORY</span><span class="p">,</span><span class="w"> </span><span class="n">DISABLED</span><span class="p">,</span><span class="w"> </span><span class="n">DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="n">UNKNOWN</span><span class="p">,</span><span class="w"> </span><span class="n">NOTSET</span><span class="p">}</span><span class="w"> </span><span class="n">offload_policy_t</span><span class="p">;</span><span class="w"></span>


<span class="n">offload_policy_t</span><span class="w"> </span><span class="nf">get_offload_policy</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">end</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;OMP_TARGET_OFFLOAD&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">env</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">NOTSET</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">env</span><span class="p">);</span><span class="w">                </span><span class="c1">//Find trimmed beginning/end</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="w">      </span><span class="o">*</span><span class="n">env</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">env</span><span class="w">  </span><span class="p">))</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">env</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">end</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">env</span><span class="p">);</span><span class="w"></span>

<span class="w">                    </span><span class="c1">//Find ONLY string -nothing more, case insensitive</span>
<span class="w">   </span><span class="k">if</span><span class="w">      </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MANDATORY&quot;</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">MANDATORY</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;DISABLED&quot;</span><span class="w"> </span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">DISABLED</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;DEFAULT&quot;</span><span class="w">  </span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">DEFAULT</span><span class="w">  </span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w">                                                 </span><span class="k">return</span><span class="w"> </span><span class="n">UNKNOWN</span><span class="w">  </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">device_num</span><span class="p">,</span><span class="w"> </span><span class="n">on_init_dev</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// get policy from OMP_TARGET_OFFLOAD variable</span>
<span class="w">   </span><span class="n">offload_policy_t</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_offload_policy</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">_OPENMP</span><span class="o">&lt;</span><span class="w"> </span><span class="mi">201811</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Warning: OMP_TARGET_OFFLOAD NOT supported, version %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">_OPENMP</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;         If OMP_TARGET_OFFLOAD is set, &quot;</span><span class="w"></span>
<span class="w">             </span><span class="s">&quot;it will be ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Set target device number to an unavailable</span>
<span class="w">   </span><span class="c1">// device to test offload policy.</span>
<span class="w">   </span><span class="n">device_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_num_devices</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Policy:</span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;OMP_TARGET_OFFLOAD Policy:  &quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w">     </span><span class="p">(</span><span class="n">policy</span><span class="o">==</span><span class="n">MANDATORY</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;MANDATORY-Terminate if dev. not avail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">policy</span><span class="o">==</span><span class="n">DISABLED</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;DISABLED -(if supported) Only on Host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">policy</span><span class="o">==</span><span class="n">DEFAULT</span><span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;DEFAULT  -On host if device not avail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">policy</span><span class="o">==</span><span class="n">UNKNOWN</span><span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;OMP_TARGET_OFFLOAD has unknown value</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">policy</span><span class="o">==</span><span class="n">NOTSET</span><span class="w">   </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;OMP_TARGET_OFFLOAD not set</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">);</span><span class="w"></span>


<span class="w">   </span><span class="n">on_init_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// device# out of range--not supported</span>
<span class="w">   </span><span class="cp">#pragma omp target device(device_num) map(tofrom: on_init_dev)</span>
<span class="w">     </span><span class="n">on_init_dev</span><span class="o">=</span><span class="n">omp_is_initial_device</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">policy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MANDATORY</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_OPENMP</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">201811</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ERROR: OpenMP implementation ignored MANDATORY policy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Target region executed on init dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">on_init_dev</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;TRUE&quot;</span><span class="o">:</span><span class="s">&quot;FALSE&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_offload_control.1
! type: F-free
! version: omp_5.0
module offload_policy
  implicit none
  integer, parameter :: LEN_POLICY=10
contains
  character(LEN_POLICY) function get_offload_policy()
     character(64) :: env
     integer       :: length, i
     env=repeat(&#39; &#39;,len(env))
                                    !policy is blank if not found *
     call get_environment_variable(&quot;OMP_TARGET_OFFLOAD&quot;,env,length)

     do i = 1,len(env)              !Makes a-z upper case
        if(iachar(env(i:i))&gt;96) env(i:i)=achar(iachar(env(i:i))-32)
     end do

     get_offload_policy = trim(adjustl(env)) !remove peripheral spaces

     if(length==0) get_offload_policy=&quot;NOTSET&quot;

     return

  end function

end module

program policy_test

  use omp_lib
  use offload_policy

  integer                :: i, device_num
  logical                :: on_init_dev
  character(LEN_POLICY)  :: policy

  policy = get_offload_policy() !!Get OMP_TARGET_OFFLOAD value

  if (OPENMP_VERSION &lt; 201811) then
     print*,&quot;Warning: OMP_TARGET_OFFLOAD NOT supported by VER.&quot;, &amp;
            OPENMP_VERSION
     print*,&quot;         If OMP_TARGET_OFFLOAD is set, it will be ignored.&quot;
  endif

     ! Set target device number to an unavailable device
     ! to test offload policy.
  device_num = omp_get_num_devices() + 1

                      !! Report OMP_TARGET_OFFOAD value
  select CASE (policy)
     case(&quot;MANDATORY&quot;)
          print*,&quot;Policy:  MANDATORY-Terminate if dev. not avail.&quot;
     case(&quot;DISABLED&quot;)
          print*,&quot;Policy:  DISABLED-(if supported) Only on Host.&quot;
     case(&quot;DEFAULT&quot;)
          print*,&quot;Policy:  DEFAULT On host if device not avail.&quot;
     case(&quot;NOTSET&quot;)
          print*,&quot;         OMP_TARGET_OFFLOAD is not set.&quot;
     case DEFAULT
          print*,&quot;         OMP_TARGET_OFFLOAD has unknown value.&quot;
          print*,&quot;         UPPER CASE VALUE=&quot;,policy
  end select


  on_init_dev = .FALSE.
                      !! device# out of range--not supported
  !$omp target  device(device_num) map(tofrom: on_init_dev)
     on_init_dev=omp_is_initial_device()
  !$omp end target

  if (policy==&quot;MANDATORY&quot; .and. OPENMP_VERSION&gt;=201811) then
     print*,&quot;OMP ERROR: &quot;, &amp;
            &quot;OpenMP 5.0 implementation ignored MANDATORY policy.&quot;
     print*,&quot;           Termination should have occurred&quot;, &amp;
            &quot; at target directive.&quot;
  endif

  print*, &quot;Target executed on init dev (T|F): &quot;, on_init_dev

end program policy_test
</pre></div>
</div>
</div>
</div>
</section>
<section id="controlling-concurrency-and-reproducibility-with-the-order-clause">
<h2><span class="section-number">12.11. </span>Controlling Concurrency and Reproducibility with  the <strong>order</strong> Clause<a class="headerlink" href="#controlling-concurrency-and-reproducibility-with-the-order-clause" title="Permalink to this headline">#</a></h2>
<p>The <strong>order</strong> clause is used for controlling the parallel execution of  loop iterations for one or more loops that are associated with a directive.  It is specified with a clause argument and optional modifier.  The only supported argument, introduced in OpenMP 5.0, is the keyword  <strong>concurrent</strong> which indicates that the loop iterations may execute  concurrently, including iterations in the same chunk per the loop schedule.  Because of the relaxed execution permitted with an <strong>order(concurrent)</strong>  clause, codes must not assume that any cross-iteration data dependences  would be preserved or that any two iterations may execute on the same thread.</p>
<p>The following example in this section demonstrates the use of  the <strong>order(concurrent)</strong> clause, without any modifiers, for controlling  the parallel execution of loop iterations. The <strong>order(concurrent)</strong> clause cannot be used for the second and third  <strong>parallel</strong> <strong>for</strong>/<strong>do</strong> constructs because of either having  data dependences or accessing threadprivate variables.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: reproducible.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp threadprivate(sum)</span>

<span class="w">   </span><span class="c1">// no data dependences, so can execute concurrently</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for order(concurrent)</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// with data dependences, so cannot execute iterations</span>
<span class="w">   </span><span class="c1">// concurrently with the order(concurrent) clause</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for ordered</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp ordered</span>
<span class="w">   </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// accessing a threadprivate variable, which would not be</span>
<span class="w">   </span><span class="c1">// permitted if the order(concurrent) clause was present</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for copyin(sum)</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sum = %d on thread %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">());</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">reproducible</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">save</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">sum</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">threadprivate</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!!</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">dependences</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="n">concurrently</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">concurrent</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">      </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="w">   </span><span class="o">!!</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">dependences</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="n">iterations</span><span class="w"></span>
<span class="w">   </span><span class="o">!!</span><span class="w"> </span><span class="n">concurrently</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">concurrent</span><span class="p">)</span><span class="w"> </span><span class="n">clause</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">ordered</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">ordered</span><span class="w"></span>
<span class="w">  </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">ordered</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="w">   </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">   </span><span class="o">!!</span><span class="w"> </span><span class="n">accessing</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">threadprivate</span><span class="w"> </span><span class="n">variable</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">would</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">be</span><span class="w"></span>
<span class="w">   </span><span class="o">!!</span><span class="w"> </span><span class="n">permitted</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">concurrent</span><span class="p">)</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">present</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">copyin</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">      </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="s">&quot;sum = &quot;</span><span class="p">,</span><span class="n">sum</span><span class="p">,</span><span class="s">&quot; on thread &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>Modifiers to the <strong>order</strong> clause, introduced in OpenMP 5.1, may be  specified to control the reproducibility of the loop schedule for  the associated loop(s). A reproducible loop schedule will consistently  yield the same mapping of iterations to threads (or SIMD lanes) if the  directive name, loop schedule, iteration space, and binding region remain  the same. The <strong>reproducible</strong> modifier indicates the loop schedule must  be reproducible, while the <strong>unconstrained</strong> modifier indicates that  the loop schedule is not reproducible. If a modifier is not specified, then the <strong>order</strong> clause does not affect  the reproducibility of the loop schedule.</p>
<p>The next example demonstrates the use of the <strong>order(concurrent)</strong> clause  with modifiers for additionally controlling the reproducibility of a loop’s  schedule. The two worksharing-loop constructs in the first <strong>parallel</strong> construct specify that the loops have reproducible schedules, thus memory effects from iteration  <em>i</em>  from the first loop will be observable to iteration  <em>i</em>  in the second loop.  In the second <strong>parallel</strong> construct, the <strong>order</strong> clause does not  control reproducibility for the loop schedules. However, since both loops  specify the same static schedules, the schedules are reproducible and the  data dependences between the loops are preserved by the execution. In the third <strong>parallel</strong> construct, the <strong>order</strong> clause indicates  that the loops are not reproducible, overriding the default reproducibility prescribed by the specified static schedule. Consequentially,  the <strong>nowait</strong> clause on the first worksharing-loop construct should not  be used to ensure that the data dependences are preserved by the execution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: reproducible.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// reproducible schedules are used for the following two constructs</span>
<span class="w">      </span><span class="cp">#pragma omp for order(reproducible: concurrent) nowait</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp for order(reproducible: concurrent)</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">  </span><span class="o">+=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// static schedules preserve data dependences between the loops</span>
<span class="w">      </span><span class="cp">#pragma omp for schedule(static) order(concurrent) nowait</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp for schedule(static) order(concurrent)</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">  </span><span class="o">+=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// the default reproducibility by the static schedule is not</span>
<span class="w">      </span><span class="c1">// preserved due to the unconstrained order clause.</span>
<span class="w">      </span><span class="c1">// use of nowait here could result in data race.</span>
<span class="w">      </span><span class="cp">#pragma omp for schedule(static) order(unconstrained: concurrent)</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp for schedule(static) order(unconstrained: concurrent)</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">  </span><span class="o">+=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">reproducible</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.1</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">   </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">      </span><span class="o">!!</span><span class="w"> </span><span class="n">reproducible</span><span class="w"> </span><span class="n">schedules</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">constructs</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">reproducible</span><span class="o">:</span><span class="w"> </span><span class="n">concurrent</span><span class="p">)</span><span class="w"> </span><span class="n">nowait</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">         </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">reproducible</span><span class="o">:</span><span class="w"> </span><span class="n">concurrent</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">      </span><span class="o">!!</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">schedules</span><span class="w"> </span><span class="n">preserve</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">dependences</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">loops</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">schedule</span><span class="p">(</span><span class="k">static</span><span class="p">)</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">concurrent</span><span class="p">)</span><span class="w"> </span><span class="n">nowait</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">         </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">schedule</span><span class="p">(</span><span class="k">static</span><span class="p">)</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">concurrent</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>
<span class="w">      </span><span class="o">!!</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n">reproducibility</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">schedule</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"></span>
<span class="w">      </span><span class="o">!!</span><span class="w"> </span><span class="n">preserved</span><span class="w"> </span><span class="n">due</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">unconstrained</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="n">clause</span><span class="p">.</span><span class="w"></span>
<span class="w">      </span><span class="o">!!</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">nowait</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="n">could</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">race</span><span class="p">.</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">schedule</span><span class="p">(</span><span class="k">static</span><span class="p">)</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">unconstrained</span><span class="o">:</span><span class="w"> </span><span class="n">concurrent</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">         </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">schedule</span><span class="p">(</span><span class="k">static</span><span class="p">)</span><span class="w"> </span><span class="n">order</span><span class="p">(</span><span class="n">unconstrained</span><span class="o">:</span><span class="w"> </span><span class="n">concurrent</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">         </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="interop-construct">
<h2><span class="section-number">12.12. </span><strong>interop</strong> Construct<a class="headerlink" href="#interop-construct" title="Permalink to this headline">#</a></h2>
<p>The <strong>interop</strong> construct allows OpenMP to interoperate with foreign runtime environments. In the example below, asynchronous cuda memory copies and a  <em>cublasDaxpy</em>  routine are executed  in a cuda stream. Also, an asynchronous target task execution (having a <strong>nowait</strong> clause)  and two explicit tasks are executed through OpenMP directives.  Scheduling dependences (synchronization) are imposed on the foreign stream and the OpenMP tasks through <strong>depend</strong> clauses.</p>
<p>First, an interop object,  <em>obj</em> , is initialized for synchronization by including the <strong>targetsync</strong>  <em>interop-type</em>  in the interop <strong>init</strong> clause  (<strong>init(</strong> <strong>targetsync,obj</strong> <strong>)</strong>).   The object provides access to the foreign runtime. The <strong>depend</strong> clause provides a dependence behavior for foreign tasks associated with a valid object.</p>
<p>Next, the <strong>omp_get_interop_int</strong> routine is used to extract the foreign  runtime id (<strong>omp_ipr_fr_id</strong>), and a test in the next statement ensures  that the cuda runtime (<strong>omp_ifr_cuda</strong>) is available.</p>
<p>Within the block for executing the  <em>cublasDaxpy</em>  routine, a stream is acquired  with the <strong>omp_get_interop_ptr</strong> routine, which returns a cuda stream ( <em>s</em> ). The stream is included in the cublas handle, and used directly in the asynchronous memory routines.  The following <strong>interop</strong> construct, with the <strong>destroy</strong> clause,  ensures that the foreign tasks have completed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       interop.1</span>
<span class="cm">* type:       C</span>
<span class="cm">* version:    omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cublas_v2.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda_runtime_api.h&gt;</span><span class="cp"></span>

<span class="cp">#define N 16384</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">myVectorSet</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">myDaxpy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">myDscal</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">scalar</span><span class="o">=</span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">d_y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w">    </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">omp_interop_t</span><span class="w"> </span><span class="n">obj</span><span class="o">=</span><span class="n">omp_interop_none</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">intptr_t</span><span class="w">  </span><span class="n">type</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Async Memcpy requires pinned memory</span>
<span class="w">  </span><span class="n">cudaMallocHost</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w">   </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocHost</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span><span class="w">   </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="w">     </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="w">     </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d_y</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_target_associate_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">omp_target_associate_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">d_y</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target nowait depend(out: x[0:N]) \</span>
<span class="cp">                     map(from: x[0:N]) device(dev)</span>
<span class="w">  </span><span class="n">myVectorSet</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp task depend(out: y[0:N])</span>
<span class="w">  </span><span class="n">myVectorSet</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// get obj for syncing</span>
<span class="w">  </span><span class="cp">#pragma omp interop init(targetsync: obj) device(dev) \</span>
<span class="cp">                 depend(in: x[0:N]) depend(inout: y[0:N])</span>

<span class="w">                                        </span><span class="c1">//foreign rt id and string name</span>
<span class="w">  </span><span class="kt">int</span><span class="w">        </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w">  </span><span class="p">)</span><span class="n">omp_get_interop_int</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">omp_ipr_fr_id</span><span class="p">,</span><span class="w">   </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">rt_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">omp_get_interop_str</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">omp_ipr_fr_name</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">obj</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">omp_interop_none</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">omp_ifr_cuda</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; OpenMP working with %s runtime to execute cublas daxpy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">rt_name</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cublasHandle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cublasCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">s</span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="n">cudaStream_t</span><span class="p">)</span><span class="n">omp_get_interop_ptr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">omp_ipr_targetsync</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">omp_irc_success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;ERROR: Failed to get %s stream, rt error= %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">rt_name</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="k">if</span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">omp_irc_no_value</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="s">&quot;Parameters valid, no meaningful value available.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">cublasSetStream</span><span class="p">(</span><span class="w"> </span><span class="n">handle</span><span class="p">,</span><span class="n">s</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="w"> </span><span class="n">d_x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">),</span><span class="w"></span>
<span class="w">                     </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="w"> </span><span class="n">d_y</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">),</span><span class="w"></span>
<span class="w">                     </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cublasDaxpy</span><span class="p">(</span><span class="w">     </span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scalar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">d_y</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">),</span><span class="w"></span>
<span class="w">                     </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">     </span><span class="c1">// Execute as OpenMP offload.</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; Notice: Offloading myDaxpy to perform daxpy calculation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cp">#pragma omp target depend(inout: y[0:N]) depend(in: x[0:N]) nowait \</span>
<span class="cp">                       map(to: x[0:N]) map(tofrom: y[0:N]) device(dev)</span>
<span class="w">    </span><span class="n">myDaxpy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// This also ensures foreign tasks complete.</span>
<span class="w">  </span><span class="cp">#pragma omp interop destroy(obj) nowait depend(out: y[0:N])</span>

<span class="w">  </span><span class="cp">#pragma omp target depend(inout: x[0:N])</span>
<span class="w">  </span><span class="n">myDscal</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp taskwait</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(-1:-16384) %f:%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(-2:-32768) %f:%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="utilities">
<h2><span class="section-number">12.13. </span>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">#</a></h2>
<p>This section contains examples of utility routines and features.</p>
<section id="timing-routines">
<h3><span class="section-number">12.13.1. </span>Timing Routines<a class="headerlink" href="#timing-routines" title="Permalink to this headline">#</a></h3>
<p>The <strong>omp_get_wtime</strong> routine can be used to measure the elapsed wall clock time (in seconds) of code execution in a program. The routine is thread safe and can be executed by multiple threads concurrently. The precision of the timer can be obtained by a call to the <strong>omp_get_wtick</strong> routine. The following example shows a use case.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: get_wtime.1</span>
<span class="cm">* type: C</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">work_to_be_timed</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">work_to_be_timed</span><span class="p">();</span><span class="w">     </span><span class="c1">// any parallel or serial codes</span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Work took %f seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Precision of the timer is %f (sec)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_wtick</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">get_wtime</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">work_to_be_timed</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="p">,</span><span class="w"> </span><span class="n">intrinsic</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">iso_c_binding</span><span class="p">,</span><span class="w"> </span><span class="n">only</span><span class="o">:</span><span class="w"> </span><span class="n">c_int</span><span class="w"></span>
<span class="w">  </span><span class="n">interface</span><span class="w"></span>
<span class="w">     </span><span class="n">subroutine</span><span class="w"> </span><span class="n">fsleep</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span><span class="w"> </span><span class="n">bind</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s">&quot;sleep&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="n">import</span><span class="w"> </span><span class="n">c_int</span><span class="w"></span>
<span class="w">       </span><span class="n">integer</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">sec</span><span class="w"></span>
<span class="w">     </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">interface</span><span class="w"></span>
<span class="w">  </span><span class="n">call</span><span class="w"> </span><span class="n">fsleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">do_work</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">  </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"></span>

<span class="w">  </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">call</span><span class="w"> </span><span class="n">work_to_be_timed</span><span class="w">    </span><span class="o">!</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">serial</span><span class="w"> </span><span class="n">codes</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_wtime</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Work took&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;seconds&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Precision of the timer is&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_wtick</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;(sec)&quot;</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="environment-display">
<h3><span class="section-number">12.13.2. </span>Environment Display<a class="headerlink" href="#environment-display" title="Permalink to this headline">#</a></h3>
<p>The OpenMP version number and the values of ICVs associated with the relevant environment variables can be displayed at runtime by setting  the <strong>OMP_DISPLAY_ENV</strong> environment variable to either  <strong>TRUE</strong> or <strong>VERBOSE</strong>. The information is displayed once by the runtime.</p>
<p>A more flexible or controllable approach is to call  the <strong>omp_display_env</strong> API routine at any desired point of a code to display the same information. This OpenMP 5.1 API routine takes a single  <em>verbose</em>  argument. A value of 0 or .false. (for C/C++ or Fortran) indicates the required OpenMP ICVs associated with environment variables be displayed, and a value of 1 or .true. (for C/C++ or Fortran) will include vendor-specific ICVs that can be modified by environment variables.</p>
<p>The following example illustrates the conditional execution of the API <strong>omp_display_env</strong> routine.  Typically it would be invoked in various debug modes of an application.  An important use case is to have a single MPI process (e.g., rank = 0)  of a hybrid (MPI+OpenMP) code execute the routine, instead of all MPI processes, as would be done by  setting the <strong>OMP_DISPLAY_ENV</strong> to <strong>TRUE</strong> or <strong>VERBOSE</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: display_env.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="c1">//implementers: customize debug routines for app debugging</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">debug</span><span class="p">(){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">debug_omp_verbose</span><span class="p">(){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">debug</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">omp_display_env</span><span class="p">(</span><span class="w"> </span><span class="n">debug_omp_verbose</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="c1">// ...</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">display_env</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="n">implementers</span><span class="o">:</span><span class="w"> </span><span class="n">customize</span><span class="w"> </span><span class="n">debug</span><span class="w"> </span><span class="n">routines</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="n">debugging</span><span class="w"></span>
<span class="n">function</span><span class="w">  </span><span class="n">debug</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">logical</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">debug</span><span class="w"></span>
<span class="w">  </span><span class="n">debug</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="nb">true</span><span class="p">.</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>

<span class="n">function</span><span class="w"> </span><span class="n">debug_omp_verbose</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">logical</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">debug_omp_verbose</span><span class="w"></span>
<span class="w">  </span><span class="n">debug_omp_verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="nb">false</span><span class="p">.</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">display_omp_environment</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">  </span><span class="n">logical</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">debug</span><span class="p">,</span><span class="w"> </span><span class="n">debug_omp_verbose</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">debug</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">omp_display_env</span><span class="p">(</span><span class="w"> </span><span class="n">debug_omp_verbose</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">!!</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>A sample output from the execution of the code might look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPENMP</span> <span class="n">DISPLAY</span> <span class="n">ENVIRONMENT</span> <span class="n">BEGIN</span>
     <span class="n">_OPENMP</span><span class="o">=</span><span class="s1">&#39;202011&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_AFFINITY_FORMAT</span><span class="o">=</span><span class="s1">&#39;(null)&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_ALLOCATOR</span><span class="o">=</span><span class="s1">&#39;omp_default_mem_alloc&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_CANCELLATION</span><span class="o">=</span><span class="s1">&#39;FALSE&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_DEFAULT_DEVICE</span><span class="o">=</span><span class="s1">&#39;0&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_DISPLAY_AFFINITY</span><span class="o">=</span><span class="s1">&#39;FALSE&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_DISPLAY_ENV</span><span class="o">=</span><span class="s1">&#39;FALSE&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_DYNAMIC</span><span class="o">=</span><span class="s1">&#39;FALSE&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_MAX_ACTIVE_LEVELS</span><span class="o">=</span><span class="s1">&#39;1&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_MAX_TASK_PRIORITY</span><span class="o">=</span><span class="s1">&#39;0&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_NESTED</span><span class="p">:</span> <span class="n">deprecated</span><span class="p">;</span> <span class="nb">max</span><span class="o">-</span><span class="n">active</span><span class="o">-</span><span class="n">levels</span><span class="o">-</span><span class="n">var</span><span class="o">=</span><span class="mi">1</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_NUM_THREADS</span><span class="p">:</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_PLACES</span><span class="p">:</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_PROC_BIND</span><span class="p">:</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_SCHEDULE</span><span class="o">=</span><span class="s1">&#39;static&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_STACKSIZE</span><span class="o">=</span><span class="s1">&#39;4M&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_TARGET_OFFLOAD</span><span class="o">=</span><span class="n">DEFAULT</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_THREAD_LIMIT</span><span class="o">=</span><span class="s1">&#39;0&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_TOOL</span><span class="o">=</span><span class="s1">&#39;enabled&#39;</span>    
    <span class="p">[</span><span class="n">host</span><span class="p">]</span> <span class="n">OMP_TOOL_LIBRARIES</span><span class="p">:</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>  
<span class="n">OPENMP</span> <span class="n">DISPLAY</span> <span class="n">ENVIRONMENT</span> <span class="n">END</span>
</pre></div>
</div>
</section>
<section id="error-directive">
<h3><span class="section-number">12.13.3. </span><strong>error</strong> Directive<a class="headerlink" href="#error-directive" title="Permalink to this headline">#</a></h3>
<p>The <strong>error</strong> directive provides a consistent method for C, C++, and Fortran to emit a  <em>fatal</em>  or  <em>warning</em>  message at  <em>compilation</em>  or  <em>execution</em>  time, as determined by a <strong>severity</strong>  or an <strong>at</strong> clause, respectively. When <strong>severity(fatal)</strong> is present, the compilation  or execution is aborted. Without any clauses the default behavior is as if <strong>at(compilation)</strong>  and <strong>severity(fatal)</strong> were specified.</p>
<p>The C, C++, and Fortran examples below show all the cases for reporting messages.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       error.1</span>
<span class="cm">* type:       C</span>
<span class="cm">* version:    omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">   </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>

<span class="cp">#pragma omp metadirective \</span>
<span class="cp">            when(implementation={vendor(gnu)}: nothing )   \</span>
<span class="cp">            otherwise(error at(compilation) severity(fatal) \</span>
<span class="cp">                    message(&quot;GNU compiler required.&quot;))</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">omp_get_num_procs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp error at(runtime) severity(fatal) \</span>
<span class="cp">                      message(&quot;3 or more procs required.&quot;)</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp parallel master</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Give notice about master deprecation at compile time and run time.</span>
<span class="w">    </span><span class="cp">#pragma omp error at(compilation) severity(warning) \</span>
<span class="cp">                      message(&quot;Notice: master is deprecated.&quot;)</span>
<span class="w">    </span><span class="cp">#pragma omp error at(runtime) severity(warning) \</span>
<span class="cp">                      message(&quot;Notice: masked used next release.&quot;)</span>

<span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; Hello from thread number 0.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w">       </span><span class="n">error</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w">       </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>

<span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">metadirective</span><span class="w">  </span><span class="o">&amp;</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">     </span><span class="n">when</span><span class="p">(</span><span class="w"> </span><span class="n">implementation</span><span class="o">=</span><span class="p">{</span><span class="n">vendor</span><span class="p">(</span><span class="n">gnu</span><span class="p">)}</span><span class="o">:</span><span class="w"> </span><span class="n">nothing</span><span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">     </span><span class="n">otherwise</span><span class="p">(</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">at</span><span class="p">(</span><span class="n">compilation</span><span class="p">)</span><span class="w"> </span><span class="n">severity</span><span class="p">(</span><span class="n">fatal</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">                </span><span class="n">message</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;GNU compiler required.&quot;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>


<span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">omp_get_num_procs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">error</span><span class="w"> </span><span class="n">at</span><span class="p">(</span><span class="n">runtime</span><span class="p">)</span><span class="w"> </span><span class="n">severity</span><span class="p">(</span><span class="n">fatal</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">message</span><span class="p">(</span><span class="s">&quot;3 or more procs required.&quot;</span><span class="p">)</span><span class="w"></span>
<span class="n">endif</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">master</span><span class="w"></span>

<span class="o">!!</span><span class="w"> </span><span class="n">Give</span><span class="w"> </span><span class="n">notice</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="n">deprecation</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">time</span><span class="p">.</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">error</span><span class="w"> </span><span class="n">at</span><span class="p">(</span><span class="n">compilation</span><span class="p">)</span><span class="w"> </span><span class="n">severity</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">message</span><span class="p">(</span><span class="s">&quot;Notice: master is deprecated.&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">error</span><span class="w"> </span><span class="n">at</span><span class="p">(</span><span class="n">runtime</span><span class="p">)</span><span class="w"> </span><span class="n">severity</span><span class="p">(</span><span class="n">warning</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">message</span><span class="p">(</span><span class="s">&quot;Notice: masked to be used in next release.&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot; Hello from thread number 0.&quot;</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">master</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents/Chap_program_control"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../Chap_memory_model/Chap_memory_model.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">11. </span>Memory Model</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../Chap_ompt_interface/Chap_ompt_interface.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">13. </span>OMPT Interface</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The OpenMP Community<br/>
  
      &copy; <a href="../../copyright.html">Copyright</a> 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>