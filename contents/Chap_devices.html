
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Devices &#8212; OpenMP Application Programming Interface Examples</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="SIMD" href="Chap_SIMD.html" />
    <link rel="prev" title="Tasking" href="Chap_tasking.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Welcome to OMP Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Title_Page.html">
   Cover
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Foreword_Chapt.html">
   Foreword
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_introduction.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_directives.html">
   OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_parallel_execution.html">
   Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_affinity.html">
   OpenMP Affinity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_tasking.html">
   Tasking
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Devices
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_SIMD.html">
   SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_synchronization.html">
   Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_data_environment.html">
   Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_memory_model.html">
   Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_program_control.html">
   Program Control
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_devices.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/passlab/Examples"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_devices.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/contents/Chap_devices.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-construct">
   <strong>
    target
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-on-parallel-construct">
     <strong>
      target
     </strong>
     Construct on
     <strong>
      parallel
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-with-map-clause">
     <strong>
      target
     </strong>
     Construct with
     <strong>
      map
     </strong>
     Clause
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map-clause-with-to-from-map-types">
     <strong>
      map
     </strong>
     Clause with
     <strong>
      to
     </strong>
     /
     <strong>
      from
     </strong>
     map-types
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map-clause-with-array-sections">
     <strong>
      map
     </strong>
     Clause with Array Sections
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-with-if-clause">
     <strong>
      target
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-reverse-offload">
     Target Reverse Offload
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defaultmap-clause">
   <strong>
    defaultmap
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pointer-mapping">
   Pointer Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#structure-mapping">
   Structure Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fortran-allocatable-array-mapping">
   Fortran Allocatable Array Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-sections-in-device-constructs">
   Array Sections in Device Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#c-virtual-functions">
   C++ Virtual Functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-shaping">
   Array Shaping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-mapper-directive">
   <strong>
    declare mapper
   </strong>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-data-construct">
   <strong>
    target
   </strong>
   <strong>
    data
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-target-data-construct">
     Simple
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-region-enclosing-multiple-target-regions">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Region Enclosing Multiple
     <strong>
      target
     </strong>
     Regions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-construct-with-orphaned-call">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct with Orphaned Call
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-construct-with-if-clause">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-enter-data-and-target-exit-data-constructs">
   <strong>
    target
   </strong>
   <strong>
    enter
   </strong>
   <strong>
    data
   </strong>
   and
   <strong>
    target
   </strong>
   <strong>
    exit
   </strong>
   <strong>
    data
   </strong>
   Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-update-construct">
   <strong>
    target
   </strong>
   <strong>
    update
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-target-data-and-target-update-constructs">
     Simple
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     and
     <strong>
      target
     </strong>
     <strong>
      update
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-update-construct-with-if-clause">
     <strong>
      target
     </strong>
     <strong>
      update
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-target-directive">
   Declare Target Directive
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-a-procedure">
     Declare Target Directive for a Procedure
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-class-type">
     Declare Target Directive for Class Type
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-variables">
     Declare Target Directive for Variables
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-with-declare-simd">
     Declare Target Directive with
     <strong>
      declare
     </strong>
     <strong>
      simd
     </strong>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-with-link-clause">
     Declare Target Directive with
     <strong>
      link
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lambda-expressions">
   Lambda Expressions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#teams-construct-and-related-combined-constructs">
   <strong>
    teams
   </strong>
   Construct and Related Combined Constructs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-and-teams-constructs-with-omp-get-num-teams-and-omp-get-team-num-routines">
     <strong>
      target
     </strong>
     and
     <strong>
      teams
     </strong>
     Constructs with
     <strong>
      omp_get_num_teams
     </strong>
     and
     <strong>
      omp_get_team_num
     </strong>
     Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-constructs">
     <strong>
      target
     </strong>
     ,
     <strong>
      teams
     </strong>
     , and
     <strong>
      distribute
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     , and Distribute Parallel Loop Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-constructs-with-scheduling-clauses">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and Distribute Parallel Loop  Constructs with Scheduling Clauses
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-simd-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and
     <strong>
      distribute
     </strong>
     <strong>
      simd
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-simd-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and Distribute Parallel Loop SIMD Constructs
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#asynchronous-target-execution-and-dependences">
   Asynchronous
   <strong>
    target
   </strong>
   Execution and Dependences
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-target-with-tasks">
     Asynchronous
     <strong>
      target
     </strong>
     with Tasks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nowait-clause-on-target-construct">
     <strong>
      nowait
     </strong>
     Clause on
     <strong>
      target
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-target-with-nowait-and-depend-clauses">
     Asynchronous
     <strong>
      target
     </strong>
     with
     <strong>
      nowait
     </strong>
     and
     <strong>
      depend
     </strong>
     Clauses
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#device-routines">
   Device Routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-is-initial-device-routine">
     <strong>
      omp_is_initial_device
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-get-num-devices-routine">
     <strong>
      omp_get_num_devices
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-set-default-device-and-omp-get-default-device-routines">
     <strong>
      omp_set_default_device
     </strong>
     and
     <strong>
      omp_get_default_device
     </strong>
     Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-memory-and-device-pointers-routines">
     Target Memory and Device Pointers Routines
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Devices</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-construct">
   <strong>
    target
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-on-parallel-construct">
     <strong>
      target
     </strong>
     Construct on
     <strong>
      parallel
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-with-map-clause">
     <strong>
      target
     </strong>
     Construct with
     <strong>
      map
     </strong>
     Clause
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map-clause-with-to-from-map-types">
     <strong>
      map
     </strong>
     Clause with
     <strong>
      to
     </strong>
     /
     <strong>
      from
     </strong>
     map-types
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map-clause-with-array-sections">
     <strong>
      map
     </strong>
     Clause with Array Sections
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-with-if-clause">
     <strong>
      target
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-reverse-offload">
     Target Reverse Offload
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defaultmap-clause">
   <strong>
    defaultmap
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pointer-mapping">
   Pointer Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#structure-mapping">
   Structure Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fortran-allocatable-array-mapping">
   Fortran Allocatable Array Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-sections-in-device-constructs">
   Array Sections in Device Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#c-virtual-functions">
   C++ Virtual Functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-shaping">
   Array Shaping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-mapper-directive">
   <strong>
    declare mapper
   </strong>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-data-construct">
   <strong>
    target
   </strong>
   <strong>
    data
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-target-data-construct">
     Simple
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-region-enclosing-multiple-target-regions">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Region Enclosing Multiple
     <strong>
      target
     </strong>
     Regions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-construct-with-orphaned-call">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct with Orphaned Call
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-construct-with-if-clause">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-enter-data-and-target-exit-data-constructs">
   <strong>
    target
   </strong>
   <strong>
    enter
   </strong>
   <strong>
    data
   </strong>
   and
   <strong>
    target
   </strong>
   <strong>
    exit
   </strong>
   <strong>
    data
   </strong>
   Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-update-construct">
   <strong>
    target
   </strong>
   <strong>
    update
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-target-data-and-target-update-constructs">
     Simple
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     and
     <strong>
      target
     </strong>
     <strong>
      update
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-update-construct-with-if-clause">
     <strong>
      target
     </strong>
     <strong>
      update
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-target-directive">
   Declare Target Directive
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-a-procedure">
     Declare Target Directive for a Procedure
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-class-type">
     Declare Target Directive for Class Type
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-variables">
     Declare Target Directive for Variables
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-with-declare-simd">
     Declare Target Directive with
     <strong>
      declare
     </strong>
     <strong>
      simd
     </strong>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-with-link-clause">
     Declare Target Directive with
     <strong>
      link
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lambda-expressions">
   Lambda Expressions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#teams-construct-and-related-combined-constructs">
   <strong>
    teams
   </strong>
   Construct and Related Combined Constructs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-and-teams-constructs-with-omp-get-num-teams-and-omp-get-team-num-routines">
     <strong>
      target
     </strong>
     and
     <strong>
      teams
     </strong>
     Constructs with
     <strong>
      omp_get_num_teams
     </strong>
     and
     <strong>
      omp_get_team_num
     </strong>
     Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-constructs">
     <strong>
      target
     </strong>
     ,
     <strong>
      teams
     </strong>
     , and
     <strong>
      distribute
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     , and Distribute Parallel Loop Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-constructs-with-scheduling-clauses">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and Distribute Parallel Loop  Constructs with Scheduling Clauses
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-simd-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and
     <strong>
      distribute
     </strong>
     <strong>
      simd
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-simd-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and Distribute Parallel Loop SIMD Constructs
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#asynchronous-target-execution-and-dependences">
   Asynchronous
   <strong>
    target
   </strong>
   Execution and Dependences
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-target-with-tasks">
     Asynchronous
     <strong>
      target
     </strong>
     with Tasks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nowait-clause-on-target-construct">
     <strong>
      nowait
     </strong>
     Clause on
     <strong>
      target
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-target-with-nowait-and-depend-clauses">
     Asynchronous
     <strong>
      target
     </strong>
     with
     <strong>
      nowait
     </strong>
     and
     <strong>
      depend
     </strong>
     Clauses
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#device-routines">
   Device Routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-is-initial-device-routine">
     <strong>
      omp_is_initial_device
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-get-num-devices-routine">
     <strong>
      omp_get_num_devices
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-set-default-device-and-omp-get-default-device-routines">
     <strong>
      omp_set_default_device
     </strong>
     and
     <strong>
      omp_get_default_device
     </strong>
     Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-memory-and-device-pointers-routines">
     Target Memory and Device Pointers Routines
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="devices">
<h1>Devices<a class="headerlink" href="#devices" title="Permalink to this headline">#</a></h1>
<p>The <strong>target</strong> construct consists of a <strong>target</strong> directive  and an execution region. The <strong>target</strong> region is executed on the default device or the device specified in the <strong>device</strong>  clause.</p>
<p>In OpenMP version 4.0, by default, all variables within the lexical scope of the construct are copied  <em>to</em>  and  <em>from</em>  the device, unless the device is the host, or the data exists on the device from a previously executed data-type construct that has created space on the device and possibly copied host data to the device storage.</p>
<p>The constructs that explicitly create storage, transfer data, and free storage on the device are categorized as structured and unstructured. The <strong>target</strong> <strong>data</strong> construct is structured. It creates a data region around <strong>target</strong> constructs, and is convenient for providing persistent data throughout multiple <strong>target</strong> regions. The <strong>target</strong> <strong>enter</strong> <strong>data</strong> and  <strong>target</strong> <strong>exit</strong> <strong>data</strong> constructs are unstructured, because  they can occur anywhere and do not support a “structure”  (a region) for enclosing <strong>target</strong> constructs, as does the <strong>target</strong> <strong>data</strong> construct.</p>
<p>The <strong>map</strong> clause is used on <strong>target</strong>  constructs and the data-type constructs to map host data. It  specifies the device storage and data movement <strong>to</strong> and <strong>from</strong> the device, and controls on the storage duration.</p>
<p>There is an important change in the OpenMP 4.5 specification that alters the data model for scalar variables and C/C++ pointer variables. The default behavior for scalar variables and C/C++ pointer variables in a 4.5 compliant code is <strong>firstprivate</strong>. Example codes that have been updated to reflect this new behavior are annotated with a description that describes changes required for correct execution. Often it is a simple matter of mapping the variable as <strong>tofrom</strong> to obtain the intended 4.0 behavior.</p>
<p>In OpenMP version 4.5 the mechanism for target execution is specified as occurring through a  <em>target task</em> .  When the <strong>target</strong> construct is encountered a new   <em>target task</em>  is generated. The  <em>target task</em>   completes after the <strong>target</strong> region has executed and all data  transfers have finished.</p>
<p>This new specification does not affect the execution of  pre-4.5 code; it is a necessary element for asynchronous  execution of the <strong>target</strong> region when using the new <strong>nowait</strong>  clause introduced in OpenMP 4.5.</p>
<section id="target-construct">
<h2><strong>target</strong> Construct<a class="headerlink" href="#target-construct" title="Permalink to this headline">#</a></h2>
<section id="target-construct-on-parallel-construct">
<h3><strong>target</strong> Construct on <strong>parallel</strong> Construct<a class="headerlink" href="#target-construct-on-parallel-construct" title="Permalink to this headline">#</a></h3>
<p>This following example shows how the <strong>target</strong> construct offloads a code  region to a target device. The variables  <em>p</em> ,  <em>v1</em> ,  <em>v2</em> , and  <em>N</em>  are implicitly mapped  to the target device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target.1
* type: C
* version: omp_4.0
*/
extern void init(float*, float*, int);
extern void output(float*, int);
void vec_mult(int N)
{
   int i;
   float p[N], v1[N], v2[N];
   init(v1, v2, N);
   #pragma omp target
   #pragma omp parallel for private(i)
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target.1
! type: F-free
! version:    omp_4.0
subroutine vec_mult(N)
   integer ::  i,N
   real    ::  p(N), v1(N), v2(N)
   call init(v1, v2, N)
   !$omp target
   !$omp parallel do
   do i=1,N
      p(i) = v1(i) * v2(i)
   end do
   !$omp end target
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-construct-with-map-clause">
<h3><strong>target</strong> Construct with <strong>map</strong> Clause<a class="headerlink" href="#target-construct-with-map-clause" title="Permalink to this headline">#</a></h3>
<p>This following example shows how the <strong>target</strong> construct offloads a code  region to a target device. The variables  <em>p</em> ,  <em>v1</em>  and  <em>v2</em>  are explicitly mapped to the  target device using the <strong>map</strong> clause. The variable  <em>N</em>  is implicitly mapped to  the target device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target.2
* type: C
* version: omp_4.0
*/
extern void init(float*, float*, int);
extern void output(float*, int);
void vec_mult(int N)
{
   int i;
   float p[N], v1[N], v2[N];
   init(v1, v2, N);
   #pragma omp target map(v1, v2, p)
   #pragma omp parallel for
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target.2
! type: F-free
! version:    omp_4.0
subroutine vec_mult(N)
   integer ::  i,N
   real    ::  p(N), v1(N), v2(N)
   call init(v1, v2, N)
   !$omp target map(v1,v2,p)
   !$omp parallel do
   do i=1,N
      p(i) = v1(i) * v2(i)
   end do
   !$omp end target
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="map-clause-with-to-from-map-types">
<h3><strong>map</strong> Clause with <strong>to</strong>/<strong>from</strong> map-types<a class="headerlink" href="#map-clause-with-to-from-map-types" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> construct offloads a code region  to a target device. In the <strong>map</strong> clause, the <strong>to</strong> and <strong>from</strong>  map-types define the mapping between the original (host) data and the target (device)  data. The <strong>to</strong> map-type specifies that the data will only be read on the  device, and the <strong>from</strong> map-type specifies that the data will only be written  to on the device. By specifying a guaranteed access on the device, data transfers  can be reduced for the <strong>target</strong> region.</p>
<p>The <strong>to</strong> map-type indicates that at the start of the <strong>target</strong> region  the variables  <em>v1</em>  and  <em>v2</em>  are initialized with the values of the corresponding variables  on the host device, and at the end of the <strong>target</strong> region the variables   <em>v1</em>  and  <em>v2</em>  are not assigned to their corresponding variables on the host device.</p>
<p>The <strong>from</strong> map-type indicates that at the start of the <strong>target</strong> region  the variable  <em>p</em>  is not initialized with the value of the corresponding variable  on the host device, and at the end of the <strong>target</strong> region the variable  <em>p</em>   is assigned to the corresponding variable on the host device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target.3
* type: C
* version: omp_4.0
*/
extern void init(float*, float*, int);
extern void output(float*, int);
void vec_mult(int N)
{
   int i;
   float p[N], v1[N], v2[N];
   init(v1, v2, N);
   #pragma omp target map(to: v1, v2) map(from: p)
   #pragma omp parallel for
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<p>The <strong>to</strong> and <strong>from</strong> map-types allow programmers to optimize data  motion. Since data for the  <em>v</em>  arrays are not returned, and data for the  <em>p</em>  array  are not transferred to the device, only one-half of the data is moved, compared  to the default behavior of an implicit mapping.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target.3
! type: F-free
! version:    omp_4.0
subroutine vec_mult(N)
   integer ::  i,N
   real    ::  p(N), v1(N), v2(N)
   call init(v1, v2, N)
   !$omp target map(to: v1,v2) map(from: p)
   !$omp parallel do
   do i=1,N
      p(i) = v1(i) * v2(i)
   end do
   !$omp end target
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="map-clause-with-array-sections">
<h3><strong>map</strong> Clause with Array Sections<a class="headerlink" href="#map-clause-with-array-sections" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> construct offloads a code region  to a target device. In the <strong>map</strong> clause, map-types are used to optimize  the mapping of variables to the target device. Because variables  <em>p</em> ,  <em>v1</em>  and  <em>v2</em>  are  pointers, array section notation must be used to map the arrays. The notation <strong>:N</strong>  is equivalent to <strong>0:N</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target.4
* type: C
* version: omp_4.0
*/
extern void init(float*, float*, int);
extern void output(float*, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target map(to: v1[0:N], v2[:N]) map(from: p[0:N])
   #pragma omp parallel for
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<p>In C, the length of the pointed-to array must be specified. In Fortran the extent  of the array is known and the length need not be specified. A section of the array  can be specified with the usual Fortran syntax, as shown in the following example.  The value 1 is assumed for the lower bound for array section  <em>v2(:N)</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target.4
! type: F-free
! version:    omp_4.0
module mults
contains
subroutine vec_mult(p,v1,v2,N)
   real,pointer,dimension(:) :: p, v1, v2
   integer                   :: N,i
   call init(v1, v2, N)
   !$omp target map(to: v1(1:N), v2(:N)) map(from: p(1:N))
   !$omp parallel do
   do i=1,N
      p(i) = v1(i) * v2(i)
   end do
   !$omp end target
   call output(p, N)
end subroutine
end module
</pre></div>
</div>
</div>
</div>
<p>A more realistic situation in which an assumed-size array is passed to <strong>vec_mult</strong>  requires that the length of the arrays be specified, because the compiler does  not know the size of the storage. A section of the array must be specified with  the usual Fortran syntax, as shown in the following example. The value 1 is assumed  for the lower bound for array section  <em>v2(:N)</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target.4b
! type: F-free
! version:    omp_4.0
module mults
contains
subroutine vec_mult(p,v1,v2,N)
   real,dimension(*) :: p, v1, v2
   integer           :: N,i
   call init(v1, v2, N)
   !$omp target map(to: v1(1:N), v2(:N)) map(from: p(1:N))
   !$omp parallel do
   do i=1,N
      p(i) = v1(i) * v2(i)
   end do
   !$omp end target
   call output(p, N)
end subroutine
end module
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-construct-with-if-clause">
<h3><strong>target</strong> Construct with <strong>if</strong> Clause<a class="headerlink" href="#target-construct-with-if-clause" title="Permalink to this headline">#</a></h3>
<p><strong>target construct <strong>target</strong> construct!if clause <strong>if</strong> clause</strong> <strong>clauses!if <strong>if</strong></strong> <strong>if clause <strong>if</strong> clause</strong></p>
<p>The following example shows how the <strong>target</strong> construct offloads a code region  to a target device.</p>
<p>The <strong>if</strong> clause on the <strong>target</strong> construct indicates that if the variable   <em>N</em>  is smaller than a given threshold, then the <strong>target</strong> region will be executed  by the host device.</p>
<p>The <strong>if</strong> clause on the <strong>parallel</strong> construct indicates that if the  variable  <em>N</em>  is smaller than a second threshold then the <strong>parallel</strong> region  is inactive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target.5
* type: C
* version: omp_4.0
*/
#define THRESHOLD1 1000000
#define THRESHOLD2 1000

extern void init(float*, float*, int);
extern void output(float*, int);

void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;

   init(v1, v2, N);

   #pragma omp target if(N&gt;THRESHOLD1) map(to: v1[0:N], v2[:N])\
 map(from: p[0:N])
   #pragma omp parallel for if(N&gt;THRESHOLD2)
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];

   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target.5
! type: F-free
! version:    omp_4.0
module params
integer,parameter :: THRESHOLD1=1000000, THRESHHOLD2=1000
end module

subroutine vec_mult(p, v1, v2, N)
   use params
   real    ::  p(N), v1(N), v2(N)
   integer ::  i

   call init(v1, v2, N)

   !$omp target if(N&gt;THRESHHOLD1) map(to: v1, v2 ) map(from: p)
      !$omp parallel do if(N&gt;THRESHOLD2)
      do i=1,N
  p(i) = v1(i) * v2(i)
      end do
   !$omp end target

   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
<p>The following example is a modification of the above  <em>target.5</em>  code to show the combined <strong>target</strong> and parallel loop directives. It uses the  <em>directive-name</em>  modifier in multiple <strong>if</strong> clauses to specify the component directive to which it applies.</p>
<p>The <strong>if</strong> clause with the <strong>target</strong> modifier applies to the <strong>target</strong> component of the  combined directive, and the <strong>if</strong> clause with the <strong>parallel</strong> modifier applies  to the <strong>parallel</strong> component of the combined directive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target.6
* type: C
* version: omp_4.5
*/
#define THRESHOLD1 1000000
#define THRESHOLD2 1000

extern void init(float*, float*, int);
extern void output(float*, int);

void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;

   init(v1, v2, N);

   #pragma omp target parallel for \
        if(target: N&gt;THRESHOLD1) if(parallel: N&gt;THRESHOLD2) \
        map(to: v1[0:N], v2[:N]) map(from: p[0:N])
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];

   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target.6
! type: F-free
! version:    omp_4.5
module params
integer,parameter :: THRESHOLD1=1000000, THRESHHOLD2=1000
end module

subroutine vec_mult(p, v1, v2, N)
   use params
   real    ::  p(N), v1(N), v2(N)
   integer ::  i

   call init(v1, v2, N)

   !$omp target parallel do  &amp;
   !$omp&amp;   if(target: N&gt;THRESHHOLD1) if(parallel: N&gt;THRESHOLD2) &amp;
   !$omp&amp;   map(to: v1, v2 ) map(from: p)
      do i=1,N
  p(i) = v1(i) * v2(i)
      end do
   !$omp end target parallel do

   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-reverse-offload">
<h3>Target Reverse Offload<a class="headerlink" href="#target-reverse-offload" title="Permalink to this headline">#</a></h3>
<p>Beginning with OpenMP 5.0, implementations are allowed to offload back to the host (reverse offload).</p>
<p>In the example below the  <em>error_handler</em>  function is executed back on the host, if an erroneous value is detected in the  <em>A</em>  array on the device.</p>
<p>This is accomplished by specifying the  <em>device-modifier</em>  <strong>ancestor</strong> modifier, along with a device number of <strong>1</strong>, to indicate that the execution is to be performed on the immediate parent ( <em>1st ancestor</em> )– the host.</p>
<p>The <strong>requires</strong> directive (another 5.0 feature) uses the <strong>reverse_offload</strong> clause to guarantee that the reverse offload is implemented.</p>
<p>Note that the <strong>declare</strong> <strong>target</strong> directive uses the <strong>device_type</strong> clause (another 5.0 feature) to specify that the  <em>error_handler</em>  function is compiled to execute on the  <em>host</em>  only. This ensures that no attempt will be made to create a device version of the function.  This feature may be necessary if the function exists in another compile unit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_reverse_offload.7
* type: C
* version: omp_5.2
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define N 100

#pragma omp requires reverse_offload

void error_handler(int wrong_value, int index)
{
   printf(&quot; Error in offload: A[%d]=%d\n&quot;, index,wrong_value);
   printf(&quot;        Expecting: A[i ]=i\n&quot;);
   exit(1);
// output:  Error in offload: A[99]=-1
//                 Expecting: A[i ]=i

}
#pragma omp declare target device_type(host) enter(error_handler)

int main()
{
   int A[N];

   for (int i=0; i&lt;N; i++) A[i] = i;

   A[N-1]=-1;

   #pragma omp target map(A)
   {
      for (int i=0; i&lt;N; i++)
      {
         if (A[i] != i)
         {
            #pragma omp target device(ancestor: 1) map(always,to: A[i:1])
               error_handler(A[i], i);
         }
      }
   }
   return 0;
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       target_reverse_offload.7
! type:       F-free
! version:    omp_5.0

!$omp requires reverse_offload

subroutine error_handler(wrong_value, index)
  integer :: wrong_value,index
  !$omp declare target device_type(host)

   write( *,&#39;(&quot;Error in offload: A(&quot;,i3,&quot;)=&quot;,i3)&#39; ) index,wrong_value
   write( *,&#39;(&quot;       Expecting: A(  i)=  i&quot;)&#39;    )
   stop
     !!output: Error in offload: A( 99)= -1
     !!               Expecting: A(  i)=  i
end subroutine

program rev_off
  use omp_lib
  integer, parameter :: N=100
  integer            :: A(N) = (/ (i, i=1,100) /)

   A(N-1)=-1

   !$omp target map(A)
      do i=1,N
         if (A(i) /= i)  then
           !$omp target device(ancestor: 1) map(always,to :A(i))
               call error_handler(A(i), i)
           !$omp end target
         endif
      end do
   !$omp end target

end program
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="defaultmap-clause">
<h2><strong>defaultmap</strong> Clause<a class="headerlink" href="#defaultmap-clause" title="Permalink to this headline">#</a></h2>
<p>The implicitly-determined, data-mapping and data-sharing attribute rules of variables referenced in a <strong>target</strong> construct can be changed by the <strong>defaultmap</strong> clause introduced in OpenMP 5.0. The implicit behavior is specified as <strong>alloc</strong>, <strong>to</strong>, <strong>from</strong>, <strong>tofrom</strong>, <strong>firstprivate</strong>, <strong>none</strong>, <strong>default</strong> or <strong>present</strong>, and is applied to a variable-category, where <strong>scalar</strong>, <strong>aggregate</strong>, <strong>allocatable</strong>, and <strong>pointer</strong> are the variable categories.</p>
<p>In OpenMP, a “category’’ has a common data-mapping and data-sharing  behavior for variable types within the category. In C/C++, <strong>scalar</strong> refers to base-language scalar variables, except pointers. In Fortran it refers to a scalar variable, as defined by the base language,  with intrinsic type, and excludes character type.</p>
<p>Also, <strong>aggregate</strong> refers to arrays and structures (C/C++) and derived types (Fortran). Fortran has the additional category of <strong>allocatable</strong>.</p>
<p>In the example below, the first <strong>target</strong> construct uses  <strong>defaultmap</strong> clauses to set data-mapping and possibly data-sharing attributes that reproduce  the default implicit mapping (data-mapping and data-sharing attributes).  That is,  if the <strong>defaultmap</strong> clauses were removed, the results would be identical.</p>
<p>In the second <strong>target</strong> construct all implicit behavior is removed by specifying the <strong>none</strong> implicit behavior in the <strong>defaultmap</strong> clause. Hence, all variables must be explicitly mapped.   In the C/C++ code a scalar ( <strong>s</strong> ), an array ( <strong>A</strong> ) and a structure  ( <strong>S</strong> ) are explicitly mapped <strong>tofrom</strong>.   The Fortran code uses a derived type ( <strong>D</strong> ) in lieu of structure.</p>
<p>The third <strong>target</strong> construct shows another usual case for using the <strong>defaultmap</strong> clause. The default mapping for (non-pointer) scalar variables is specified as <strong>tofrom</strong>. Here, the default implicit mapping for  <strong>s3</strong>  is <strong>tofrom</strong> as specified  in the <strong>defaultmap</strong> clause, and  <strong>s1</strong>  and  <strong>s2</strong>  are explicitly  mapped with the <strong>firstprivate</strong> data-sharing attribute.</p>
<p>In the fourth <strong>target</strong> construct all arrays, structures (C/C++) and derived  types (Fortran) are mapped with <strong>firstprivate</strong> data-sharing behavior by a  <strong>defaultmap</strong> clause with an <strong>aggregate</strong> variable category. For the  <strong>H</strong>  allocated array in the Fortran code, the <strong>allocable</strong>  category must be used in a separate <strong>defaultmap</strong> clause to acquire  <strong>firsprivate</strong> data-sharing behavior ( <strong>H</strong>  has the Fortran allocatable attribute).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_defaultmap.1
* type:       C
* version: omp_5.0
*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#define N 2

int main(){
  typedef struct S_struct { int s; int A[N]; } S_struct_t;


  int         s;       //scalar int variable (scalar)
  int         A[N];    //aggregate variable  (array)
  S_struct_t  S;       //aggregate variable  (structure)
  int         *ptr;    //scalar, pointer variable (pointer)

  int         s1, s2, s3;

// Initialize everything to zero;
   s=2; s1=s2=s3=0;
   A[0]=0; A[1]=0;
   S.s=0; S.A[0]=0; S.A[1]=0;

// Target Region 1
                   // Uses defaultmap to set scalars, aggregates &amp;
                   // pointers to normal defaults.
    #pragma omp target \
            defaultmap(firstprivate: scalar)   //could also be default \
            defaultmap(tofrom:       aggregate)//could also be default \
            defaultmap(default:      pointer)  //must be default       \
            map(ptr2m[:N])
    {
        s       = 3;            //SCALAR firstprivate, value not returned

        A[0]    = 3;  A[1] = 3; //AGGREGATE array, default map tofrom

                                //AGGREGATE structure, default tofrom
        S.s     = 2;
        S.A[0]  = 2;  S.A[1] = 2;

        ptr = &amp;A[0];            //POINTER is private
        ptr[0] = 2;   ptr[1] = 2;

    }
   if(s==2 &amp;&amp; A[0]==2 &amp;&amp; S.s==2 &amp;&amp; S.A[0]==2)
      printf(&quot; PASSED 1 of 4\n&quot;);


// Target Region 2
                   // no implicit mapping allowed.
    #pragma omp target defaultmap(none) map(tofrom: s, A, S)
    {
        s     +=5;           // All variables must be explicitly mapped
        A[0]  +=5; A[1]+=5;
        S.s   +=5;
        S.A[0]+=5; S.A[1]+=5;
    }
    if(s==7 &amp;&amp; A[0]==7 &amp;&amp; S.s==7 &amp;&amp; S.A[0]==7)
        printf(&quot; PASSED 2 of 4\n&quot;);


// Target Region 3
            // defaultmap &amp; explicit map with variables in same category
    s1=s2=s3=1;
    #pragma  omp defaultmap(tofrom: scalar) map(firstprivate: s1,s2)
    {
        s1 += 5;         // firstprivate (s1 value not returned to host)
        s2 += 5;         // firstprivate (s2 value not returned to host)
        s3 += s1 + s2;   // mapped as tofrom
    }
    if(s1==1 &amp;&amp; s2==1 &amp;&amp; s3==13 ) printf(&quot; PASSED 3 of 4\n&quot;);


// Target Region 4
    A[0]=0; A[1]=0;
    S.A[0]=0; S.A[1]=0;

    // arrays and structure are firstprivate, and scalars are from
    #pragma omp target defaultmap(firstprivate: aggregate) \
                       map(from: s1, s2)
    {

        A[0]+=1; S.A[0]+=1; //Aggregate changes not returned to host
        A[1]+=1; S.A[1]+=1; //Aggregate changes not returned to host
        s1 = A[0]+S.A[0]; //s1 value returned to host
        s2 = A[1]+S.A[1]; //s1 value returned to host
    }
    if( A[0]==0 &amp;&amp; S.A[0]==0 &amp;&amp; s1==2 ) printf(&quot; PASSED 4 of 4\n&quot;);

}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       target_defaultmap.1
! type:       F-free
! version:    omp_5.0
program defaultmap
  integer, parameter :: N=2

  type DDT_sA
    integer  :: s
    integer  :: A(N)
  end type

  integer             :: s,s1,s2,s3 !! SCALAR: variable (integer)

  integer,target      :: A(N)       !! AGGREGATE: Array
  type(DDT_sA)        :: D          !! AGGREGATE: Derived Data Type (D)

  integer,allocatable :: H(:)       !! ALLOCATABLE: Heap allocated array

  integer,pointer     :: ptrA(:)    !! POINTER: points to Array

  ! Assign vaues to scalar, Array, Allocatable, and Pointers

    s=2;
    s1=0;   s2=0;     s3=0
    D%s=0;  D%A(1)=0; D%A(2)=0
    A(1)=0; A(2)=0

    allocate( H(2) )
    H(1)=0; H(2)=0

!! Target Region 1
                   !! Using defaultmap to set scalars, aggregates &amp;
                   !! pointers and allocatables to normal defaults.
    !$omp target                                        &amp;
    !$omp&amp;       defaultmap( firstprivate: scalar)      &amp;
    !$omp&amp;       defaultmap( tofrom:       aggregate)   &amp;
    !$omp&amp;       defaultmap( tofrom:       allocatable) &amp;
    !$omp&amp;       defaultmap( default:      pointer)

        s = 3                     !! SCALAR firstprivate, val not returned

        A(1) = 3                  !! AGGREGATE array, default map tofrom
        A(2) = 3

        D%s = 2                   !! AGGR. Derived Type, default map tofrom
        D%A(1) = 2;  D%A(2) = 2

        H(1) = 2;    H(2) = 2     !! ALLOCATABLE, default map tofrom

        ptrA=&gt;A                   !! POINTER is private
        ptrA(1) = 2; ptrA(2) = 2

    !$omp end target

    if(s==2 .and. A(1)==2 .and. D%s==2 .and. D%A(1)==2 .and. H(1) == 2) &amp;
       print*,&quot; PASSED 1 of 4&quot;

!! Target Region 2
                   !! no implicit mapping allowed
    !$omp target defaultmap(none) map(tofrom: s, A, D)

        s=s+5                 !! All variables must be explicitly mapped
        A(1)=A(1)+5;       A(2)=A(2)+5
        D%s=D%s+5
        D%A(1)=D%A(1)+5; D%A(2)=D%A(2)+5

    !$omp end target
    if(s==7 .and. A(1)==7 .and. D%s==7 .and. D%A(1)==7) &amp;
        print*,&quot; PASSED 2 of 4&quot;

!! Target Region 3
                !!defaultmap &amp; explicit map with variables in same category
    s1=1; s2=1; s3=1
    !$omp defaultmap(tofrom: scalar) map(firstprivate: s1,s2)

        s1 = s1+5;          !! firstprivate (s1 value not returned to host)
        s2 = s2+5;          !! firstprivate (s2 value not returned to host)
        s3 = s3 +s1 + s2;   !! mapped as tofrom

    !$omp end target
    if(s1==1 .and. s2==1 .and. s3==13) print*,&quot; PASSED 3 of 4&quot;

!! Target Region 4
    A(1)=0;   A(2)=0
    D%A(1)=0; D%A(2)=0
    H(1)=0;   H(2)=0
              !! non-allocated arrays &amp; derived types are in AGGREGATE cat.
              !! Allocatable Arrays are in ALLOCATABLE category
              !! Scalars are explicitly mapped from
    !$omp target defaultmap(firstprivate: aggregate )  &amp;
    !$omp&amp;       defaultmap(firstprivate: allocatable) &amp;
    !$omp&amp;       map(from: s1, s2)

        A(1)=A(1)+1; D%A(1)=D%A(1)+1; H(1)=H(1)+1 !! changes to A, D%A, H
        A(2)=A(2)+1; D%A(2)=D%A(2)+1; H(2)=H(2)+1 !!   not returned to host
        s1 = A(1)+D%A(1)+H(1)                     !! s1 returned to host
        s2 = A(2)+D%A(2)+H(1)                     !! s2 returned to host

    !$omp end target
    if(A(1)==0 .and. D%A(1)==0 .and. H(1)==0 .and. s1==3) &amp;
       print*,&quot; PASSED 4 of 4&quot;

    deallocate(H)

end program

</pre></div>
</div>
</div>
</div>
</section>
<section id="pointer-mapping">
<h2>Pointer Mapping<a class="headerlink" href="#pointer-mapping" title="Permalink to this headline">#</a></h2>
<p>Pointers that contain host addresses require that those addresses are translated to device addresses for them to be useful in the context of a device data environment. Broadly speaking, there are two scenarios where this is important.</p>
<p>The first scenario is where the pointer is mapped to the device data environment, such that references to the pointer inside a <strong>target</strong> region are to the corresponding pointer. Pointer attachment ensures that the corresponding pointer will contain a device address when all of the following conditions are true:</p>
<ul class="simple">
<li><p>the pointer is mapped by directive  A  to a device;</p></li>
<li><p>a list item that uses the pointer as its base pointer (call it the <em>pointee</em>) is mapped, to the same device, by directive  B , which may be the same as  A ;</p></li>
<li><p>the effect of directive  B  is to create either the corresponding pointer or pointee in the device data environment of the device.</p></li>
</ul>
<p>Given the above conditions, pointer attachment is initiated as a result of directive  B  and subsequent references to the pointee list item in a target region that use the pointer will access the corresponding pointee. The corresponding pointer remains in this <em>attached</em> state until it is removed from the device data environment.</p>
<p>The second scenario, which is only applicable for C/C++, is where the pointer is implicitly privatized inside a <strong>target</strong> construct when it appears as the base pointer to a list item on the construct and does not appear explicitly as a list item in a <strong>map</strong> clause, <strong>is_device_ptr</strong> clause, or data-sharing attribute clause. This scenario can be further split into two cases: the list item is a zero-length array section (e.g.,  <em>p[:0]</em> ) or it is not.</p>
<p>If it is a zero-length array section, this will trigger a runtime check on entry to the <strong>target</strong> region for a previously mapped list item where the value of the pointer falls within the range of its base address and ending address. If such a match is found the private pointer is initialized to the device address corresponding to the value of the original pointer, and otherwise it is initialized to NULL (or retains its original value if the <strong>unified_address</strong> requirement is specified for that compilation unit).</p>
<p>If the list item (again, call it the <em>pointee</em>) is not a zero-length array section, the private pointer will be initialized such that references in the <strong>target</strong> region to the pointee list item that use the pointer will access the corresponding pointee.</p>
<p>The following example shows the basics of mapping pointers with and without associated storage on the host.</p>
<p>Storage for pointers  <em>ptr1</em>  and  <em>ptr2</em>  is created on the host.  To map storage that is associated with a pointer on the host, the data can be explicitly mapped as an array section so that the compiler knows  the amount of data to be assigned in the device (to the “corresponding” data storage area). On the <strong>target</strong> construct array sections are mapped; however, the pointer  <em>ptr1</em>  is mapped, while  <em>ptr2</em>  is not. Since  <em>ptr2</em>  is not explicitly mapped, it is firstprivate.  This creates a subtle difference in the way these pointers can be used.</p>
<p>As a firstprivate pointer,  <em>ptr2</em>  can be manipulated on the device; however, as an explicitly mapped pointer,   <em>ptr1</em>  becomes an <em>attached</em> pointer and cannot be manipulated. In both cases the host pointer is not updated with the device pointer  address—as one would expect for distributed memory.  The storage data on the host is updated from the corresponding device data at the end of the <strong>target</strong> region.</p>
<p>As a comparison, note that the  <em>aray</em>  array is automatically mapped,  since the compiler knows the extent of the array.</p>
<p>The pointer  <em>ptr3</em>  is used inside the <strong>target</strong> construct, but it does not appear in a data-mapping or data-sharing clause. Nor is there a <strong>defaultmap</strong> clause on the construct to indicate what its implicit data-mapping or data-sharing attribute should be. For such a case,  <em>ptr3</em>  will be implicitly privatized within the construct and there will be a runtime check to see if the host memory to which it is pointing has corresponding memory in the device data environment. If this runtime check passes, the private  <em>ptr3</em>  would be initialized to point to the corresponding memory. But in this case the check does not pass and so it is initialized to null. Since  <em>ptr3</em>  is private, the value to which it is assigned in the <strong>target</strong> region is not returned into the original  <em>ptr3</em>  on the host.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_ptr_map.1
* type:       C
* version: omp_5.0
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 100

int main()
{
  int *ptr1;
  int *ptr2;
  int *ptr3;
  int aray[N];

  ptr1 = (int *)malloc(sizeof(int)*N);
  ptr2 = (int *)malloc(sizeof(int)*N);

  #pragma omp target map(ptr1, ptr1[:N]) map(ptr2[:N] )
  {
     for (int i=0; i&lt;N; i++)
     {
         ptr1[i] = i;
         ptr2[i] = i;
         aray[i] = i;
     }

   //*(++ptr1) = 9;  //NOT ALLOWED since ptr1 is an attached pointer
     *(++ptr2) = 9;  //    allowed since ptr2 is firstprivate

     ptr3=(int *)malloc(sizeof(int)*N); // ptr3 is firstprivate
                                        // ptr3 value not returned
     for (int i=0; i&lt;N; i++) ptr3[i] = 5;

     for (int i=0; i&lt;N; i++) ptr1[i] += ptr3[i];

     free(ptr3);     // explicitly free allocated storage on device
   }

   printf(&quot; %d %d\n&quot;,ptr1[1],ptr2[1]);
   //        6  9

   free(ptr1);
   free(ptr2);
   return 0;
}
</pre></div>
</div>
</div>
</div>
<p>In the following example the global pointer  <em>p</em>  appears in a declare target directive.  Hence, the pointer  <em>p</em>  will  persist on the device throughout executions in all <strong>target</strong> regions.</p>
<p>The pointer is also used in an array section of a <strong>map</strong> clause on  a <strong>target</strong> construct.  When the pointer of storage associated with  a declare target directive is mapped, as for the array section  <em>p[:N]</em>  in the <strong>target</strong> construct, the array section on the device is <em>attached</em> to the device pointer  <em>p</em>  on entry to the construct, and the value of the device pointer  <em>p</em>  becomes undefined on exit.  (Of course, storage allocation for the array section on the device will occur before the  pointer on the device is <em>attached</em>.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_ptr_map.2
* type:       C
* version: omp_5.1
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 100

#pragma omp begin declare target
  int *p;
  extern void use_arg_p(int *p, int n);
  extern void use_global_p(     int n);
#pragma omp end declare target

int main()
{
  int i;
  p = (int *)malloc(sizeof(int)*N);

  #pragma omp target map(p[:N])  // device p attached to array section
  {
    for (i=0; i&lt;N; i++) p[i] = i;
    use_arg_p(p, N);
    use_global_p(N);
  }                              // value of host p is preserved

  printf(&quot; %3.3d %3.3d\n&quot;, p[1], p[N-1]);
         // 003   297   &lt;- output

  free(p);
  return 0;
}

// A #pragma omp begin declare target is optional here
// because of prototype spec
void use_arg_p(int *q, int n)
{
  int i;
  for (i=0; i&lt;n; i++)
    q[i] *= 2;
}

void use_global_p(int n)
{
  int i;
  for (i=0; i&lt;n; i++)
    p[i] += i;   // valid since p is in declare target and called from
                 // inside target region where p was attached to
                 // valid memory
}
// A #pragma omp end declare target is optional here
// because of prototype spec
</pre></div>
</div>
</div>
</div>
<p>The following two examples illustrate subtle differences in pointer attachment to device address because of the order of data mapping.</p>
<p>In example  <em>target_ptr_map.3a</em>   the global pointer  <em>p1</em>  points to array  <em>x</em>  and  <em>p2</em>  points to array  <em>y</em>  on the host. The array section  <em>x[:N]</em>  is mapped by the <strong>target</strong> <strong>enter</strong> <strong>data</strong> directive while array  <em>y</em>  is mapped on the <strong>target</strong> construct.  Since the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> directive is applied to the declaration of  <em>p1</em> ,  <em>p1</em>  is a treated like a mapped variable on the <strong>target</strong> construct and references to  <em>p1</em>  inside the construct will be to the corresponding  <em>p1</em>  that exists on the device.  However, the corresponding  <em>p1</em>  will be undefined since there is no pointer attachment for it. Pointer attachment for  <em>p1</em>  would require that (1)  <em>p1</em>  (or an lvalue expression that refers to the same storage as  <em>p1</em> ) appears as a base pointer to a list item in a <strong>map</strong> clause, and (2) the construct that has the <strong>map</strong> clause causes the list item to transition from <strong>not mapped</strong> to <strong>mapped</strong>. The conditions are clearly not satisfied for this example.</p>
<p>The problem for  <em>p2</em>  in this example is also subtle. It will be privatized inside the <strong>target</strong> construct, with a runtime check for whether the memory to which it is pointing has corresponding memory that is accessible on the device. If this check is successful, then the  <em>p2</em>  inside the construct would be appropriately initialized to point to that corresponding memory. Unfortunately, despite there being an implicit map of the array  <em>y</em>  (to which  <em>p2</em>  is pointing) on the construct, the order of this map relative to the initialization of  <em>p2</em>  is unspecified. Therefore, the initial value of  <em>p2</em>  will also be undefined.</p>
<p>Thus, referencing values via either  <em>p1</em>  or  <em>p2</em>  inside the <strong>target</strong> region would be invalid.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_ptr_map.3a
* type:       C
* version: omp_5.1
*/
#define N 100

int x[N], y[N];
#pragma omp begin declare target
int *p1;
#pragma omp end declare target
int *p2;

int foo()
{
  p1 = &amp;x[0];
  p2 = &amp;y[0];

  // Explicitly map array section x[:N]
  #pragma omp target enter data map(x[:N])

  #pragma omp target  // as if .. map(p1) map(p1[:0]) map(p2[:0]) map(y)
  {
    // Accessing the mapped arrays x,y is OK here.
    x[0] = 1;
    y[1] = 2;

    // Pointer attachment for p1 does not occur here
    //   because p1[:0] does not allocate a new array section and
    //   array x is present on the target construct as it was mapped
    //   before by the target enter data directive.
    p1[0] = 3;      // accessing p1 is undefined

    // The initial value of p2 in the target region is undefined
    //   because map(y) may occur after map(p2[:0]).
    p2[1] = 4;      // accessing p2 is undefined
  }

  return 0;
}
</pre></div>
</div>
</div>
</div>
<p>In example  <em>target_ptr_map.3b</em>  the mapping orders for arrays  <em>x</em>  and  <em>y</em>  were rearranged to allow proper pointer attachments. On the <strong>target</strong> construct, the <strong>map(x)</strong> clause triggers pointer attachment for  <em>p1</em>  to the device address of  <em>x</em> .  Pointer  <em>p2</em>  is assigned the device address of the previously mapped  array  <em>y</em> . Referencing values via either  <em>p1</em>  or  <em>p2</em>  inside the <strong>target</strong> region is now valid.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_ptr_map.3b
* type:       C
* version: omp_5.1
*/
#define N 100

int x[N], y[N];
#pragma omp begin declare target
int *p1;
#pragma omp end declare target
int *p2;

int foo()
{
  p1 = &amp;x[0];
  p2 = &amp;y[0];

  // Explicitly map array section y[:N]
  #pragma omp target enter data map(y[:N])

  #pragma omp target map(x[:N]) map(p1[:N]) map(p2[:0])
  {
    // Accessing the mapped arrays x,y is OK here.
    x[0] = 1;
    y[1] = 2;

    // Pointer attachment for p1 occurs here when array x is mapped
    //   on the target construct (as p1 = &amp;x[0] on the device)
    p1[0] = 3;      // accessing p1 is OK

    // p2 in the target region is initialized to &amp;y[0]
    p2[1] = 4;      // accessing p2 is OK
  }

  return 0;
}
</pre></div>
</div>
</div>
</div>
<p>In the following example, storage allocated on the host is not mapped in a <strong>target</strong> region if it is determined that the host memory is accessible from the device. On platforms that support host memory access from a target device,  it may be more efficient to omit map clauses and avoid the potential memory allocation  and data transfers that may result from the map. The <strong>omp_target_is_accessible</strong> API routine is used to determine if the  host storage of size  <em>buf_size</em>  is accessible on the device, and a metadirective is used to select the directive variant (a <strong>target</strong> with/without a <strong>map</strong> clause).</p>
<p>The <strong>omp_target_is_accessible</strong> routine will return true if the storage indicated  by the first and second arguments is accessible on the target device. In this case,  the host pointer  <em>ptr</em>  may be directly dereferenced in the subsequent  <strong>target</strong> region to access this storage, rather than mapping an array section based  off the pointer. By explicitly specifying the host pointer in a <strong>firstprivate</strong>  clause on the construct, its original value will be used directly in the <strong>target</strong> region.  In OpenMP 5.1, removing the <strong>firstprivate</strong> clause will result in an implicit presence  check of the storage to which  <em>ptr</em>  points, and since this storage is not mapped by the  program,  <em>ptr</em>  will be NULL-initialized in the <strong>target</strong> region.  In the next version of the OpenMP Specification, a false presence check without  the <strong>firstprivate</strong> clause will cause the pointer to retain its original value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_ptr_map.4
* type:       C
* version: omp_5.2
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;omp.h&gt;

void do_work(int *ptr, const int size);

int main()
{
   const int n = 1000;
   const int buf_size = sizeof(int) * n;
   const int dev = omp_get_default_device();

   int *ptr = (int *) malloc(buf_size); // possibly compiled on
                                        // Unified Shared Memory system
   const int accessible = omp_target_is_accessible(ptr, buf_size, dev);

   #pragma omp metadirective \
      when(user={condition(accessible)}: target firstprivate(ptr) ) \
      otherwise(                         target map(ptr[:n])      )
   {
      do_work(ptr, n);
   }

   free(ptr);
   return 0;
}

</pre></div>
</div>
</div>
</div>
<p>Similar to the previous example, the <strong>omp_target_is_accessible</strong> routine is used to discover if a deep copy is required for the platform.  Here, the  <em>deep_copy</em>  map, defined in the <strong>declare</strong> <strong>mapper</strong> directive, is used if the host storage referenced by   <em>s.ptr</em>  (or  <em>sptr</em>  in Fortran) is not accessible from the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_ptr_map.5
* type:       C
* version: omp_5.2
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;omp.h&gt;

typedef struct {
   int *ptr;
   int buf_size;
} T;

#pragma omp declare mapper(deep_copy: T s) map(s, s.ptr[:s.buf_size])

void do_work(int *ptr, const int size);

int main()
{
   const int n = 1000;
   const int buf_size = sizeof(int) * n;
   T s = { 0, buf_size };
   const int dev = omp_get_default_device();
   s.ptr = (int *)malloc(buf_size);
   const int accessible =
      omp_target_is_accessible(s.ptr, s.buf_size, dev);

   #pragma omp metadirective \
      when(user={condition(accessible)}: target) \
      otherwise(target map(mapper(deep_copy),tofrom:s) )
   {
      do_work(s.ptr, n);
   }

   free(s.ptr);
   return 0;
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       target_ptr_map.5
! type:       F-free
! version:    omp_5.2
program main
   use omp_lib

   use, intrinsic :: iso_c_binding, only : c_loc, c_size_t, c_sizeof, c_int
   implicit none
   external :: do_work

   type T
     integer,pointer :: ptr(:)
     integer         :: buf_size
   end type

   !$omp declare mapper(deep_copy: T :: s) map(s, s%ptr(:s%buf_size))

   integer,parameter :: n = 1000
   integer(c_int)    :: dev, accessible
   integer(c_size_t) :: buf_size

   type(T) s

   allocate(s%ptr(n))

   buf_size = c_sizeof(s%ptr(1))*n
   dev = omp_get_default_device()

   accessible = omp_target_is_accessible(c_loc(s%ptr(1)), buf_size, dev)

   !$omp  begin metadirective                              &amp;
   !$omp&amp;       when(user={condition(accessible)}: target) &amp;
   !$omp&amp;       otherwise( target map(mapper(deep_copy),tofrom:s) )

      call do_work(s, n)

   !$omp  end   metadirective

   deallocate(s%ptr)

end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="structure-mapping">
<h2>Structure Mapping<a class="headerlink" href="#structure-mapping" title="Permalink to this headline">#</a></h2>
<p>In the example below, only structure elements  <em>S.a</em> ,  <em>S.b</em>  and  <em>S.p</em>   of the  <em>S</em>  structure appear in <strong>map</strong> clauses of a <strong>target</strong> construct. Only these components have corresponding variables and storage on the device.   Hence, the large arrays,  <em>S.buffera</em>  and  <em>S.bufferb</em> , and the  <em>S.x</em>  component have no storage  on the device and cannot be accessed.</p>
<p>Also, since the pointer member  <em>S.p</em>  is used in an array section of a  <strong>map</strong> clause, the array storage of the array section on the device,   <em>S.p[:N]</em> , is <em>attached</em> to the pointer member  <em>S.p</em>  on the device. Explicitly mapping the pointer member  <em>S.p</em>  is optional in this case.</p>
<p>Note: The buffer arrays and the  <em>x</em>  variable have been grouped together, so that the components that will reside on the device are all together (without gaps). This allows the runtime to optimize the transfer and the storage footprint on the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_struct_map.1
* type:       C
* version: omp_5.1
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 100
#define BAZILLION 2000000

struct foo {
  char buffera[BAZILLION];
  char bufferb[BAZILLION];
  float x;
  float a, b;
  float *p;
};

#pragma omp begin declare target
void saxpyfun(struct foo *S)
{
  int i;
  for(i=0; i&lt;N; i++)
    S-&gt;p[i] = S-&gt;p[i]*S-&gt;a + S-&gt;b;
}
#pragma omp end declare target

int main()
{
  struct foo S;
  int i;

  S.a = 2.0;
  S.b = 4.0;
  S.p = (float *)malloc(sizeof(float)*N);
  for(i=0; i&lt;N; i++) S.p[i] = i;

  #pragma omp target map(alloc:S.p) map(S.p[:N]) map(to:S.a, S.b)
  saxpyfun(&amp;S);

  printf(&quot; %4.0f %4.0f\n&quot;, S.p[0], S.p[N-1]);
        //     4  202  &lt;- output

  free(S.p);
  return 0;
}
</pre></div>
</div>
</div>
</div>
<p>The following example is a slight modification of the above example for  a C++ class.  In the member function  <em>SAXPY::driver</em>   the array section  <em>p[:N]</em>  is <em>attached</em> to the pointer member  <em>p</em>  on the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_struct_map.2
* type:       C++
* version: omp_5.1
*/
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#define N 100

class SAXPY {
  private:
   float a, b, *p;
  public:
   float buffer[N];

   SAXPY(float arg_a, float arg_b){ a=arg_a; b=arg_b; }
   void driver();
   void saxpyfun(float *p);
};

#pragma omp begin declare target
void SAXPY::saxpyfun(float *q)
{
  for(int i=0; i&lt;N; i++)
    buffer[i] = q[i]*a + b;
}
#pragma omp end declare target

void SAXPY::driver()
{
  p = (float *) malloc(N*sizeof(float));
  for(int i=0; i&lt;N; i++) p[i]=i;

  #pragma omp target map(alloc:p) map(to:p[:N]) map(to:a,b) \
              map(from:buffer[:N])   // attach(p) to device_malloc()
  {
    saxpyfun(p);
  }

  free(p);
}

int main()
{
  SAXPY my_saxpy(2.0,4.0);

  my_saxpy.driver();

  printf(&quot; %4.0f %4.0f\n&quot;, my_saxpy.buffer[0], my_saxpy.buffer[N-1]);
         //   4   202     &lt;- output

  return 0;
}
</pre></div>
</div>
</div>
</div>
<p>The next example shows two ways in which the structure may be <em>incorrectly</em> mapped.</p>
<p>In Case 1, the array section  <em>S1.p[:N]</em>  is first mapped in an enclosing <strong>target</strong> <strong>data</strong> construct, and the <strong>target</strong> construct then implicitly maps the structure  <em>S1</em> . The initial map of the array section does not map the base pointer  <em>S1.p</em>  – it only maps the elements of the array section.  Furthermore, the implicit map is not sufficient to ensure pointer attachment for the structure member  <em>S1.p</em>  (refer to the conditions for pointer attachment described in Section 6.3). Consequentially, the dereference operation  <em>S1.p[i]</em>  in the call to  <em>saxpyfun</em>  will probably fail because  <em>S1.p</em>  contains a host address.</p>
<p>In Case 2, again an array section is mapped on an enclosing <strong>target</strong> <strong>data</strong> construct. This time, the nested <strong>target</strong> construct explicitly maps  <em>S2.p</em> ,  <em>S2.a</em> , and  <em>S2.b</em> . But as in Case 1, this does not satisfy the conditions for pointer attachment since the construct must map a list item for which  <em>S2.p</em>  is a base pointer, and it must do so when the  <em>S2.p</em>  is already present on the device or will be created on the device as a result of the same construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_struct_map.3
* type:       C
* version: omp_5.1
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 100
#define BAZILLION 2000000

struct foo {
  char buffera[BAZILLION];
  char bufferb[BAZILLION];
  float x;
  float a, b;
  float *p;
};

#pragma omp begin declare target
void saxpyfun(struct foo *S)
{
  int i;
  for(i=0; i&lt;N; i++)
    S-&gt;p[i] = S-&gt;p[i] * S-&gt;a + S-&gt;b; // S-&gt;p[i] invalid
}
#pragma omp end declare target

int main()
{
  struct foo S1, S2;
  int i;

  // Case 1

  S1.a = 2.0;
  S1.b = 4.0;
  S1.p = (float *)malloc(sizeof(float)*N);
  for(i=0; i&lt;N; i++) S1.p[i] = i;

  // No pointer attachment for S1.p here
  #pragma omp target data map(S1.p[:N])
  #pragma omp target // implicit map of S1
  saxpyfun(&amp;S1);

  // Case 2

  S2.a = 2.0;
  S2.b = 4.0;
  S2.p = (float *)malloc(sizeof(float)*N);
  for(i=0; i&lt;N; i++) S2.p[i] = i;

  // No pointer attachment for S2.p here either
  #pragma omp target data map(S2.p[:N])
  #pragma omp target map(S2.p, S2.a, S2.b) // implicit map of S2
  saxpyfun(&amp;S2);

  // These print statement may not execute because the
  // above code is invalid
  printf(&quot; %4.0f %4.0f\n&quot;, S1.p[0], S1.p[N-1]);
  printf(&quot; %4.0f %4.0f\n&quot;, S2.p[0], S2.p[N-1]);

  free(S1.p);
  free(S2.p);
  return 0;
}
</pre></div>
</div>
</div>
</div>
<p>The following example correctly implements pointer attachment cases that involve implicit structure maps.</p>
<p>In Case 1, members  <em>p</em> ,  <em>a</em> , and  <em>b</em>  of the structure  <em>S1</em>  are explicitly mapped by the <strong>target</strong> <strong>data</strong> construct, to avoid mapping parts of  <em>S1</em>  that aren’t required on the device. The mapped  <em>S1.p</em>  is attached to the array section  <em>S1.p[:N]</em> , and remains attached while it exists on the device (for the duration of <strong>target</strong> <strong>data</strong> region).  Due to the  <em>S1</em>  reference inside the nested <strong>target</strong> construct, the construct implicitly maps  <em>S1</em>  so that the reference refers to the corresponding storage created by the enclosing <strong>target</strong> <strong>data</strong> region. Note that only the members  <em>a</em> ,  <em>b</em> , and  <em>p</em>  may be accessed from this storage.</p>
<p>In Case 2, only the storage for the array section  <em>S2.p[:N]</em>  is mapped by the <strong>target</strong> <strong>data</strong> construct.  The nested <strong>target</strong> construct explicitly maps  <em>S2.a</em>  and  <em>S2.b</em>  and explicitly maps an array section for which  <em>S2.p</em>  is a base pointer. This satisfies the conditions for  <em>S2.p</em>  becoming an attached pointer. The array section in this case is zero-length, but the effect would be the same if the length was a positive integer less than or equal to  <em>N</em> . There is also an implicit map of the containing structure  <em>S2</em> , again due to the reference to  <em>S2</em>  inside the construct. The effect of this implicit map permits access only to members  <em>a</em> ,  <em>b</em> , and  <em>p</em> , as for Case 1.</p>
<p>In Case 3, there is no <strong>target</strong> <strong>data</strong> construct. The <strong>target</strong> construct explicitly maps  <em>S3.a</em>  and  <em>S3.b</em>  and explicitly maps an array section for which  <em>S3.p</em>  is a base pointer. Again, there is an implicit map of the structure referenced in the construct,  <em>S3</em> . This implicit map also causes  <em>S3.p</em>  to be implicitly mapped, because no other part of  <em>S3</em>  is present prior to the construct being encountered. The result is an attached pointer  <em>S3.p</em>  on the device. As for Cases 1 and 2, this implicit map only ensures that storage for the members  <em>a</em> ,  <em>b</em> , and  <em>p</em>  are accessible within the corresponding  <em>S3</em>  that is created on the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       target_struct_map.4
* type:       C
* version: omp_5.1
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 100
#define BAZILLION 2000000

struct foo {
  char buffera[BAZILLION];
  char bufferb[BAZILLION];
  float x;
  float a, b;
  float *p;
};

#pragma omp begin declare target
void saxpyfun(struct foo *S)
{
  int i;
  for(i=0; i&lt;N; i++)
    S-&gt;p[i] = S-&gt;p[i]*S-&gt;a + S-&gt;b;
}
#pragma omp end declare target

int main()
{
  struct foo S1, S2, S3;
  int i;

  // Case 1

  S1.a = 2.0;
  S1.b = 4.0;
  S1.p = (float *)malloc(sizeof(float)*N);
  for(i=0; i&lt;N; i++) S1.p[i] = i;

  // The target data construct results in pointer attachment for S1.p.
  // Explicitly mapping S1.p, S1.a, and S1.b rather than S1 avoids
  // mapping the entire structure (including members buffera, bufferb,
  // and x).
  #pragma omp target data map(S1.p[:N],S1.p,S1.a,S1.b)
  #pragma omp target //implicit map of S1
  saxpyfun(&amp;S1);


  // Case 2

  S2.a = 2.0;
  S2.b = 4.0;
  S2.p = (float *)malloc(sizeof(float)*N);
  for(i=0; i&lt;N; i++) S2.p[i] = i;

  // The target construct results in pointer attachment for S2.p.
  #pragma omp target data map(S2.p[:N])
  #pragma omp target map(S2.p[:0], S2.a, S2.b) // implicit map of S2
  saxpyfun(&amp;S2);

  // Case 3

  S3.a = 2.0;
  S3.b = 4.0;
  S3.p = (float *)malloc(sizeof(float)*N);
  for(i=0; i&lt;N; i++) S3.p[i] = i;

  // The target construct results in pointer attachment for S3.p.
  // Note that S3.p is implicitly mapped due to the implicit map of S3
  // (but corresponding storage is NOT created for members buffera,
  // bufferb, and x).
  #pragma omp target map(S3.p[:N], S3.a, S3.b)  // implicit map of S3
  saxpyfun(&amp;S3);

  printf(&quot; %4.0f %4.0f\n&quot;, S1.p[0], S1.p[N-1]);  //OUT1 4 202
  printf(&quot; %4.0f %4.0f\n&quot;, S2.p[0], S2.p[N-1]);  //OUT2 4 202
  printf(&quot; %4.0f %4.0f\n&quot;, S3.p[0], S3.p[N-1]);  //OUT3 4 202

  free(S1.p);
  free(S2.p);
  free(S3.p);
  return 0;
}
</pre></div>
</div>
</div>
</div>
</section>
<section id="fortran-allocatable-array-mapping">
<h2>Fortran Allocatable Array Mapping<a class="headerlink" href="#fortran-allocatable-array-mapping" title="Permalink to this headline">#</a></h2>
<p>The following examples illustrate the use of Fortran allocatable arrays in <strong>target</strong> regions.</p>
<p>In the first example,  allocatable variables (<em>a</em> and <em>b</em>) are first allocated
on the host, and then mapped onto a device in the Target 1 and 2 sections, respectively.
For <em>a</em> the map is implicit and for <em>b</em> an explicit map is used.
Both are mapped with the default <strong>tofrom</strong> map type.
The user-level behavior is similar to non-allocatable arrays.
However, the mapping operations include creation of the allocatable variable,
creation of the allocated storage, setting the allocation status to allocated,
and making sure the allocatable variable references the storage.</p>
<p>In Target 3 and 4 sections, allocatable variables are mapped in two
different ways before they are allocated on the host and subsequently used on the device.
In one case, a <strong>target data</strong> construct creates an enclosing region for
the allocatable variable to persist, and in the other case a
<strong>declare target</strong> directive maps the allocation variable for all device executions.
In both cases the new array storage is mapped <strong>tofrom</strong> with the <strong>always</strong> modifier.
An explicit map is used here with an <strong>always</strong> modifier to ensure that the allocatable
variable status is updated on the device.</p>
<p>Note: OpenMP 5.1 specifies that an <strong>always</strong> map modifier guarantees the
allocation status update for an existing allocatable variable on the device.
In OpenMP 6.0, this restriction may be relaxed to also guarantee updates
without the <strong>always</strong> modifier.</p>
<p>In Target 3 and 4 sections, the behavior of an allocatable variable is very
much like a Fortran pointer, in which a pointer can be mapped to a device with an associated
or disassociated status, and associated storage can be mapped and attached as needed.
For allocatable variables, the update of the allocation status to allocated (allowing
reference to allocated storage) on the device, is similar to pointer attachment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! @@name:       target_fort_allocatable_map.1
! @@type:       F-free
! @@compilable: yes
! @@linkable:   yes
! @@expect:     success
! @@version:    omp_5.1
program main
  implicit none
  integer :: i

  integer, save, allocatable :: d(:)
  !$omp    declare target(d)

  integer, allocatable :: a(:)
  integer, allocatable :: b(:)
  integer, allocatable :: c(:)

  allocate(a(4))
  !$omp target                      ! Target 1
    a(:) = 4
  !$omp end target
  print *, a ! prints 4*4

  allocate(b(4))
  !$omp target map(b)               ! Target 2 
    b(:) = 4
  !$omp end target
  print *, b ! prints 4*4

  !$omp target data map(c)
  
    allocate(c(4), source=[1,2,3,4])
    !$omp target map(always,tofrom:c) ! Target 3 
       c(:) = 4
    !$omp end target 
    print *, c ! prints 4*4

    deallocate(c)
  
  !$omp end target data

  allocate(d(4), source=[1,2,3,4])
  !$omp target map(always,tofrom:d) ! Target 4
     d(:) = d(:) + [ ( i,i=size(d),1,-1) ]
  !$omp end target
  print *, d ! prints 4*5

  deallocate(a, b, d)

end program
</pre></div>
</div>
</div>
</div>
<p>Once an allocatable variable has been allocated on the host,
its allocation status may not be changed in a <strong>target</strong> region, either
explicitly or implicitly. The following example illustrates typical
operations on allocatable variables that violate this restriction.
Note, an assignment that reshapes or reassigns (causing a deallocation
and allocation) in a <strong>target</strong> region is not conforming.
Also, an initial intrinsic assignment of an allocatable variable
requires deallocation before the <strong>target</strong> region ends.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! @@name:       target_fort_allocatable_map.2
! @@type:       F-free
! @@compilable: yes
! @@linkable:   yes
! @@expect:     unspecified
! @@version:    omp_5.1
program main
  implicit none

  integer, allocatable :: a(:,:), b(:), c(:)
  integer              :: x(10,2)

  allocate(a(2,10))

  !$omp target
     a = x             ! Reshape (or resize) NOT ALLOWED (implicit change)

     deallocate(a)     ! Allocation status change of &quot;a&quot; NOT ALLOWED.

     allocate(b(20))   ! Allocation of  b *

     c = 10            ! Intrinsic assignment allocates c *

     ! * Since an explicit deallocation for b and c does not occur before 
     ! the end of the target region, the PROGRAM BEHAVIOR IS UNSPECIFIED.
  !$omp end target

end program
</pre></div>
</div>
</div>
</div>
<p>The next example illustrates a corner case of this restriction (allocatable status
change in a <strong>target</strong> region).
Two allocatable arrays are passed to a subroutine within a <strong>target</strong>
region. The dummy-variable arrays are declared allocatable.
Also, the <em>ain</em> variable has the <em>intent(in)</em> attribute, and <em>bout</em>
has the <em>intent(out)</em> attribute.
For the dummy argument with the attributes <em>allocatable</em> and <em>intent(out)</em>,
the compiler will deallocate the associated actual argument when the subroutine is invoked.
(However, the allocation on procedure entry can be avoided by specifying the intent
as <em>intent(inout)</em>, making the intended use conforming.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! @@name:       target_fort_allocatable_map.3
! @@type:       F-free
! @@compilable: yes
! @@linkable:   no
! @@expect:     fail
! @@version:    omp_5.1
module corfu
contains
  subroutine foo(ain,bout)
    implicit none
    integer, allocatable, intent( in) :: ain(:)
    integer, allocatable, intent(out) :: bout(:) !&quot;out&quot; causes de/realloc
    !$omp declare target
    bout = ain
  end subroutine
end module

program  main
  use corfu
  implicit none

  integer, allocatable :: a(:)
  integer, allocatable :: b(:)
  allocate(a(10),b(10))
  a(:)=10
  b(:)=10

  !$omp target

  call foo(a,b) !ERROR: b deallocation/reallocation not allowed
                !  in target region

  !$omp end target

end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="array-sections-in-device-constructs">
<h2>Array Sections in Device Constructs<a class="headerlink" href="#array-sections-in-device-constructs" title="Permalink to this headline">#</a></h2>
<p>The following examples show the usage of array sections in <strong>map</strong> clauses  on <strong>target</strong> and <strong>target</strong> <strong>data</strong> constructs.</p>
<p>This example shows the invalid usage of two separate sections of the same array  inside of a <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: array_sections.1
* type: C
* version: omp_4.0
*/
void foo ()
{
   int A[30];
#pragma omp target data map( A[0:4] )
{
   /* Cannot map distinct parts of the same array */
   #pragma omp target map( A[7:20] )
   {
      A[2] = 0;
   }
}
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: array_sections.1
! type: F-free
! version: omp_4.0
subroutine foo()
integer :: A(30)
   A = 1
   !$omp target data map( A(1:4) )
     ! Cannot map distinct parts of the same array
     !$omp target map( A(8:27) )
        A(3) = 0
     !$omp end target
   !$omp end target data
end subroutine
</pre></div>
</div>
</div>
</div>
<p>This example shows the invalid usage of two separate sections of the same array  inside of a <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: array_sections.2
* type: C
* version: omp_4.0
*/
void foo ()
{
   int A[30], *p;
#pragma omp target data map( A[0:4] )
{
   p = &amp;A[0];
   /* invalid because p[3] and A[3] are the same
    * location on the host but the array section
    * specified via p[...] is not a subset of A[0:4] */
   #pragma omp target map( p[3:20] )
   {
      A[2] = 0;
      p[8] = 0;
   }
}
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: array_sections.2
! type: F-free
! version: omp_4.0
subroutine foo()
integer,target  :: A(30)
integer,pointer :: p(:)
   A=1
   !$omp target data map( A(1:4) )
     p=&gt;A
     ! invalid because p(4) and A(4) are the same
     ! location on the host but the array section
     ! specified via p(...) is not a subset of A(1:4)
     !$omp target map( p(4:23) )
        A(3) = 0
        p(9) = 0
     !$omp end target
   !$omp end target data
end subroutine
</pre></div>
</div>
</div>
</div>
<p>This example shows the valid usage of two separate sections of the same array inside  of a <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: array_sections.3
* type: C
* version: omp_4.0
*/
void foo ()
{
   int A[30], *p;
#pragma omp target data map( A[0:4] )
{
   p = &amp;A[0];
   #pragma omp target map( p[7:20] )
   {
      A[2] = 0;
      p[8] = 0;
   }
}
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: array_sections.3
! type: F-free
! version: omp_4.0
subroutine foo()
integer,target  :: A(30)
integer,pointer :: p(:)
   !$omp target data map( A(1:4) )
     p=&gt;A
     !$omp target map( p(8:27) )
        A(3) = 0
        p(9) = 0
     !$omp end target
   !$omp end target data
end subroutine
</pre></div>
</div>
</div>
</div>
<p>This example shows the valid usage of a wholly contained array section of an already  mapped array section inside of a <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: array_sections.4
* type: C
* version: omp_4.0
*/
void foo ()
{
   int A[30], *p;
#pragma omp target data map( A[0:10] )
{
   p = &amp;A[0];
   #pragma omp target map( p[3:7] )
   {
      A[2] = 0;
      p[8] = 0;
      A[8] = 1;
   }
}
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: array_sections.4
! type: F-free
! version: omp_4.0
subroutine foo()
integer,target  :: A(30)
integer,pointer :: p(:)
   !$omp target data map( A(1:10) )
     p=&gt;A
     !$omp target map( p(4:10) )
        A(3) = 0
        p(9) = 0
        A(9) = 1
     !$omp end target
   !$omp end target data
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="c-virtual-functions">
<h2>C++ Virtual Functions<a class="headerlink" href="#c-virtual-functions" title="Permalink to this headline">#</a></h2>
<p>The 5.2 OpenMP Specification clarified restrictions on the use
of polymorphic classes and virtual functions when used within
<strong>target</strong> regions.  The following example identifies
problem cases in which the restrictions are not followed
(for Unified Shared Memory, as prescribed by the <strong>requires</strong>
directive).</p>
<p>The first section illustrates the restriction
that when mapping an object for the first time,
the static and dynamic types must match.</p>
<p>For the first target region the behavior of the implicit map of <em>ar</em>
is not specified - its static type (A) doesn’t match its dynamic type (D).<br />
Hence access to the virtual functions is undefined.
However, the second target region can access <em>D::vf()</em>
since the object to which <em>ap</em> points is not mapped and
therefore the restriction does not apply.</p>
<p>The second section illustrates the restriction:</p>
<p><em>“Invoking a virtual member function of an object on a device other than the device on which the
object was constructed results in unspecified behavior, unless the object is accessible and was
constructed on the host device.”</em></p>
<p>An instantiation of a polymorphic class (<em>A</em>) occurs in the
<strong>target</strong> region, and access of its virtual function
is incorrectly attempted on the host (another device).
However, once the object is deleted on
the target device and instantiated on the host, access within
the next <strong>target</strong> region is permitted.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* @@name:       virtual_functions.1
* @@type:       C++
* @@compilable: yes
* @@linkable:   no
* @@expect:     success
* @@version:	omp_5.2
*/
#include &lt;iostream&gt;
#pragma omp requires unified_shared_memory

#pragma omp begin declare target
class A {  
  public:
   virtual void vf()  { std::cout &lt;&lt; &quot;In A\n&quot;; }
};

class D: public A {
  public:
   void vf() override { std::cout &lt;&lt; &quot;In D\n&quot;; }
};
#pragma omp end declare target

int main(){

   // Section 1 --------------------------------------------------------
   D d;               // D derives from A, and A::vf() is virtual
   A &amp;ar = d;         // reference to Derived object d

   #pragma omp target // implicit map of ar is illegal here
   {
      ar.vf();        // unspecified whether A::vf() or D::vf() is called
   }
   
   A *ap = &amp;d;        // pointer to derived object d
   #pragma omp target // No need for mapping with Unified Share Memory
   {                  // implicit ap[:0] map is fine 
      ap-&gt;vf();       // calls D::vf()
   }

   // Section 2 --------------------------------------------------------
   ap = nullptr;
   #pragma omp target map(ap)
   {
        ap = new A();
   }
   
   ap-&gt;vf();     // illegal

   #pragma omp target
   {
      delete ap;
   }
   ap = new A();
   #pragma omp target  // No need for mapping with Unified Share Memory
   {
      ap-&gt;vf();  // ok
   }

   return 0;
}
</pre></div>
</div>
</div>
</div>
</section>
<section id="array-shaping">
<h2>Array Shaping<a class="headerlink" href="#array-shaping" title="Permalink to this headline">#</a></h2>
<p>A pointer variable can be shaped to a multi-dimensional array to facilitate data access. This is achieved by a  <em>shape-operator</em>  casted in front of  a pointer (lvalue expression):<br />
<strong>([ s<sub>1</sub>][ s<sub>2</sub>]…[ s<sub>n</sub>])</strong> <em>pointer</em><br />
where each  s<sub>i</sub>  is an integral-type expression of positive value. The shape-operator can appear in either the  <em>motion-clause</em>  of the <strong>target</strong> <strong>update</strong> directive or the <strong>depend</strong> clause.</p>
<p>The following example shows the use of the shape-operator in the  <strong>target</strong> <strong>update</strong> directive. The shape-operator <strong>([nx][ny+2])</strong> casts pointer variable <em>a</em> to a 2-dimentional array of size  <em>nx</em>  x  <em>(ny+2)</em> .  The resulting array is then accessed as array sections (such as <strong>[0:nx][1]</strong> and <strong>[0:nx][ny]</strong>)  in the <strong>from</strong> or <strong>to</strong> clause for transferring two columns of  noncontiguous boundary data from or to the device.   Note the use of additional parentheses around the shape-operator and <em>a</em> to ensure the correct precedence  over array-section operations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: array_shaping.1
* type: C
* version: omp_5.1
*/
#pragma omp begin declare target
  int do_work(double *a, int nx, int ny);
  int other_work(double *a, int nx, int ny);
#pragma omp end declare target

void exch_data(double *a, int nx, int ny);

void array_shaping(double *a, int nx, int ny)
{
   // map data to device and do work
   #pragma omp target data map(a[0:nx*(ny+2)])
   {
      // do work on the device
      #pragma omp target  // map(a[0:nx*(ny+2)]) is optional here
      do_work(a, nx, ny);

      // update boundary points (two columns of 2D array) on the host
      // pointer is shaped to 2D array using the shape-operator
      #pragma omp target update from( (([nx][ny+2])a)[0:nx][1], \
                                      (([nx][ny+2])a)[0:nx][ny] )

      // exchange ghost points with neighbors
      exch_data(a, nx, ny);

      // update ghost points (two columns of 2D array) on the device
      // pointer is shaped to 2D array using the shape-operator
      #pragma omp target update to( (([nx][ny+2])a)[0:nx][0], \
                                    (([nx][ny+2])a)[0:nx][ny+1] )

      // perform other work on the device
      #pragma omp target  // map(a[0:nx*(ny+2)]) is optional here
      other_work(a, nx, ny);
   }
}
</pre></div>
</div>
</div>
</div>
<p>The shape operator is not defined for Fortran.  Explicit array shaping of procedure arguments can be used instead to achieve a similar goal. Below is the Fortran-equivalent of the above example that illustrates the support of transferring two rows of noncontiguous boundary data in the <strong>target</strong> <strong>update</strong> directive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: array_shaping.1
! type: F-free
! version: omp_5.2

module m
   interface
      subroutine do_work(a, nx, ny)
         !$omp declare target enter(do_work)
         integer, intent(in) :: nx, ny
         double precision a(0:nx+1,ny)
      end subroutine do_work

      subroutine other_work(a, nx, ny)
         !$omp declare target enter(other_work)
         integer, intent(in) :: nx, ny
         double precision a(0:nx+1,ny)
      end subroutine other_work

      subroutine exch_data(a, nx, ny)
         integer, intent(in) :: nx, ny
         double precision a(0:nx+1,ny)
      end subroutine exch_data
   end interface
end module m

subroutine array_shaping(a, nx, ny)
   use m
   implicit none
   integer, intent(in) :: nx, ny
   double precision a(0:nx+1,ny)

   ! map data to device and do work
   !$omp target data map(a)

      ! do work on the device
      !$omp target      ! map(a) is optional here
      call do_work(a, nx, ny)
      !$omp end target

      ! update boundary points (two rows of 2D array) on the host.
      ! data transferred are noncontiguous
      !$omp target update from( a(1,1:ny), a(nx,1:ny) )

      ! exchange ghost points with neighbors
      call exch_data(a, nx, ny)

      ! update ghost points (two rows of 2D array) on the device.
      ! data transferred are noncontiguous
      !$omp target update to( a(0,1:ny), a(nx+1,1:ny) )

      ! perform other work on the device
      !$omp target      ! map(a) is optional here
      call other_work(a, nx, ny)
      !$omp end target

   !$omp end target data

end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-mapper-directive">
<h2><strong>declare mapper</strong> Directive<a class="headerlink" href="#declare-mapper-directive" title="Permalink to this headline">#</a></h2>
<p>The following examples show how to use the <strong>declare mapper</strong> directive to prescribe a map for later use. It is also quite useful for pre-defining partitioned and nested  structure elements.</p>
<p>In the first example the <strong>declare mapper</strong> directive specifies  that any structure of type  <em>myvec_t</em>  for which implicit data-mapping rules apply will be mapped according to its <strong>map</strong> clause. The variable  <em>v</em>  is used for referencing the structure and its  elements within the <strong>map</strong> clause.  Within the <strong>map</strong> clause the  <em>v</em>  variable specifies that all elements of the structure are to be mapped.  Additionally, the array section  <em>v.data[0:v.len]</em>  specifies that the dynamic  storage for data is to be mapped.</p>
<p>Within the main program the  <em>s</em>  variable is typed as  <em>myvec_t</em> . Since the variable is found within the target region and the type has a mapping prescribed by a <strong>declare mapper</strong> directive, it will be automatically mapped according to its prescription:  full structure, plus the dynamic storage of the  <em>data</em>  element.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_mapper.1
* type: C
* version: omp_5.0
*/
#include  &lt;stdlib.h&gt;
#include   &lt;stdio.h&gt;
#define N 100

typedef struct myvec{
    size_t len;
    double *data;
} myvec_t;

#pragma omp declare mapper(myvec_t v) \
                    map(v, v.data[0:v.len])
void init(myvec_t *s);

int main(){
   myvec_t s;

   s.data = (double *)calloc(N,sizeof(double));
   s.len  = N;

   #pragma omp target
   init(&amp;s);

   printf(&quot;s.data[%d]=%lf\n&quot;,N-1,s.data[N-1]);  //s.data[99]=99.000000
}

void init(myvec_t *s)
{ for(int i=0; i&lt;s-&gt;len; i++) s-&gt;data[i]=i; }
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       target_mapper.1
! type:       F-free
! version:    omp_5.0

module my_structures
  type myvec_t
    integer                     :: len
    double precision, pointer   :: data(:)
  end type
end module

program main
  use my_structures
  integer, parameter :: N=100

  !$omp  declare mapper(myvec_t :: v) &amp;
  !$omp&amp;         map(v, v%data(1:v%len))

  type(myvec_t) :: s

  allocate(s%data(N))
  s%data(1:N) = 0.0d0
  s%len = N

  !$omp target
  call init(s)
  !$omp end target

  print*,&quot;s%data(&quot;,N,&quot;)=&quot;,s%data(N)  !! s%data( 100 )=100.000000000000
end program

subroutine init(s)
  use my_structures
  type(myvec_t) :: s

  s%data = [ (i, i=1,s%len) ]
end subroutine
</pre></div>
</div>
</div>
</div>
<p>The next example illustrates the use of the  <em>mapper-identifier</em>  and deep copy within a structure.  The structure,  <em>dzmat_t</em> ,  represents a complex matrix,  with separate real ( <em>r_m</em> ) and imaginary ( <em>i_m</em> ) elements. Two map identifiers are created for partitioning the  <em>dzmat_t</em>  structure.</p>
<p>For the C/C++ code the first identifier is named  <em>top_id</em>  and maps the top half of two matrices of type  <em>dzmat_t</em> ; while the second identifier,  <em>bottom_id</em> , maps the lower half of two matrices.  Each identifier is applied to a different <strong>target</strong> construct, as  <strong>map(mapper(top_id), tofrom: a,b)</strong>  and <strong>map(mapper(bottom_id), tofrom: a,b)</strong>. Each target offload is allowed to execute concurrently on two different devices  ( <em>0</em>  and  <em>1</em> ) through the <strong>nowait</strong> clause.</p>
<p>The Fortran code uses the  <em>left_id</em>  and  <em>right_id</em>  map identifiers in the <strong>map(mapper(left_id),tofrom: a,b)</strong> and <strong>map(mapper(right_id),tofrom: a,b)</strong> map clauses.   The array sections for these left and right contiguous portions of the matrices  were defined previously in the <strong>declare mapper</strong> directive.</p>
<p>Note, the  <em>is</em>  and  <em>ie</em>  scalars are firstprivate  by default for a target region, but are declared firstprivate anyway to remind the user of important firstprivate data-sharing properties required here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_mapper.2
* type: C
* version: omp_5.0
*/
#include &lt;stdio.h&gt;
//                   N MUST BE EVEN
#define N  100

  typedef struct dzmat
  {
     double r_m[N][N];
     double i_m[N][N];
  } dzmat_t;

  #pragma omp declare mapper( top_id: dzmat_t v) \
                      map(v.r_m[0:N/2][0:N],     \
                          v.i_m[0:N/2][0:N]      )

  #pragma omp declare mapper(bottom_id: dzmat_t v) \
                      map(v.r_m[N/2:N/2][0:N],     \
                          v.i_m[N/2:N/2][0:N]      )
//initialization
void dzmat_init(dzmat_t *z, int is, int ie, int n);
//matrix add: c=a+b
void host_add(  dzmat_t *a, dzmat_t *b, dzmat_t *c, int n);


int main()
{
  dzmat_t a,b,c;
  int     is,ie;

  is=0; ie=N/2-1;       //top N/2 rows on device 0
  #pragma omp target map(mapper(top_id), tofrom: a,b) device(0) \
                     firstprivate(is,ie) nowait
  {
    dzmat_init(&amp;a,is,ie,N);
    dzmat_init(&amp;b,is,ie,N);
  }

  is=N/2; ie=N-1;       //bottom N/2 rows on device 1
  #pragma omp target map(mapper(bottom_id), tofrom: a,b) device(1) \
                     firstprivate(is,ie) nowait
  {
    dzmat_init(&amp;a,is,ie,N);
    dzmat_init(&amp;b,is,ie,N);
  }

  #pragma omp taskwait

  host_add(&amp;a,&amp;b,&amp;c,N);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       target_mapper.2
! type:       F-free
! version:    omp_5.0
module complex_mats

   integer, parameter :: N=100    !N must be even
   type dzmat_t
     double precision ::  r_m(N,N), i_m(N,N)
   end type

   !$omp  declare mapper( left_id: dzmat_t :: v) map( v%r_m(N,  1:N/2), &amp;
   !$omp&amp;                                             v%i_m(N,  1:N/2))

   !$omp  declare mapper(right_id: dzmat_t :: v) map( v%r_m(N,N/2+1:N), &amp;
   !$omp&amp;                                             v%i_m(N,N/2+1:N))

end module


program main
  use  complex_mats
  type(dzmat_t) :: a,b,c
  external dzmat_init, host_add  !initialization and matrix add: a=b+c

  integer :: is,ie


  is=1; ie=N/2            !left N/2 columns on device 0
  !$omp target map(mapper( left_id), tofrom: a,b) device(0) &amp;
  !$omp&amp;       firstprivate(is,ie) nowait
    call dzmat_init(a,is,ie)
    call dzmat_init(b,is,ie)
  !$omp end target

  is=N/2+1; ie=N         !right N/2 columns on device 1
  !$omp target map(mapper(right_id), tofrom: a,b) device(1) &amp;
  !$omp&amp;       firstprivate(is,ie) nowait
    call dzmat_init(a,is,ie)
    call dzmat_init(b,is,ie)
  !$omp end target

  !$omp taskwait

  call host_add(a,b,c)

end program main
</pre></div>
</div>
</div>
</div>
<p>In the third example  <em>myvec</em>  structures are nested within a  <em>mypoints</em>  structure. The  <em>myvec_t</em>  type is mapped as in the first example.  Following the  <em>mypoints</em>  structure declaration,  the  <em>mypoints_t</em>  type is mapped by a <strong>declare mapper</strong> directive.  For this structure the  <em>hostonly_data</em>  element will not be mapped; also the array section of  <em>x</em>  ( <em>v.x[:1]</em> ) and  <em>x</em>  will be mapped; and  <em>scratch</em>  will be allocated and used as scratch storage on the device. The default map-type mapping, <strong>tofrom</strong>, applies to the  <em>x</em>  array section, but not to  <em>scratch</em>  which is explicitly mapped with the <strong>alloc</strong> map-type.  Note: the variable  <em>v</em>  is not included in the map list (otherwise the  <em>hostonly_data</em>  would be mapped) - just the elements  to be mapped are listed.</p>
<p>The two mappers are combined when a  <em>mypoints_t</em>  structure type is mapped, because the mapper  <em>myvec_t</em>  structure type is used within a  <em>mypoints_t</em>  type structure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_mapper.3
* type: C
* version: omp_5.0
*/

#include &lt;stdlib.h&gt;
#include  &lt;stdio.h&gt;

#define N 100

typedef struct myvec {
    size_t len;
    double *data;
} myvec_t;

#pragma omp declare mapper(myvec_t v) \
                    map(v, v.data[0:v.len])

typedef struct mypoints {
    struct myvec scratch;
    struct myvec *x;
    double hostonly_data[500000];
} mypoints_t;

#pragma omp declare mapper(mypoints_t v)  \
                    map(v.x, v.x[0] ) map(alloc:v.scratch)

void init_mypts_array(mypoints_t *P, int n);
void eval_mypts_array(mypoints_t *P, int n);

int main(){

   mypoints_t P;

   init_mypts_array(&amp;P, N);

   #pragma omp target map(P)
   eval_mypts_array(&amp;P, N);

}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       target_mapper.3
! type:       F-free
! version:    omp_5.0

module my_structures
  type myvec_t
    integer                   :: len
    double precision, pointer :: data(:)
  end type
  !$omp  declare mapper(myvec_t :: v) &amp;
  !$omp&amp;         map(v)

  type mypoints_t
     type(myvec_t)            :: scratch
     type(myvec_t), pointer   :: x(:)
     double precision         :: hostonly_data(500000)
  end  type
 !$omp  declare mapper(mypoints_t :: v)  &amp;
 !$omp&amp;         map(v%x, v%x(1)) map(alloc:v%scratch)

end module


program main
  use my_structures
  external  init_mypts_array, eval_mypts_array

  type(mypoints_t) :: P

   call init_mypts_array(P)

   !$omp target map(P)
   call eval_mypts_array(P)

end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-data-construct">
<h2><strong>target</strong> <strong>data</strong> Construct<a class="headerlink" href="#target-data-construct" title="Permalink to this headline">#</a></h2>
<section id="simple-target-data-construct">
<h3>Simple <strong>target</strong> <strong>data</strong> Construct<a class="headerlink" href="#simple-target-data-construct" title="Permalink to this headline">#</a></h3>
<p>This example shows how the <strong>target</strong> <strong>data</strong> construct maps variables  to a device data environment. The <strong>target</strong> <strong>data</strong> construct creates  a new device data environment and maps the variables  <em>v1</em> ,  <em>v2</em> , and  <em>p</em>  to the new device  data environment. The <strong>target</strong> construct enclosed in the <strong>target</strong>  <strong>data</strong> region creates a new device data environment, which inherits the  variables  <em>v1</em> ,  <em>v2</em> , and  <em>p</em>  from the enclosing device data environment. The variable   <em>N</em>  is mapped into the new device data environment from the encountering task’s data  environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_data.1
* type: C
* version: omp_4.0
*/
extern void init(float*, float*, int);
extern void output(float*, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target data map(to: v1[0:N], v2[:N]) map(from: p[0:N])
   {
      #pragma omp target
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
 p[i] = v1[i] * v2[i];
   }
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<p>The Fortran code passes a reference and specifies the extent of the arrays in the  declaration. No length information is necessary in the map clause, as is required  with C/C++ pointers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_data.1
! type: F-free
! version:    omp_4.0
subroutine vec_mult(p, v1, v2, N)
   real    ::  p(N), v1(N), v2(N)
   integer ::  i
   call init(v1, v2, N)
   !$omp target data map(to: v1, v2) map(from: p)
   !$omp target
   !$omp parallel do
      do i=1,N
  p(i) = v1(i) * v2(i)
      end do
   !$omp end target
   !$omp end target data
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-data-region-enclosing-multiple-target-regions">
<h3><strong>target</strong> <strong>data</strong> Region Enclosing Multiple <strong>target</strong> Regions<a class="headerlink" href="#target-data-region-enclosing-multiple-target-regions" title="Permalink to this headline">#</a></h3>
<p>The following examples show how the <strong>target</strong> <strong>data</strong> construct maps  variables to a device data environment of a <strong>target</strong> region. The <strong>target</strong>  <strong>data</strong> construct creates a device data environment and encloses <strong>target</strong>  regions, which have their own device data environments. The device data environment  of the <strong>target</strong> <strong>data</strong> region is inherited by the device data environment  of an enclosed <strong>target</strong> region. The <strong>target</strong> <strong>data</strong> construct  is used to create variables that will persist throughout the <strong>target</strong> <strong>data</strong>  region.</p>
<p>In the following example the variables  <em>v1</em>  and  <em>v2</em>  are mapped at each <strong>target</strong>  construct. Instead of mapping the variable  <em>p</em>  twice, once at each <strong>target</strong>  construct,  <em>p</em>  is mapped once by the <strong>target</strong> <strong>data</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_data.2
* type: C
* version: omp_4.0
*/
extern void init(float*, float*, int);
extern void init_again(float*, float*, int);
extern void output(float*, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target data map(from: p[0:N])
   {
      #pragma omp target map(to: v1[:N], v2[:N])
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
 p[i] = v1[i] * v2[i];
      init_again(v1, v2, N);
      #pragma omp target map(to: v1[:N], v2[:N])
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
 p[i] = p[i] + (v1[i] * v2[i]);
   }
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<p>The Fortran code uses reference and specifies the extent of the  <em>p</em> ,  <em>v1</em>  and  <em>v2</em>  arrays.  No length information is necessary in the <strong>map</strong> clause, as is required with  C/C++ pointers. The arrays  <em>v1</em>  and  <em>v2</em>  are mapped at each <strong>target</strong> construct.  Instead of mapping the array  <em>p</em>  twice, once at each target construct,  <em>p</em>  is mapped  once by the <strong>target</strong> <strong>data</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_data.2
! type: F-free
! version:    omp_4.0
subroutine vec_mult(p, v1, v2, N)
   real    ::  p(N), v1(N), v2(N)
   integer ::  i
   call init(v1, v2, N)
   !$omp target data map(from: p)
      !$omp target map(to: v1, v2 )
         !$omp parallel do
         do i=1,N
            p(i) = v1(i) * v2(i)
         end do
      !$omp end target
      call init_again(v1, v2, N)
      !$omp target map(to: v1, v2 )
         !$omp parallel do
         do i=1,N
            p(i) = p(i) + v1(i) * v2(i)
         end do
      !$omp end target
   !$omp end target data
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
<p>In the following example, the array  <em>Q</em>  is mapped once at the enclosing  <strong>target</strong> <strong>data</strong> region instead of at each <strong>target</strong> construct.  In OpenMP 4.0, a scalar variable is implicitly mapped with the <strong>tofrom</strong> map-type. But since OpenMP 4.5, a scalar variable, such as the  <em>tmp</em>  variable, has to be explicitly mapped with  the <strong>tofrom</strong> map-type at the first <strong>target</strong> construct in order to return  its reduced value from the parallel loop construct to the host. The variable defaults to firstprivate at the second <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_data.3
* type: C
* version: omp_4.0
*/

#include &lt;math.h&gt;
#define COLS 100

void gramSchmidt(float Q[][COLS], const int rows)
{
    int cols = COLS;
    #pragma omp target data map(Q[0:rows][0:cols])
    for(int k=0; k &lt; cols; k++)
    {
        double tmp = 0.0;

        #pragma omp target map(tofrom: tmp)
        #pragma omp parallel for reduction(+:tmp)
        for(int i=0; i &lt; rows; i++)
            tmp += (Q[i][k] * Q[i][k]);

        tmp = 1/sqrt(tmp);

        #pragma omp target
        #pragma omp parallel for
        for(int i=0; i &lt; rows; i++)
            Q[i][k] *= tmp;
    }
}

/* Note:  The variable tmp is now mapped with tofrom, for correct
          execution with 4.5 (and pre-4.5) compliant compilers.
          See Devices Intro.
 */
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_data.3
! type: F-free
! version:    omp_4.0
subroutine gramSchmidt(Q,rows,cols)
integer             ::   rows,cols,  i,k
double precision    :: Q(rows,cols), tmp
      !$omp target data map(Q)
      do k=1,cols
         tmp = 0.0d0
        !$omp target map(tofrom: tmp)
           !$omp parallel do reduction(+:tmp)
           do i=1,rows
              tmp = tmp + (Q(i,k) * Q(i,k))
           end do
        !$omp end target

          tmp = 1.0d0/sqrt(tmp)

        !$omp target
           !$omp parallel do
           do i=1,rows
               Q(i,k) = Q(i,k)*tmp
           enddo
        !$omp end target
      end do
      !$omp end target data
end subroutine

! Note:  The variable tmp is now mapped with tofrom, for correct
! execution with 4.5 (and pre-4.5) compliant compilers. See Devices Intro.
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-data-construct-with-orphaned-call">
<h3><strong>target</strong> <strong>data</strong> Construct with Orphaned Call<a class="headerlink" href="#target-data-construct-with-orphaned-call" title="Permalink to this headline">#</a></h3>
<p>The following two examples show how the <strong>target</strong> <strong>data</strong> construct  maps variables to a device data environment. The <strong>target</strong> <strong>data</strong>  construct’s device data environment encloses the <strong>target</strong> construct’s device  data environment in the function <strong>vec_mult()</strong>.</p>
<p>When the type of the variable appearing in an array section is pointer, the pointer  variable and the storage location of the corresponding array section are mapped  to the device data environment. The pointer variable is treated as if it had appeared  in a <strong>map</strong> clause with a map-type of <strong>alloc</strong>. The array section’s  storage location is mapped according to the map-type in the <strong>map</strong> clause  (the default map-type is <strong>tofrom</strong>).</p>
<p>The <strong>target</strong> construct’s device data environment inherits the storage locations  of the array sections  <em>v1[0:N]</em> ,  <em>v2[:n]</em> , and  <em>p0[0:N]</em>  from the enclosing <strong>target</strong> <strong>data</strong> construct’s device data environment. Neither initialization nor assignment is performed  for the array sections in the new device data environment.</p>
<p>The pointer variables  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are mapped into the <strong>target</strong> construct’s device  data environment with an implicit map-type of alloc and they are assigned the address  of the storage location associated with their corresponding array sections. Note  that the following pairs of array section storage locations are equivalent ( <em>p0[:N]</em> ,   <em>p1[:N]</em> ), ( <em>v1[:N]</em> , <em>v3[:N]</em> ), and ( <em>v2[:N]</em> , <em>v4[:N]</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_data.4
* type: C
* version: omp_4.0
*/
void vec_mult(float*, float*, float*, int);

extern void init(float*, float*, int);
extern void output(float*, int);


void foo(float *p0, float *v1, float *v2, int N)
{
   init(v1, v2, N);

   #pragma omp target data map(to: v1[0:N], v2[:N]) map(from: p0[0:N])
   {
      vec_mult(p0, v1, v2, N);
   }

   output(p0, N);
}


void vec_mult(float *p1, float *v3, float *v4, int N)
{
   int i;
   #pragma omp target map(to: v3[0:N], v4[:N]) map(from: p1[0:N])
   #pragma omp parallel for
   for (i=0; i&lt;N; i++)
   {
     p1[i] = v3[i] * v4[i];
   }
}
</pre></div>
</div>
</div>
</div>
<p>The Fortran code maps the pointers and storage in an identical manner (same extent,  but uses indices from 1 to  <em>N</em> ).</p>
<p>The <strong>target</strong> construct’s device data environment inherits the storage locations  of the arrays  <em>v1</em> ,  <em>v2</em>  and  <em>p0</em>  from the enclosing <strong>target</strong> <strong>data</strong> constructs’s  device data environment. However, in Fortran the associated data of the pointer  is known, and the shape is not required.</p>
<p>The pointer variables  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are mapped into the <strong>target</strong> construct’s  device data environment with an implicit map-type of <strong>alloc</strong> and they are  assigned the address of the storage location associated with their corresponding  array sections. Note that the following pair of array storage locations are equivalent  ( <em>p0</em> , <em>p1</em> ), ( <em>v1</em> , <em>v3</em> ), and ( <em>v2</em> , <em>v4</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_data.4
! type: F-free
! version:    omp_4.0
module mults
contains
subroutine foo(p0,v1,v2,N)
real,pointer,dimension(:) :: p0, v1, v2
integer                   :: N,i

   call init(v1, v2, N)

   !$omp target data map(to: v1, v2) map(from: p0)
    call vec_mult(p0,v1,v2,N)
   !$omp end target data

   call output(p0, N)

end subroutine

subroutine vec_mult(p1,v3,v4,N)
real,pointer,dimension(:) :: p1, v3, v4
integer                   :: N,i

   !$omp target map(to: v3, v4) map(from: p1)
   !$omp parallel do
   do i=1,N
      p1(i) = v3(i) * v4(i)
   end do
   !$omp end target

end subroutine
end module
</pre></div>
</div>
</div>
</div>
<p>In the following example, the variables  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are references to the pointer  variables  <em>p0</em> ,  <em>v1</em>  and  <em>v2</em>  respectively. The <strong>target</strong> construct’s device data  environment inherits the pointer variables  <em>p0</em> ,  <em>v1</em> , and  <em>v2</em>  from the enclosing <strong>target</strong>  <strong>data</strong> construct’s device data environment. Thus,  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are already  present in the device data environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_data.5
* type: C++
* version: omp_4.0
*/
void vec_mult(float* &amp;, float* &amp;, float* &amp;, int &amp;);
extern void init(float*, float*, int);
extern void output(float*, int);
void foo(float *p0, float *v1, float *v2, int N)
{
   init(v1, v2, N);
   #pragma omp target data map(to: v1[0:N], v2[:N]) map(from: p0[0:N])
   {
      vec_mult(p0, v1, v2, N);
   }
   output(p0, N);
}
void vec_mult(float* &amp;p1, float* &amp;v3, float* &amp;v4, int &amp;N)
{
   int i;
   #pragma omp target map(to: v3[0:N], v4[:N]) map(from: p1[0:N])
   #pragma omp parallel for
   for (i=0; i&lt;N; i++)
     p1[i] = v3[i] * v4[i];
}
</pre></div>
</div>
</div>
</div>
<p>In the following example, the usual Fortran approach is used for dynamic memory.  The  <em>p0</em> ,  <em>v1</em> , and  <em>v2</em>  arrays are allocated in the main program and passed as references  from one routine to another. In <strong>vec_mult</strong>,  <em>p1</em> ,  <em>v3</em>  and  <em>v4</em>  are references to the   <em>p0</em> ,  <em>v1</em> , and  <em>v2</em>  arrays, respectively. The <strong>target</strong> construct’s device data  environment inherits the arrays  <em>p0</em> ,  <em>v1</em> , and  <em>v2</em>  from the enclosing target data construct’s  device data environment. Thus,  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are already present in the device  data environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_data.5
! type: F-free
! version:    omp_4.0
module my_mult
contains
subroutine foo(p0,v1,v2,N)
real,dimension(:) :: p0, v1, v2
integer           :: N,i
   call init(v1, v2, N)
   !$omp target data map(to: v1, v2) map(from: p0)
    call vec_mult(p0,v1,v2,N)
   !$omp end target data
   call output(p0, N)
end subroutine
subroutine vec_mult(p1,v3,v4,N)
real,dimension(:) :: p1, v3, v4
integer           :: N,i
   !$omp target map(to: v3, v4) map(from: p1)
   !$omp parallel do
   do i=1,N
      p1(i) = v3(i) * v4(i)
   end do
   !$omp end target
end subroutine
end module
program main
use my_mult
integer, parameter :: N=1024
real,allocatable, dimension(:) :: p, v1, v2
   allocate( p(N), v1(N), v2(N) )
   call foo(p,v1,v2,N)
   deallocate( p, v1, v2 )
end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-data-construct-with-if-clause">
<h3><strong>target</strong> <strong>data</strong> Construct with <strong>if</strong> Clause<a class="headerlink" href="#target-data-construct-with-if-clause" title="Permalink to this headline">#</a></h3>
<p>The following two examples show how the <strong>target</strong> <strong>data</strong> construct  maps variables to a device data environment.</p>
<p>In the following example, the if clause on the <strong>target</strong> <strong>data</strong> construct  indicates that if the variable  <em>N</em>  is smaller than a given threshold, then the <strong>target</strong>  <strong>data</strong> construct will not create a device data environment.</p>
<p>The <strong>target</strong> constructs enclosed in the <strong>target</strong> <strong>data</strong> region  must also use an <strong>if</strong> clause on the same condition, otherwise the pointer  variable  <em>p</em>  is implicitly mapped with a map-type of <strong>tofrom</strong>, but the storage  location for the array section  <em>p[0:N]</em>  will not be mapped in the device data environments  of the <strong>target</strong> constructs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_data.6
* type: C
* version: omp_4.0
*/
#define THRESHOLD 1000000
extern void init(float*, float*, int);
extern void init_again(float*, float*, int);
extern void output(float*, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target data if(N&gt;THRESHOLD) map(from: p[0:N])
   {
      #pragma omp target if (N&gt;THRESHOLD) map(to: v1[:N], v2[:N])
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
        p[i] = v1[i] * v2[i];
      init_again(v1, v2, N);
      #pragma omp target if (N&gt;THRESHOLD) map(to: v1[:N], v2[:N])
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
        p[i] = p[i] + (v1[i] * v2[i]);
   }
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<p>The <strong>if</strong> clauses work the same way for the following Fortran code. The <strong>target</strong>  constructs enclosed in the <strong>target</strong> <strong>data</strong> region should also use  an <strong>if</strong> clause with the same condition, so that the <strong>target</strong> <strong>data</strong>  region and the <strong>target</strong> region are either both created for the device, or  are both ignored.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_data.6
! type: F-free
! version:    omp_4.0
module params
integer,parameter :: THRESHOLD=1000000
end module
subroutine vec_mult(p, v1, v2, N)
   use params
   real    ::  p(N), v1(N), v2(N)
   integer ::  i
   call init(v1, v2, N)
   !$omp target data if(N&gt;THRESHOLD) map(from: p)
      !$omp target if(N&gt;THRESHOLD) map(to: v1, v2)
         !$omp parallel do
         do i=1,N
            p(i) = v1(i) * v2(i)
         end do
      !$omp end target
      call init_again(v1, v2, N)
      !$omp target if(N&gt;THRESHOLD) map(to: v1, v2)
         !$omp parallel do
         do i=1,N
            p(i) = p(i) + v1(i) * v2(i)
         end do
      !$omp end target
   !$omp end target data
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
<p>In the following example, when the <strong>if</strong> clause conditional expression on  the <strong>target</strong> construct evaluates to  <em>false</em> , the target region will  execute on the host device. However, the <strong>target</strong> <strong>data</strong> construct  created an enclosing device data environment that mapped  <em>p[0:N]</em>  to a device data  environment on the default device. At the end of the <strong>target</strong> <strong>data</strong>  region the array section  <em>p[0:N]</em>  will be assigned from the device data environment  to the corresponding variable in the data environment of the task that encountered  the <strong>target</strong> <strong>data</strong> construct, resulting in undefined values in  <em>p[0:N]</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_data.7
* type: C
* version: omp_4.0
*/
#define THRESHOLD 1000000
extern void init(float*, float*, int);
extern void output(float*, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target data map(from: p[0:N])
   {
      #pragma omp target if (N&gt;THRESHOLD) map(to: v1[:N], v2[:N])
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
        p[i] = v1[i] * v2[i];
   } /* UNDEFINED behavior if N&lt;=THRESHOLD */
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<p>The <strong>if</strong> clauses work the same way for the following Fortran code. When  the <strong>if</strong> clause conditional expression on the <strong>target</strong> construct  evaluates to  <em>false</em> , the <strong>target</strong> region will execute on the host  device. However, the <strong>target</strong> <strong>data</strong> construct created an enclosing  device data environment that mapped the  <em>p</em>  array (and  <em>v1</em>  and  <em>v2</em> ) to a device data  environment on the default target device. At the end of the <strong>target</strong> <strong>data</strong>  region the  <em>p</em>  array will be assigned from the device data environment to the corresponding  variable in the data environment of the task that encountered the <strong>target</strong>  <strong>data</strong> construct, resulting in undefined values in  <em>p</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_data.7
! type: F-free
! version:    omp_4.0
module params
integer, parameter :: THRESHOLD=1000000
end module
subroutine vec_mult(p, v1, v2, N)
   use params
   real    ::  p(N), v1(N), v2(N)
   integer ::  i
   call init(v1, v2, N)
   !$omp target data map(from: p)
      !$omp target if(N&gt;THRESHOLD) map(to: v1, v2)
         !$omp parallel do
         do i=1,N
            p(i) = v1(i) * v2(i)
         end do
      !$omp end target
   !$omp end target data
   call output(p, N)  !*** UNDEFINED behavior if N&lt;=THRESHOLD
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="target-enter-data-and-target-exit-data-constructs">
<h2><strong>target</strong> <strong>enter</strong> <strong>data</strong> and <strong>target</strong> <strong>exit</strong> <strong>data</strong> Constructs<a class="headerlink" href="#target-enter-data-and-target-exit-data-constructs" title="Permalink to this headline">#</a></h2>
<p>The structured data construct (<strong>target</strong> <strong>data</strong>) provides persistent data on a device for subsequent <strong>target</strong> constructs as shown in the  <strong>target</strong> <strong>data</strong> examples above. This is accomplished by creating a single <strong>target</strong> <strong>data</strong> region containing <strong>target</strong> constructs.</p>
<p>The unstructured data constructs allow the creation and deletion of data on the device at any appropriate point within the host code, as shown below  with the <strong>target</strong> <strong>enter</strong> <strong>data</strong> and <strong>target</strong> <strong>exit</strong> <strong>data</strong> constructs.</p>
<p>The following C++ code creates/deletes a vector in a constructor/destructor  of a class. The constructor creates a vector with <strong>target</strong> <strong>enter</strong> <strong>data</strong> and uses an <strong>alloc</strong> modifier in the <strong>map</strong> clause to avoid copying values to the device. The destructor deletes the data (<strong>target</strong> <strong>exit</strong> <strong>data</strong>) and uses the <strong>delete</strong> modifier in the <strong>map</strong> clause to avoid copying data back to the host. Note, the stand-alone <strong>target</strong> <strong>enter</strong> <strong>data</strong> occurs  after the host vector is created, and the <strong>target</strong> <strong>exit</strong> <strong>data</strong> construct occurs before the host data is deleted.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:        target_unstructured_data.1
* type:        C++
* version:     omp_4.5
*/
class Matrix
{

  Matrix(int n) {
    len = n;
    v = new double[len];
    #pragma omp target enter data map(alloc:v[0:len])
  }

  ~Matrix() {
    // NOTE: delete map type should be used, since the corresponding
    // host data will cease to exist after the deconstructor is called.

    #pragma omp target exit data map(delete:v[0:len])
    delete[] v;
  }

  private:
  double* v;
  int len;

};
</pre></div>
</div>
</div>
</div>
<p>The following C code allocates and frees the data member of a Matrix structure. The <strong>init_matrix</strong> function allocates the memory used in the structure and uses the <strong>target</strong> <strong>enter</strong> <strong>data</strong> directive to map it to the target device. The <strong>free_matrix</strong> function removes the mapped array from the target device and then frees the memory on the host.  Note, the stand-alone  <strong>target</strong> <strong>enter</strong> <strong>data</strong> occurs after the host memory is allocated, and the  <strong>target</strong> <strong>exit</strong> <strong>data</strong> construct occurs before the host data is freed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
 * name:        target_unstructured_data.1
 * type:        C
 * version:     omp_4.5
 */
#include &lt;stdlib.h&gt;
typedef struct {
  double *A;
  int N;
} Matrix;

void init_matrix(Matrix *mat, int n)
{
  mat-&gt;A = (double *)malloc(n*sizeof(double));
  mat-&gt;N = n;
  #pragma omp target enter data map(alloc:mat-&gt;A[:n])
}

void free_matrix(Matrix *mat)
{
  #pragma omp target exit data map(delete:mat-&gt;A[:mat-&gt;N])
  mat-&gt;N = 0;
  free(mat-&gt;A);
  mat-&gt;A = NULL;
}
</pre></div>
</div>
</div>
</div>
<p>The following Fortran code allocates and deallocates a module array.  The <strong>initialize</strong> subroutine allocates the module array and uses the <strong>target</strong> <strong>enter</strong> <strong>data</strong> directive to map it to the target device. The <strong>finalize</strong> subroutine removes the mapped array from the target device and then deallocates the array on the host.  Note, the stand-alone  <strong>target</strong> <strong>enter</strong> <strong>data</strong> occurs after the host memory is allocated, and the  <strong>target</strong> <strong>exit</strong> <strong>data</strong> construct occurs before the host data is deallocated.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:        target_unstructured_data.1
! type:        F-free
! version:     omp_4.5
module example
  real(8), allocatable :: A(:)

  contains
    subroutine initialize(N)
      integer :: N

      allocate(A(N))
      !$omp target enter data map(alloc:A)

    end subroutine initialize

    subroutine finalize()

      !$omp target exit data map(delete:A)
      deallocate(A)

    end subroutine finalize
end module example
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-update-construct">
<h2><strong>target</strong> <strong>update</strong> Construct<a class="headerlink" href="#target-update-construct" title="Permalink to this headline">#</a></h2>
<section id="simple-target-data-and-target-update-constructs">
<h3>Simple <strong>target</strong> <strong>data</strong> and <strong>target</strong> <strong>update</strong> Constructs<a class="headerlink" href="#simple-target-data-and-target-update-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>update</strong> construct updates  variables in a device data environment.</p>
<p>The <strong>target</strong> <strong>data</strong> construct maps array sections  <em>v1[:N]</em>  and  <em>v2[:N]</em>   (arrays  <em>v1</em>  and  <em>v2</em>  in the Fortran code) into a device data environment.</p>
<p>The task executing on the host device encounters the first <strong>target</strong> region  and waits for the completion of the region.</p>
<p>After the execution of the first <strong>target</strong> region, the task executing on  the host device then assigns new values to  <em>v1[:N]</em>  and  <em>v2[:N]</em>  ( <em>v1</em>  and  <em>v2</em>  arrays  in Fortran code) in the task’s data environment by calling the function <strong>init_again()</strong>.</p>
<p>The <strong>target</strong> <strong>update</strong> construct assigns the new values of  <em>v1</em>  and   <em>v2</em>  from the task’s data environment to the corresponding mapped array sections  in the device data environment of the <strong>target</strong> <strong>data</strong> construct.</p>
<p>The task executing on the host device then encounters the second <strong>target</strong>  region and waits for the completion of the region.</p>
<p>The second <strong>target</strong> region uses the updated values of  <em>v1[:N]</em>  and  <em>v2[:N]</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_update.1
* type: C
* version: omp_4.0
*/
extern void init(float *, float *, int);
extern void init_again(float *, float *, int);
extern void output(float *, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target data map(to: v1[:N], v2[:N]) map(from: p[0:N])
   {
      #pragma omp target
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
 p[i] = v1[i] * v2[i];
      init_again(v1, v2, N);
      #pragma omp target update to(v1[:N], v2[:N])
      #pragma omp target
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
 p[i] = p[i] + (v1[i] * v2[i]);
   }
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_update.1
! type: F-free
! version:     omp_4.0
subroutine vec_mult(p, v1, v2, N)
   real    ::  p(N), v1(N), v2(N)
   integer ::  i
   call init(v1, v2, N)
   !$omp target data map(to: v1, v2) map(from: p)
      !$omp target
      !$omp parallel do
         do i=1,N
            p(i) = v1(i) * v2(i)
         end do
      !$omp end target
      call init_again(v1, v2, N)
      !$omp target update to(v1, v2)
      !$omp target
      !$omp parallel do
         do i=1,N
            p(i) = p(i) + v1(i) * v2(i)
         end do
      !$omp end target
   !$omp end target data
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-update-construct-with-if-clause">
<h3><strong>target</strong> <strong>update</strong> Construct with <strong>if</strong> Clause<a class="headerlink" href="#target-update-construct-with-if-clause" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>update</strong> construct updates  variables in a device data environment.</p>
<p>The <strong>target</strong> <strong>data</strong> construct maps array sections  <em>v1[:N]</em>  and  <em>v2[:N]</em>   (arrays  <em>v1</em>  and  <em>v2</em>  in the Fortran code) into a device data environment. In between  the two <strong>target</strong> regions, the task executing on the host device conditionally  assigns new values to  <em>v1</em>  and  <em>v2</em>  in the task’s data environment. The function <strong>maybe_init_again()</strong>  returns  <em>true</em>  if new data is written.</p>
<p>When the conditional expression (the return value of <strong>maybe_init_again()</strong>) in the  <strong>if</strong> clause is  <em>true</em> , the <strong>target</strong> <strong>update</strong> construct  assigns the new values of  <em>v1</em>  and  <em>v2</em>  from the task’s data environment to the corresponding  mapped array sections in the <strong>target</strong> <strong>data</strong> construct’s device data  environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: target_update.2
* type: C
* version: omp_4.0
*/
extern void init(float *, float *, int);
extern int maybe_init_again(float *, int);
extern void output(float *, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target data map(to: v1[:N], v2[:N]) map(from: p[0:N])
   {
      int changed;
      #pragma omp target
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
        p[i] = v1[i] * v2[i];
      changed = maybe_init_again(v1,  N);
      #pragma omp target update if (changed) to(v1[:N])
      changed = maybe_init_again(v2,  N);
      #pragma omp target update if (changed) to(v2[:N])
      #pragma omp target
      #pragma omp parallel for
      for (i=0; i&lt;N; i++)
        p[i] = p[i] + (v1[i] * v2[i]);
   }
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: target_update.2
! type: F-free
! version:     omp_4.0
subroutine vec_mult(p, v1, v2, N)
   interface
      logical function maybe_init_again (v1, N)
      real :: v1(N)
      integer :: N
      end function
   end interface
   real    ::  p(N), v1(N), v2(N)
   integer ::  i
   logical :: changed
   call init(v1, v2, N)
   !$omp target data map(to: v1, v2) map(from: p)
      !$omp target
         !$omp parallel do
         do i=1, N
            p(i) = v1(i) * v2(i)
         end do
      !$omp end target
      changed = maybe_init_again(v1, N)
      !$omp target update if(changed) to(v1(:N))
      changed = maybe_init_again(v2, N)
      !$omp target update if(changed) to(v2(:N))
      !$omp target
         !$omp parallel do
         do i=1, N
            p(i) = p(i) + v1(i) * v2(i)
         end do
      !$omp end target
   !$omp end target data
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="declare-target-directive">
<h2>Declare Target Directive<a class="headerlink" href="#declare-target-directive" title="Permalink to this headline">#</a></h2>
<section id="declare-target-directive-for-a-procedure">
<h3>Declare Target Directive for a Procedure<a class="headerlink" href="#declare-target-directive-for-a-procedure" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the declare target directive  is used to indicate that the corresponding call inside a <strong>target</strong> region  is to a <strong>fib</strong> function that can execute on the default target device.</p>
<p>A version of the function is also available on the host device. When the <strong>if</strong>  clause conditional expression on the <strong>target</strong> construct evaluates to  <em>false</em> ,  the <strong>target</strong> region (thus <strong>fib</strong>) will execute on the host device.</p>
<p>For the following C/C++ code the declaration of the function <strong>fib</strong> appears between the  <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong> directives.  In the corresponding Fortran code, the <strong>declare</strong> <strong>target</strong> directive appears at the end of the specification part of the subroutine.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: declare_target.1
* type: C
* version: omp_5.1
*/
#pragma omp begin declare target
extern void fib(int N);
#pragma omp end declare target

#define THRESHOLD 1000000
void fib_wrapper(int n)
{
   #pragma omp target if(n &gt; THRESHOLD)
   {
      fib(n);
   }
}
</pre></div>
</div>
</div>
</div>
<p>The Fortran <strong>fib</strong> subroutine contains a <strong>declare</strong> <strong>target</strong> declaration  to indicate to the compiler to create an device executable version of the procedure.  The subroutine name has not been included on the <strong>declare</strong> <strong>target</strong>  directive and is, therefore, implicitly assumed.</p>
<p>The program uses the <strong>module_fib</strong> module, which presents an explicit interface to  the compiler with the <strong>declare</strong> <strong>target</strong> declarations for processing  the <strong>fib</strong> call.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: declare_target.1
! type: F-free
! version: omp_4.0
module module_fib
contains
   subroutine fib(N)
      integer :: N
      !$omp declare target
      !...
   end subroutine
end module
module params
integer :: THRESHOLD=1000000
end module
program my_fib
use params
use module_fib
   !$omp target if( N &gt; THRESHOLD )
      call fib(N)
   !$omp end target
end program
</pre></div>
</div>
</div>
</div>
<p>The next Fortran example shows the use of an external subroutine. As the subroutine is neither use associated nor an internal procedure, the <strong>declare</strong> <strong>target</strong> declarations within a external subroutine are unknown to the main program unit;  therefore, a <strong>declare</strong> <strong>target</strong> must be provided within the program scope for the compiler to determine that a target binary should be available.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: declare_target.2
! type: F-free
! version: omp_4.0
program my_fib
integer :: N = 8
interface
  subroutine fib(N)
    !$omp declare target
    integer :: N
  end subroutine fib
end interface
   !$omp target
      call fib(N)
   !$omp end target
end program
subroutine fib(N)
integer :: N
!$omp declare target
     print*,&quot;hello from fib&quot;
     !...
end subroutine
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-target-directive-for-class-type">
<h3>Declare Target Directive for Class Type<a class="headerlink" href="#declare-target-directive-for-class-type" title="Permalink to this headline">#</a></h3>
<p>The following example shows the use of the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong> pair to designate the beginning and end of the affected declarations, as introduced in OpenMP 5.1. The <strong>begin</strong> <strong>declare</strong> <strong>target</strong> directive was defined to symmetrically complement the terminating (“end’’) directive.</p>
<p>The example also shows 3 different ways to use a declare target directive for a  class and an external member-function definition (for the  <em>XOR1</em> ,  <em>XOR2</em> ,  and  <em>XOR3</em>  classes and definitions for their corresponding  <em>foo</em>  member functions).</p>
<p>For  <em>XOR1</em> , a <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and  <strong>end</strong> <strong>declare</strong> <strong>target</strong> directive enclose both the class and its member function definition. The compiler immediately knows to create a device version of the function for execution in a <strong>target</strong> region.</p>
<p>For  <em>XOR2</em> , the class member function definition is not specified with a declare target directive. An implicit declare target is created for the member function definition. The same applies if this declaration arrangement for the class and function  are included through a header file.</p>
<p>For  <em>XOR3</em> , the class and its member function are not enclosed by <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong> directives, but there is an implicit declare target since the class, its function and the <strong>target</strong> construct are in the same file scope. That is, the class and its function are treated as if delimited by a declare target directive. The same applies if the class and function are included through a header file.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       declare_target.2a
* type:       C++
* version:    omp_5.1
*/
#include &lt;iostream&gt;
using namespace std;

  #pragma omp begin declare target // declare target--class and function
  class XOR1
  {
      int a;
    public:
      XOR1(int arg): a(arg) {};
      int foo();
  }
  int XOR1::foo() { return a^0x01;}
  #pragma omp end declare target

  #pragma omp begin declare target // declare target--class, not function
  class XOR2
  {
      int a;
    public:
      XOR2(int arg): a(arg) {};
      int foo();
  };
  #pragma omp end declare target

  int XOR2::foo() { return a^0x01;}

  class XOR3                // declare target--neither class nor function
  {
      int a;
    public:
      XOR3(int arg): a(arg) {};
      int foo();
  };
  int XOR3::foo() { return a^0x01;}

int main (){

    XOR1 my_XOR1(3);
    XOR2 my_XOR2(3);
    XOR3 my_XOR3(3);
    int res1, res2, res3;

    #pragma omp target map(tofrom:res1)
    res1=my_XOR1.foo();

    #pragma omp target map(tofrom:res2)
    res2=my_XOR2.foo();

    #pragma omp target map(tofrom:res3)
    res3=my_XOR3.foo();

    cout &lt;&lt; res1 &lt;&lt; endl;  // OUT1: 2
    cout &lt;&lt; res2 &lt;&lt; endl;  // OUT2: 2
    cout &lt;&lt; res3 &lt;&lt; endl;  // OUT3: 2
}
</pre></div>
</div>
</div>
</div>
<p>Often class definitions and their function definitions are included in separate files, as shown in  <em>declare_target.2b_classes.hpp</em>  and  <em>declare_target.2b_functions.cpp</em>  below. In this case, it is necessary to specify in a declare target directive for the classes. However, as long as the  <em>2b_functions.cpp</em>  file includes the corresponding declare target classes, there is no need to specify the functions with a declare target directive. The functions are treated as if they are specified with a declare target directive. Compiling the  <em>declare_target.2b_functions.cpp</em>  and  <em>declare_target.2b_main.cpp</em>  files  separately and linking them, will create appropriate executable device functions for the target device.</p>
<p>\srcnexample[5.1]{declare_target}{2b_classes}{hpp}</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

 #pragma omp begin declare target
 class XOR1
 {    
     int a;
   public:
     XOR1(int arg): a(arg) {};
     int foo();
 };
 #pragma omp end declare target
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* @@name:       declare_target.2b_functions
* @@type:       C++
* @@compilable: yes
* @@linkable:   no
* @@expect:     failure
* @@version:    omp_5.1
*/
#include &quot;classes.hpp&quot;
int XOR1::foo() { return a^0x01;}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       declare_target.2b_main
* type:       C++
* version:    omp_5.1
*/
#include &lt;iostream&gt;
using namespace std;

#include &quot;classes.hpp&quot;

int main (){

   XOR1 my_XOR1(3);
   int res1;

   #pragma omp target map(from: res1)
   res1=my_XOR1.foo();

   cout &lt;&lt; res1 &lt;&lt; endl;  // OUT1: 2
}

</pre></div>
</div>
</div>
</div>
<p>The following example shows how the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong>  <strong>declare</strong> <strong>target</strong> directives are used to enclose the declaration  of a variable  <em>varY</em>  with a class type <strong>typeY</strong>.</p>
<p>This example shows pre-OpenMP 5.0 behavior for the  <em>varY.foo()</em>  function call (an error). The member function <strong>typeY::foo()</strong> cannot be accessed on a target device because its  declaration does not appear between <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and  <strong>end</strong> <strong>declare</strong> <strong>target</strong> directives. As of OpenMP 5.0, the function is implicitly declared with a declare target directive  and will successfully execute the function on the device.  See previous examples.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: declare_target.2c
* type: C++
* version: omp_5.2
*/
struct typeX
{
   int a;
};
class typeY
{
   int a;
  public:
   int foo() { return a^0x01;}
};

#pragma omp begin declare target
  struct typeX varX;  // ok
  class typeY varY; // ok if varY.foo() not called on target device
#pragma omp end declare target

void foo()
{
   #pragma omp target
   {
      varX.a = 100; // ok
      varY.foo(); // error foo() is not available on a target device
   }
}
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-target-directive-for-variables">
<h3>Declare Target Directive for Variables<a class="headerlink" href="#declare-target-directive-for-variables" title="Permalink to this headline">#</a></h3>
<p>The following examples show how the declare target directive is used to indicate that global variables are mapped to the implicit device data environment of each target device.</p>
<p>In the following example, the declarations of the variables  <em>p</em> ,  <em>v1</em> , and  <em>v2</em>  appear  between <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong>  directives indicating that the variables are mapped to the implicit device data  environment of each target device. The <strong>target</strong> <strong>update</strong> directive  is then used to manage the consistency of the variables  <em>p</em> ,  <em>v1</em> , and  <em>v2</em>  between the  data environment of the encountering host device task and the implicit device data  environment of the default target device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: declare_target.3
* type: C
* version: omp_5.1
*/
#define N 1000

#pragma omp begin declare target
float p[N], v1[N], v2[N];
#pragma omp end declare target

extern void init(float *, float *, int);
extern void output(float *, int);

void vec_mult()
{
   int i;
   init(v1, v2, N);
   #pragma omp target update to(v1, v2)
   #pragma omp target
   #pragma omp parallel for
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
   #pragma omp target update from(p)
   output(p, N);
}
</pre></div>
</div>
</div>
</div>
<p>The Fortran version of the above C code uses a different syntax. Fortran modules  use a list syntax on the <strong>declare</strong> <strong>target</strong> directive to declare  mapped variables.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: declare_target.3
! type: F-free
! version: omp_4.0
module my_arrays
!$omp declare target (N, p, v1, v2)
integer, parameter :: N=1000
real               :: p(N), v1(N), v2(N)
end module
subroutine vec_mult()
use my_arrays
   integer :: i
   call init(v1, v2, N);
   !$omp target update to(v1, v2)
   !$omp target
   !$omp parallel do
   do i = 1,N
     p(i) = v1(i) * v2(i)
   end do
   !$omp end target
   !$omp target update from (p)
   call output(p, N)
end subroutine
</pre></div>
</div>
</div>
</div>
<p>The following example also indicates that the function  <em>Pfun()</em>  is available on the  target device, as well as the variable  <em>Q</em> , which is mapped to the implicit device  data environment of each target device. The <strong>target</strong> <strong>update</strong> directive  is then used to manage the consistency of the variable  <em>Q</em>  between the data environment  of the encountering host device task and the implicit device data environment of  the default target device.</p>
<p>In the following example, the function and variable declarations appear between  the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong>  directives.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: declare_target.4
* type: C
* version: omp_5.1
*/
#define N 10000

#pragma omp begin declare target
  float Q[N][N];
  float Pfun(const int i, const int k) { return Q[i][k] * Q[k][i]; }
#pragma omp end declare target

float accum(int k)
{
    float tmp = 0.0;
    #pragma omp target update to(Q)
    #pragma omp target map(tofrom: tmp)
    #pragma omp parallel for reduction(+:tmp)
    for(int i=0; i &lt; N; i++)
        tmp += Pfun(i,k);
    return tmp;
}

/* Note:  The variable tmp is now mapped with tofrom, for correct
          execution with 4.5 (and pre-4.5) compliant compilers.
          See Devices Intro.
 */
</pre></div>
</div>
</div>
</div>
<p>The Fortran version of the above C code uses a different syntax. In Fortran modules  a list syntax on the <strong>declare</strong> <strong>target</strong> directive is used to declare  mapped variables and procedures. The  <em>N</em>  and  <em>Q</em>  variables are declared as a comma  separated list. When the <strong>declare</strong> <strong>target</strong> directive is used to  declare just the procedure, the procedure name need not be listed – it is implicitly  assumed, as illustrated in the  <em>Pfun()</em>  function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: declare_target.4
! type: F-free
! version: omp_4.0
module my_global_array
!$omp declare target (N,Q)
integer, parameter :: N=10
real               :: Q(N,N)
contains
function Pfun(i,k)
!$omp declare target
real               :: Pfun
integer,intent(in) :: i,k
   Pfun=(Q(i,k) * Q(k,i))
end function
end module

function accum(k) result(tmp)
use my_global_array
real    :: tmp
integer :: i, k
   tmp = 0.0e0
   !$omp target map(tofrom: tmp)
   !$omp parallel do reduction(+:tmp)
   do i=1,N
      tmp = tmp + Pfun(k,i)
   end do
   !$omp end target
end function

! Note:  The variable tmp is now mapped with tofrom, for correct
! execution with 4.5 (and pre-4.5) compliant compilers. See Devices Intro.
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-target-directive-with-declare-simd">
<h3>Declare Target Directive with <strong>declare</strong> <strong>simd</strong><a class="headerlink" href="#declare-target-directive-with-declare-simd" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and  <strong>end</strong> <strong>declare</strong> <strong>target</strong> directives are used to indicate that a function  is available on a target device. The <strong>declare</strong> <strong>simd</strong> directive indicates  that there is a SIMD version of the function  <em>P()</em>  that is available on the target  device as well as one that is available on the host device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: declare_target.5
* type: C
* version: omp_5.1
*/
#define N 10000
#define M 1024

#pragma omp begin declare target
float Q[N][N];

#pragma omp declare simd uniform(i) linear(k) notinbranch
float P(const int i, const int k)
{
  return Q[i][k] * Q[k][i];
}
#pragma omp end declare target

float accum(void)
{
  float tmp = 0.0;
  int i, k;
#pragma omp target map(tofrom: tmp)
#pragma omp parallel for reduction(+:tmp)
  for (i=0; i &lt; N; i++) {
    float tmp1 = 0.0;
#pragma omp simd reduction(+:tmp1)
    for (k=0; k &lt; M; k++) {
      tmp1 += P(i,k);
    }
    tmp += tmp1;
  }
  return tmp;
}

/* Note:  The variable tmp is now mapped with tofrom, for correct
          execution with 4.5 (and pre-4.5) compliant compilers.
          See Devices Intro.
 */
</pre></div>
</div>
</div>
</div>
<p>The Fortran version of the above C code uses a different syntax. Fortran modules  use a list syntax of the <strong>declare</strong> <strong>target</strong> declaration for the mapping.  Here the  <em>N</em>  and  <em>Q</em>  variables are declared in the list form as a comma separated list.  The function declaration does not use a list and implicitly assumes the function  name. In this Fortran example row and column indices are reversed relative to the  C/C++ example, as is usual for codes optimized for memory access.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: declare_target.5
! type: F-free
! version: omp_4.0
module my_global_array
!$omp declare target (N,Q)
integer, parameter :: N=10000, M=1024
real               :: Q(N,N)
contains
function P(k,i)
!$omp declare simd uniform(i) linear(k) notinbranch
!$omp declare target
real               :: P
integer,intent(in) :: k,i
   P=(Q(k,i) * Q(i,k))
end function
end module

function accum() result(tmp)
use my_global_array
real    :: tmp, tmp1
integer :: i
   tmp = 0.0e0
   !$omp target map(tofrom: tmp)
   !$omp parallel do private(tmp1) reduction(+:tmp)
   do i=1,N
      tmp1 = 0.0e0
      !$omp simd reduction(+:tmp1)
      do k = 1,M
         tmp1 = tmp1 + P(k,i)
      end do
      tmp = tmp + tmp1
   end do
   !$omp end target
end function

! Note:  The variable tmp is now mapped with tofrom, for correct
! execution with 4.5 (and pre-4.5) compliant compilers. See Devices Intro.
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-target-directive-with-link-clause">
<h3>Declare Target Directive with <strong>link</strong> Clause<a class="headerlink" href="#declare-target-directive-with-link-clause" title="Permalink to this headline">#</a></h3>
<p>In the OpenMP 4.5 standard the declare target directive was extended to allow static data to be mapped, <em>when needed</em>, through a <strong>link</strong> clause.</p>
<p>Data storage for items listed in the <strong>link</strong> clause becomes available on the device when it is mapped implicitly or explicitly in a <strong>map</strong> clause, and it persists for the scope of the mapping (as specified by a <strong>target</strong> construct,  a <strong>target</strong> <strong>data</strong> construct, or  <strong>target</strong> <strong>enter/exit</strong> <strong>data</strong> constructs).</p>
<p>Tip: When all the global data items will not fit on a device and are not needed simultaneously, use the <strong>link</strong> clause and map the data only when it is needed.</p>
<p>The following C and Fortran examples show two sets of data (single precision and double precision) that are global on the host for the entire execution on the host; but are only used globally on the device for part of the program execution. The single precision data are allocated and persist only for the first <strong>target</strong> region. Similarly, the double precision data are in scope on the device only for the second <strong>target</strong> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: declare_target.6
* type: C
* version: omp_5.1
*/
#define N 100000000

float  sp[N], sv1[N], sv2[N];
double dp[N], dv1[N], dv2[N];
#pragma omp declare target link(sp,sv1,sv2) \
                           link(dp,dv1,dv2)

void s_init(float *, float *, int);
void d_init(double *, double *, int);
void s_output(float *, int);
void d_output(double *, int);

#pragma omp begin declare target

void s_vec_mult_accum()
{
   int i;

   #pragma omp parallel for
   for (i=0; i&lt;N; i++)
     sp[i] = sv1[i] * sv2[i];
}

void d_vec_mult_accum()
{
   int i;

   #pragma omp parallel for
   for (i=0; i&lt;N; i++)
     dp[i] = dv1[i] * dv2[i];
}
#pragma omp end declare target

int main()
{
   s_init(sv1, sv2, N);
   #pragma omp target map(to:sv1,sv2) map(from:sp)
      s_vec_mult_accum();
   s_output(sp, N);

   d_init(dv1, dv2, N);
   #pragma omp target map(to:dv1,dv2) map(from:dp)
      d_vec_mult_accum();
   d_output(dp, N);

  return 0;
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: declare_target.6
! type: F-free
! version: omp_4.5
module m_dat
   integer, parameter :: N=100000000
   !$omp declare target link(sp,sv1,sv2)
   real :: sp(N), sv1(N), sv2(N)

   !$omp declare target link(dp,dv1,dv2)
   double precision :: dp(N), dv1(N), dv2(N)

contains
   subroutine s_vec_mult_accum()
   !$omp declare target
      integer :: i

      !$omp parallel do
      do i = 1,N
        sp(i) = sv1(i) * sv2(i)
      end do

   end subroutine s_vec_mult_accum

   subroutine d_vec_mult_accum()
   !$omp declare target
      integer :: i

      !$omp parallel do
      do i = 1,N
        dp(i) = dv1(i) * dv2(i)
      end do

   end subroutine
end module m_dat

program prec_vec_mult
   use m_dat

   call s_init(sv1, sv2, N)
   !$omp target map(to:sv1,sv2) map(from:sp)
     call s_vec_mult_accum()
   !$omp end target
   call s_output(sp, N)

   call d_init(dv1, dv2, N)
   !$omp target map(to:dv1,dv2) map(from:dp)
     call d_vec_mult_accum()
   !$omp end target
   call d_output(dp, N)

end program
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="lambda-expressions">
<h2>Lambda Expressions<a class="headerlink" href="#lambda-expressions" title="Permalink to this headline">#</a></h2>
<p>The following example illustrates the usage of lambda expressions and their corresponding closure objects within a <strong>target</strong> region.</p>
<p>In CASE 1, a lambda expression is defined inside a <strong>target</strong> construct that implicitly maps the structure 	extit{s}. Inside the construct, the lambda captures (by reference) the corresponding <em>s</em>, and the resulting closure object is assigned to <em>lambda1</em>.  When the call operator is invoked on <em>lambda1</em>, the captured reference to <em>s</em> is used in the call.  The modified <em>s</em> is then copied back to the host device on exit from the <strong>target</strong> construct.</p>
<p>In CASE 2, a lambda expression is instead defined before the <strong>target</strong> construct and captures (by copy) the pointer <em>sp</em>. A <strong>target</strong> <strong>data</strong> construct is used to first map the structure, and then the <strong>target</strong> construct implicitly maps the closure object referenced by <em>lambda2</em>, a zero-length array section based on the structure pointer <em>sp</em>, and a zero-length array section based on the captured pointer in the closure object. The implicit maps result in attached pointers to the corresponding structure. The call for <em>lambda2</em> inside the <strong>target</strong> construct will access <em>sp-&gt;a</em> and <em>sp-&gt;b</em> from the corresponding structure.</p>
<p>CASE 3 is similar to CASE 2, except <em>s</em> is instead captured by reference by the lambda expression. As for CASE 2, the structure is first mapped by an enclosing <strong>target</strong> <strong>data</strong> construct, and then the <strong>target</strong> construct implicitly maps <em>s</em> and the closure object referenced by <em>lambda3</em>. The effect of the map is to make the the call for <em>lambda3</em> refer to the corresponding <em>s</em> inside the <strong>target</strong> construct rather than the original <em>s</em>.</p>
<p>In CASE 4, the program defines a static variable <em>ss</em> of the same structure type as <em>s</em>. While the body of the lambda expression refers to <em>ss</em>, it is not captured. In order for <em>lambda4</em> to be callable in the <strong>target</strong> region, the reference to <em>ss</em> should be to a device copy of <em>ss</em> that also has static storage. This is achieved with the use of the <strong>declare</strong> <strong>target</strong> directive.  Inside the <strong>target</strong> construct, all references to <em>ss</em>, including in the <em>lambda4()</em> call, will refer to the corresponding <em>ss</em> that results from the <strong>declare</strong> <strong>target</strong> directive. The <strong>always</strong> modifier is used on the <strong>map</strong> clause to transfer the updated values for the structure back to the host device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name:       lambda_expressions.1
* type:       C++
* version:   omp_5.0
*/
#include &lt;iostream&gt;
using namespace std;

struct S { int a; int b; };

int main()
{

// CASE 1 Lambda defined in target region

   S s = S {0,1};

   #pragma omp target
   {
      auto lambda1 = [&amp;s]() { s.a = s.b * 2; };
      s.b += 2;
      lambda1(); // s.a = 3 * 2
   }
   cout &lt;&lt; s.a &lt;&lt; &quot; &quot; &lt;&lt; s.b &lt;&lt; endl; //OUT 6 3

// CASE 2 Host defined lambda, Capture pointer to s

   s = {0,1};
   S *sp = &amp;s;
   auto lambda2 = [sp]() {sp-&gt;a = sp-&gt;b * 2; };

   // closure object&#39;s sp attaches to corresponding s on target
   // construct
   #pragma omp target data map(sp[0])
   #pragma omp target
   {
      sp-&gt;b += 2;
      lambda2();
   }
   cout &lt;&lt; s.a &lt;&lt; &quot; &quot; &lt;&lt; s.b &lt;&lt; endl; //OUT 6 3

// CASE 3 Host defined lambda, Capture s by reference

   s = {0,1};
   auto lambda3 = [&amp;s]() {s.a = s.b * 2; };

   // closure object&#39;s s refers to corresponding s in target
   // construct
   #pragma omp target data map(s)
   #pragma omp target
   {
      s.b += 2;
      lambda3();
   }
   cout &lt;&lt; s.a &lt;&lt; &quot; &quot; &lt;&lt; s.b &lt;&lt; endl; //OUT 6 3

// CASE 4 Host defined lambda, references static variable

   static S ss = {0,1};
   #pragma omp declare target enter(ss)
   auto lambda4 = [&amp;]() {ss.a = ss.b * 2; };

   #pragma omp target map(always,from:ss)
   {
      ss.b += 2;
      lambda4();
   }
   cout &lt;&lt; ss.a &lt;&lt; &quot; &quot; &lt;&lt; ss.b &lt;&lt; endl; //OUT 6 3

   return 0;
}
</pre></div>
</div>
</div>
</div>
</section>
<section id="teams-construct-and-related-combined-constructs">
<h2><strong>teams</strong> Construct and Related Combined Constructs<a class="headerlink" href="#teams-construct-and-related-combined-constructs" title="Permalink to this headline">#</a></h2>
<section id="target-and-teams-constructs-with-omp-get-num-teams-and-omp-get-team-num-routines">
<h3><strong>target</strong> and <strong>teams</strong> Constructs with <strong>omp_get_num_teams</strong> and <strong>omp_get_team_num</strong> Routines<a class="headerlink" href="#target-and-teams-constructs-with-omp-get-num-teams-and-omp-get-team-num-routines" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> and <strong>teams</strong> constructs  are used to create a league of thread teams that execute a region. The <strong>teams</strong>  construct creates a league of at most two teams where the primary thread of each  team executes the <strong>teams</strong> region.</p>
<p>The <strong>omp_get_num_teams</strong> routine returns the number of teams executing in a <strong>teams</strong>  region. The <strong>omp_get_team_num</strong> routine returns the team number, which is an integer  between 0 and one less than the value returned by <strong>omp_get_num_teams</strong>. The following  example manually distributes a loop across two teams.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: teams.1
* type: C
* version: omp_4.0
*/
#include &lt;stdlib.h&gt;
#include &lt;omp.h&gt;
float dotprod(float B[], float C[], int N)
{
   float sum0 = 0.0;
   float sum1 = 0.0;
   #pragma omp target map(to: B[:N], C[:N]) map(tofrom: sum0, sum1)
   #pragma omp teams num_teams(2)
   {
      int i;
      if (omp_get_num_teams() != 2)
         abort();
      if (omp_get_team_num() == 0)
      {
  #pragma omp parallel for reduction(+:sum0)
  for (i=0; i&lt;N/2; i++)
     sum0 += B[i] * C[i];
      }
      else if (omp_get_team_num() == 1)
      {
  #pragma omp parallel for reduction(+:sum1)
  for (i=N/2; i&lt;N; i++)
     sum1 += B[i] * C[i];
      }
   }
   return sum0 + sum1;
}

/* Note:  The variables sum0,sum1 are now mapped with tofrom, for
          correct execution with 4.5 (and pre-4.5) compliant compilers.
          See Devices Intro.
 */
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: teams.1
! type: F-free
! version:    omp_4.0
function dotprod(B,C,N) result(sum)
use omp_lib, ONLY : omp_get_num_teams, omp_get_team_num
    real    :: B(N), C(N), sum,sum0, sum1
    integer :: N, i
    sum0 = 0.0e0
    sum1 = 0.0e0
    !$omp target map(to: B, C) map(tofrom: sum0, sum1)
    !$omp teams num_teams(2)
      if (omp_get_num_teams() /= 2) stop &quot;2 teams required&quot;
      if (omp_get_team_num() == 0) then
         !$omp parallel do reduction(+:sum0)
         do i=1,N/2
            sum0 = sum0 + B(i) * C(i)
         end do
      else if (omp_get_team_num() == 1) then
         !$omp parallel do reduction(+:sum1)
         do i=N/2+1,N
            sum1 = sum1 + B(i) * C(i)
         end do
      end if
    !$omp end teams
    !$omp end target
    sum = sum0 + sum1
end function

! Note:  The variables sum0,sum1 are now mapped with tofrom, for correct
! execution with 4.5 (and pre-4.5) compliant compilers. See Devices Intro.
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-constructs">
<h3><strong>target</strong>, <strong>teams</strong>, and <strong>distribute</strong> Constructs<a class="headerlink" href="#target-teams-and-distribute-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong>, <strong>teams</strong>, and <strong>distribute</strong>  constructs are used to execute a loop nest in a <strong>target</strong> region. The <strong>teams</strong>  construct creates a league and the primary thread of each team executes the <strong>teams</strong>  region. The <strong>distribute</strong> construct schedules the subsequent loop iterations  across the primary threads of each team.</p>
<p>The number of teams in the league is less than or equal to the variable  <em>num_blocks</em> .  Each team in the league has a number of threads less than or equal to the variable   <em>block_threads</em> . The iterations in the outer loop are distributed among the primary  threads of each team.</p>
<p>When a team’s primary thread encounters the parallel loop construct before the inner  loop, the other threads in its team are activated. The team executes the <strong>parallel</strong>  region and then workshares the execution of the loop.</p>
<p><strong>reduction clause <strong>reduction</strong> clause!on teams construct on <strong>teams</strong> construct</strong> Each primary thread executing the <strong>teams</strong> region has a private copy of the  variable  <em>sum</em>  that is created by the <strong>reduction</strong> clause on the <strong>teams</strong> construct.  The primary thread and all threads in its team have a private copy of the variable   <em>sum</em>  that is created by the <strong>reduction</strong> clause on the parallel loop construct.  The second private  <em>sum</em>  is reduced into the primary thread’s private copy of  <em>sum</em>   created by the <strong>teams</strong> construct. At the end of the <strong>teams</strong> region,  each primary thread’s private copy of  <em>sum</em>  is reduced into the final  <em>sum</em>  that is  implicitly mapped into the <strong>target</strong> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: teams.2
* type: C
* version: omp_4.0
*/
#define min(x, y) (((x) &lt; (y)) ? (x) : (y))

float dotprod(float B[], float C[], int N, int block_size,
  int num_teams, int block_threads)
{
    float sum = 0.0;
    int i, i0;
    #pragma omp target map(to: B[0:N], C[0:N]) map(tofrom: sum)
    #pragma omp teams num_teams(num_teams) thread_limit(block_threads) \
      reduction(+:sum)
    #pragma omp distribute
    for (i0=0; i0&lt;N; i0 += block_size)
       #pragma omp parallel for reduction(+:sum)
       for (i=i0; i&lt; min(i0+block_size,N); i++)
           sum += B[i] * C[i];
    return sum;
}
/* Note:  The variable sum is now mapped with tofrom, for correct
   execution with 4.5 (and pre-4.5) compliant compilers. See
   Devices Intro.
 */
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name: teams.2
! type: F-free
! version: omp_4.0
function dotprod(B,C,N, block_size, num_teams, block_threads) result(sum)
implicit none
    real    :: B(N), C(N), sum
    integer :: N, block_size, num_teams, block_threads, i, i0
    sum = 0.0e0
    !$omp target map(to: B, C) map(tofrom: sum)
    !$omp teams num_teams(num_teams) thread_limit(block_threads) &amp;
    !$omp&amp;  reduction(+:sum)
    !$omp distribute
       do i0=1,N, block_size
          !$omp parallel do reduction(+:sum)
          do i = i0, min(i0+block_size,N)
             sum = sum + B(i) * C(i)
          end do
       end do
    !$omp end teams
    !$omp end target
end function

! Note:  The variable sum is now mapped with tofrom, for correct
! execution with 4.5 (and pre-4.5) compliant compilers. See Devices Intro.
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-parallel-loop-constructs">
<h3><strong>target</strong> <strong>teams</strong>, and Distribute Parallel Loop Constructs<a class="headerlink" href="#target-teams-and-distribute-parallel-loop-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>teams</strong> and distribute  parallel loop constructs are used to execute a <strong>target</strong> region. The <strong>target</strong>  <strong>teams</strong> construct creates a league of teams where the primary thread of each  team executes the <strong>teams</strong> region.</p>
<p>The distribute parallel loop construct schedules the loop iterations across the  primary threads of each team and then across the threads of each team.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: teams.3
* type: C
* version: omp_4.5
*/
float dotprod(float B[], float C[], int N)
{
   float sum = 0;
   int i;
   #pragma omp target teams map(to: B[0:N], C[0:N]) \
                            defaultmap(tofrom:scalar) reduction(+:sum)
   #pragma omp distribute parallel for reduction(+:sum)
   for (i=0; i&lt;N; i++)
      sum += B[i] * C[i];
   return sum;
}

/* Note:  The variable sum is now mapped with tofrom from the defaultmap
          clause on the combined target teams construct, for correct
          execution with 4.5 (and pre-4.5) compliant compilers.
          See Devices Intro.
 */
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: teams.3
! type: F-free
! version: omp_4.5
function dotprod(B,C,N) result(sum)
   real    :: B(N), C(N), sum
   integer :: N, i
   sum = 0.0e0
   !$omp target teams map(to: B, C)  &amp;
   !$omp&amp;             defaultmap(tofrom:scalar) reduction(+:sum)
   !$omp distribute parallel do reduction(+:sum)
      do i = 1,N
         sum = sum + B(i) * C(i)
      end do
   !$omp end target teams
end function

! Note:  The variable sum is now mapped with tofrom from the defaultmap
!  clause on the combined target teams construct, for correct
!  execution with 4.5 (and pre-4.5) compliant compilers. See Devices Intro.

</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-parallel-loop-constructs-with-scheduling-clauses">
<h3><strong>target</strong> <strong>teams</strong> and Distribute Parallel Loop  Constructs with Scheduling Clauses<a class="headerlink" href="#target-teams-and-distribute-parallel-loop-constructs-with-scheduling-clauses" title="Permalink to this headline">#</a></h3>
<p><strong>distribute construct <strong>distribute</strong> construct!dist_schedule clause <strong>dist_schedule</strong> clause</strong> <strong>clauses!dist_schedule <strong>dist_schedule</strong></strong> <strong>dist_schedule clause <strong>dist_schedule</strong> clause</strong> <strong>worksharing-loop constructs!schedule clause <strong>schedule</strong> clause</strong> <strong>clauses!schedule <strong>schedule</strong></strong> <strong>schedule clause <strong>schedule</strong> clause</strong></p>
<p>The following example shows how the <strong>target</strong> <strong>teams</strong> and distribute  parallel loop constructs are used to execute a <strong>target</strong> region. The <strong>teams</strong>  construct creates a league of at most eight teams where the primary thread of each  team executes the <strong>teams</strong> region. The number of threads in each team is  less than or equal to 16.</p>
<p>The <strong>distribute</strong> parallel loop construct schedules the subsequent loop iterations  across the primary threads of each team and then across the threads of each team.</p>
<p>The <strong>dist_schedule</strong> clause on the distribute parallel loop construct indicates  that loop iterations are distributed to the primary thread of each team in chunks  of 1024 iterations.</p>
<p>The <strong>schedule</strong> clause indicates that the 1024 iterations distributed to  a primary thread are then assigned to the threads in its associated team in chunks  of 64 iterations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: teams.4
* type: C
* version: omp_4.0
*/
#define N 1024*1024
float dotprod(float B[], float C[])
{
    float sum = 0.0;
    int i;
    #pragma omp target map(to: B[0:N], C[0:N]) map(tofrom: sum)
    #pragma omp teams num_teams(8) thread_limit(16) reduction(+:sum)
    #pragma omp distribute parallel for reduction(+:sum) \
                dist_schedule(static, 1024) schedule(static, 64)
    for (i=0; i&lt;N; i++)
        sum += B[i] * C[i];
    return sum;
}

/* Note:  The variable sum is now mapped with tofrom, for correct
          execution with 4.5 (and pre-4.5) compliant compilers.
          See Devices Intro.
 */

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: teams.4
! type: F-free
! version: omp_4.0
module arrays
integer,parameter :: N=1024*1024
real :: B(N), C(N)
end module
function dotprod() result(sum)
use arrays
   real    :: sum
   integer :: i
   sum = 0.0e0
   !$omp target map(to: B, C) map(tofrom: sum)
   !$omp teams num_teams(8) thread_limit(16) reduction(+:sum)
   !$omp distribute parallel do reduction(+:sum) &amp;
   !$omp&amp;  dist_schedule(static, 1024) schedule(static, 64)
      do i = 1,N
         sum = sum + B(i) * C(i)
      end do
   !$omp end teams
   !$omp end target
end function

! Note:  The variable sum is now mapped with tofrom, for correct
! execution with 4.5 (and pre-4.5) compliant compilers. See Devices Intro.

</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-simd-constructs">
<h3><strong>target</strong> <strong>teams</strong> and <strong>distribute</strong> <strong>simd</strong> Constructs<a class="headerlink" href="#target-teams-and-distribute-simd-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>teams</strong> and <strong>distribute</strong>  <strong>simd</strong> constructs are used to execute a loop in a <strong>target</strong> region.  The <strong>target</strong> <strong>teams</strong> construct creates a league of teams where the  primary thread of each team executes the <strong>teams</strong> region.</p>
<p>The <strong>distribute</strong> <strong>simd</strong> construct schedules the loop iterations across  the primary thread of each team and then uses SIMD parallelism to execute the iterations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: teams.5
* type: C
* version: omp_4.0
*/
extern void init(float *, float *, int);
extern void output(float *, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target teams map(to: v1[0:N], v2[:N]) map(from: p[0:N])
   #pragma omp distribute simd
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
   output(p, N);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: teams.5
! type: F-free
! version: omp_4.0
subroutine vec_mult(p, v1, v2, N)
   real    ::  p(N), v1(N), v2(N)
   integer ::  i
   call init(v1, v2, N)
   !$omp target teams map(to: v1, v2) map(from: p)
      !$omp distribute simd
         do i=1,N
            p(i) = v1(i) * v2(i)
         end do
   !$omp end target teams
   call output(p, N)
end subroutine

</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-parallel-loop-simd-constructs">
<h3><strong>target</strong> <strong>teams</strong> and Distribute Parallel Loop SIMD Constructs<a class="headerlink" href="#target-teams-and-distribute-parallel-loop-simd-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>teams</strong> and the distribute  parallel loop SIMD constructs are used to execute a loop in a <strong>target</strong> <strong>teams</strong>  region. The <strong>target</strong> <strong>teams</strong> construct creates a league of teams  where the primary thread of each team executes the <strong>teams</strong> region.</p>
<p>The distribute parallel loop SIMD construct schedules the loop iterations across  the primary thread of each team and then across the threads of each team where each  thread uses SIMD parallelism.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: teams.6
* type: C
* version: omp_4.0
*/
extern void init(float *, float *, int);
extern void output(float *, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   #pragma omp target teams map(to: v1[0:N], v2[:N]) map(from: p[0:N])
   #pragma omp distribute parallel for simd
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
   output(p, N);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: teams.6
! type: F-free
! version: omp_4.0
subroutine vec_mult(p, v1, v2, N)
   real    ::  p(N), v1(N), v2(N)
   integer ::  i
   call init(v1, v2, N)
   !$omp target teams map(to: v1, v2) map(from: p)
      !$omp distribute parallel do simd
         do i=1,N
            p(i) = v1(i) * v2(i)
         end do
   !$omp end target teams
   call output(p, N)
end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../devices/teams.tex</p>
</section>
</section>
<section id="asynchronous-target-execution-and-dependences">
<h2>Asynchronous <strong>target</strong> Execution and Dependences<a class="headerlink" href="#asynchronous-target-execution-and-dependences" title="Permalink to this headline">#</a></h2>
<p>Asynchronous execution of a <strong>target</strong> region can be accomplished by creating an explicit task around the <strong>target</strong> region. Examples with explicit tasks are shown at the beginning of this section.</p>
<p>As of OpenMP 4.5 and beyond the <strong>nowait</strong> clause can be used on the <strong>target</strong> directive for asynchronous execution. Examples with  <strong>nowait</strong> clauses follow the explicit <strong>task</strong> examples.</p>
<p>This section also shows the use of <strong>depend</strong> clauses to order  executions through dependences. ../../devices/async_target_depend.tex</p>
<section id="asynchronous-target-with-tasks">
<h3>Asynchronous <strong>target</strong> with Tasks<a class="headerlink" href="#asynchronous-target-with-tasks" title="Permalink to this headline">#</a></h3>
<p><strong>target construct <strong>target</strong> construct</strong> <strong>task construct <strong>task</strong> construct</strong></p>
<p><strong>directives!declare target <strong>declare</strong> <strong>target</strong></strong> <strong>declare target directive <strong>declare</strong> <strong>target</strong> directive</strong></p>
<p><strong>directives!begin declare target <strong>begin</strong> <strong>declare</strong> <strong>target</strong></strong> <strong>begin declare target directive <strong>begin</strong> <strong>declare</strong> <strong>target</strong> directive</strong></p>
<p>The following example shows how the <strong>task</strong> and <strong>target</strong> constructs  are used to execute multiple <strong>target</strong> regions asynchronously. The task that  encounters the <strong>task</strong> construct generates an explicit task that contains  a <strong>target</strong> region. The thread executing the explicit task encounters a task  scheduling point while waiting for the execution of the <strong>target</strong> region  to complete, allowing the thread to switch back to the execution of the encountering  task or one of the previously generated explicit tasks.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: async_target.1
* type: C
* version: omp_5.1
*/
#pragma omp begin declare target
float F(float);
#pragma omp end declare target

#define N 1000000000
#define CHUNKSZ 1000000
void init(float *, int);
float Z[N];
void pipedF(){
   int C, i;
   init(Z, N);
   for (C=0; C&lt;N; C+=CHUNKSZ){
      #pragma omp task shared(Z)
      #pragma omp target map(Z[C:CHUNKSZ])
      #pragma omp parallel for
      for (i=0; i&lt;CHUNKSZ; i++) Z[i] = F(Z[i]);
   }
   #pragma omp taskwait
}

</pre></div>
</div>
</div>
</div>
<p><strong>directives!declare target <strong>declare</strong> <strong>target</strong></strong> <strong>declare target directive <strong>declare</strong> <strong>target</strong> directive</strong> The Fortran version has an interface block that contains the <strong>declare</strong> <strong>target</strong>.  An identical statement exists in the function declaration (not shown here).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: async_target.1
! type: F-free
! version: omp_4.0
module parameters
integer, parameter :: N=1000000000, CHUNKSZ=1000000
end module
subroutine pipedF()
use parameters, ONLY: N, CHUNKSZ
integer            :: C, i
real               :: z(N)

interface
   function F(z)
   !$omp declare target
     real, intent(IN) ::z
     real             ::F
   end function F
end interface

   call init(z,N)

   do C=1,N,CHUNKSZ

      !$omp task shared(z)
      !$omp target map(z(C:C+CHUNKSZ-1))
      !$omp parallel do
         do i=C,C+CHUNKSZ-1
            z(i) = F(z(i))
         end do
      !$omp end target
      !$omp end task

   end do
   !$omp taskwait
   print*, z

end subroutine pipedF

</pre></div>
</div>
</div>
</div>
<p>The following example shows how the <strong>task</strong> and <strong>target</strong> constructs  are used to execute multiple <strong>target</strong> regions asynchronously. The task dependence  ensures that the storage is allocated and initialized on the device before it is  accessed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: async_target.2
* type: C
* version: omp_5.1
*/
#include &lt;stdlib.h&gt;
#include &lt;omp.h&gt;

#pragma omp begin declare target
extern void init(float *, float *, int);
#pragma omp end declare target

extern void foo();
extern void output(float *, int);
void vec_mult(float *p, int N, int dev)
{
   float *v1, *v2;
   int i;
   #pragma omp task shared(v1, v2) depend(out: v1, v2)
   #pragma omp target device(dev) map(v1, v2)
   {
       // check whether on device dev
       if (omp_is_initial_device())
   abort();
       v1 = (float *)malloc(N*sizeof(float));
       v2 = (float *)malloc(N*sizeof(float));
       init(v1, v2, N);
   }
   foo(); // execute other work asychronously
   #pragma omp task shared(v1, v2, p) depend(in: v1, v2)
   #pragma omp target device(dev) map(to: v1, v2) map(from: p[0:N])
   {
       // check whether on device dev
       if (omp_is_initial_device())
   abort();
       #pragma omp parallel for
       for (i=0; i&lt;N; i++)
  p[i] = v1[i] * v2[i];
       free(v1);
       free(v2);
   }
   #pragma omp taskwait
   output(p, N);
}

</pre></div>
</div>
</div>
</div>
<p>The Fortran example below is similar to the C version above. Instead of pointers, though, it uses the convenience of Fortran allocatable arrays on the device. In order to preserve the arrays  allocated on the device across multiple <strong>target</strong> regions, a <strong>target</strong> <strong>data</strong> region  is used in this case.</p>
<p>If there is no shape specified for an allocatable array in a <strong>map</strong> clause, only the array descriptor (also called a dope vector) is mapped. That is, device space is created for the descriptor, and it is initially populated with host values. In this case, the  <em>v1</em>  and  <em>v2</em>  arrays will be in a non-associated state on the device. When space for  <em>v1</em>  and  <em>v2</em>  is allocated on the device in the first <strong>target</strong> region the addresses to the space will be included in their descriptors.</p>
<p>At the end of the first <strong>target</strong> region, the arrays  <em>v1</em>  and  <em>v2</em>  are preserved on the device  for access in the second <strong>target</strong> region. At the end of the second <strong>target</strong> region, the data  in array  <em>p</em>  is copied back, the arrays  <em>v1</em>  and  <em>v2</em>  are not.</p>
<p><strong>task construct <strong>task</strong> construct!depend clause <strong>depend</strong> clause</strong> <strong>clauses!depend <strong>depend</strong></strong> <strong>depend clause <strong>depend</strong> clause</strong> A <strong>depend</strong> clause is used in the <strong>task</strong> directive to provide a wait at the beginning of the second  <strong>target</strong> region, to insure that there is no race condition with  <em>v1</em>  and  <em>v2</em>  in the two tasks. It would be noncompliant to use  <em>v1</em>  and/or  <em>v2</em>  in lieu of  <em>N</em>  in the <strong>depend</strong> clauses,  because the use of non-allocated allocatable arrays as list items in a <strong>depend</strong> clause would  lead to unspecified behavior.</p>
<p>This example is not strictly compliant with the OpenMP 4.5 specification since the allocation status of allocatable arrays  <em>v1</em>  and  <em>v2</em>  is changed inside the <strong>target</strong> region, which is not allowed. (See the restrictions for the <strong>map</strong> clause in the  <em>Data-mapping Attribute Rules and Clauses</em>   section of the specification.) However, the intention is to relax the restrictions on mapping of allocatable variables in the next release of the specification so that the example will be compliant.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: async_target.2
! type: F-free
! version: omp_4.0
 subroutine mult(p,  N, idev)
   use omp_lib, ONLY: omp_is_initial_device
   real             :: p(N)
   real,allocatable :: v1(:), v2(:)
   integer ::  i, idev
   !$omp declare target (init)

   !$omp target data map(v1,v2)

   !$omp task shared(v1,v2) depend(out: N)
      !$omp target device(idev)
         if( omp_is_initial_device() ) &amp;
            stop &quot;not executing on target device&quot;
         allocate(v1(N), v2(N))
         call init(v1,v2,N)
      !$omp end target
   !$omp end task

   call foo()  ! execute other work asychronously

   !$omp task shared(v1,v2,p) depend(in: N)
      !$omp target device(idev) map(from: p)
         if( omp_is_initial_device() ) &amp;
            stop &quot;not executing on target device&quot;
         !$omp parallel do
            do i = 1,N
               p(i) = v1(i) * v2(i)
            end do
         deallocate(v1,v2)

      !$omp end target
   !$omp end task

   !$omp taskwait

   !$omp end target data

   call output(p, N)

end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../devices/async_target_with_tasks.tex</p>
</section>
<section id="nowait-clause-on-target-construct">
<h3><strong>nowait</strong> Clause on <strong>target</strong> Construct<a class="headerlink" href="#nowait-clause-on-target-construct" title="Permalink to this headline">#</a></h3>
<p><strong>target construct <strong>target</strong> construct!nowait clause <strong>nowait</strong> clause</strong> <strong>clauses!nowait <strong>nowait</strong></strong> <strong>nowait clause <strong>nowait</strong> clause</strong></p>
<p>The following example shows how to execute code asynchronously on a  device without an explicit task. The <strong>nowait</strong> clause on a <strong>target</strong>  construct allows the thread of the  <em>target task</em>  to perform other work while waiting for the <strong>target</strong> region execution to complete.  Hence, the <strong>target</strong> region can execute asynchronously on the  device (without requiring a host thread to idle while waiting for  the  <em>target task</em>  execution to complete).</p>
<p>In this example the product of two vectors (arrays),  <em>v1</em>  and  <em>v2</em> , is formed. One half of the operations is performed on the device, and the last half on the host, concurrently.</p>
<p>After a team of threads is formed the primary thread generates  the  <em>target task</em>  while the other threads can continue on, without a barrier, to the execution of the host portion of the vector product. The completion of the  <em>target task</em>  (asynchronous target execution) is  guaranteed by the synchronization in the implicit barrier at the end of the  host vector-product worksharing loop region. See the <strong>barrier</strong>  glossary entry in the OpenMP specification for details.</p>
<p>The host loop scheduling is <strong>dynamic</strong>, to balance the host thread executions, since  one thread is being used for offload generation. In the situation where  little time is spent by the  <em>target task</em>  in setting  up and tearing down the target execution, <strong>static</strong> scheduling may be desired.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: async_target.3
* type: C
* version: omp_5.1
*/
#include &lt;stdio.h&gt;

#define N 1000000      //N must be even
void init(int n, float *v1, float *v2);

int main(){
   int   i, n=N;
   int   chunk=1000;
   float v1[N],v2[N],vxv[N];

   init(n, v1,v2);

   #pragma omp parallel
   {

      #pragma omp masked
      #pragma omp target teams distribute parallel for nowait \
                                map(to: v1[0:n/2]) \
                                map(to: v2[0:n/2]) \
                                map(from: vxv[0:n/2])
      for(i=0; i&lt;n/2; i++){ vxv[i] = v1[i]*v2[i]; }

      #pragma omp for schedule(dynamic,chunk)
      for(i=n/2; i&lt;n; i++){ vxv[i] = v1[i]*v2[i]; }

   }
   printf(&quot; vxv[0] vxv[n-1] %f %f\n&quot;, vxv[0], vxv[n-1]);
   return 0;
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: async_target.3
! type: F-free
! version: omp_5.1
program concurrent_async
   use omp_lib
   integer,parameter :: n=1000000  !!n must be even
   integer           :: i, chunk=1000
   real              :: v1(n),v2(n),vxv(n)

   call init(n, v1,v2)

   !$omp parallel

      !$omp masked
      !$omp target teams distribute parallel do nowait &amp;
      !$omp&amp;                    map(to: v1(1:n/2))   &amp;
      !$omp&amp;                    map(to: v2(1:n/2))   &amp;
      !$omp&amp;                    map(from: vxv(1:n/2))
      do i = 1,n/2;    vxv(i) = v1(i)*v2(i); end do
      !$omp end masked

      !$omp do schedule(dynamic,chunk)
      do i = n/2+1,n;  vxv(i) = v1(i)*v2(i); end do

   !$omp end parallel

   print*, &quot; vxv(1) vxv(n) :&quot;, vxv(1), vxv(n)

end program

</pre></div>
</div>
</div>
</div>
<p>../../devices/async_target_nowait.tex</p>
</section>
<section id="asynchronous-target-with-nowait-and-depend-clauses">
<h3>Asynchronous <strong>target</strong> with <strong>nowait</strong> and <strong>depend</strong> Clauses<a class="headerlink" href="#asynchronous-target-with-nowait-and-depend-clauses" title="Permalink to this headline">#</a></h3>
<p><strong>target construct <strong>target</strong> construct!nowait clause <strong>nowait</strong> clause</strong> <strong>target construct <strong>target</strong> construct!depend clause <strong>depend</strong> clause</strong> <strong>nowait clause <strong>nowait</strong> clause</strong> <strong>depend clause <strong>depend</strong> clause</strong> <strong>clauses!nowait <strong>nowait</strong></strong> <strong>clauses!depend <strong>depend</strong></strong></p>
<p>More details on dependences can be found in  task_depend , Task  Dependences. In this example, there are three flow dependences.  In the first two dependences the target task does not execute until the preceding explicit tasks have finished.   These  dependences are produced by arrays  <em>v1</em>  and  <em>v2</em>   with the <strong>out</strong> dependence type in the first two tasks, and the <strong>in</strong> dependence type in the target task.</p>
<p>The last dependence is produced by array  <em>p</em>   with the <strong>out</strong> dependence type in the target task, and the <strong>in</strong> dependence type in the last task.  The last task does not execute until the target task finishes.</p>
<p>The <strong>nowait</strong> clause on the <strong>target</strong> construct creates a deferrable  <em>target task</em> , allowing the encountering task to continue execution without waiting for the completion of the  <em>target task</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: async_target.4
* type: C
* version: omp_4.5
*/

extern void init(  float*, int);
extern void output(float*, int);

void vec_mult(int N)
{
   int i;
   float p[N], v1[N], v2[N];

   #pragma omp parallel num_threads(2)
   {
      #pragma omp single
      {
         #pragma omp task depend(out:v1)
         init(v1, N);

         #pragma omp task depend(out:v2)
         init(v2, N);

         #pragma omp target nowait depend(in:v1,v2) depend(out:p) \
                                      map(to:v1,v2) map( from: p)
         #pragma omp parallel for private(i)
         for (i=0; i&lt;N; i++)
            p[i] = v1[i] * v2[i];

         #pragma omp task depend(in:p)
         output(p, N);
      }
   }
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: async_target.4
! type: F-free
! version: omp_4.5

subroutine vec_mult(N)
   implicit none
   integer           :: i, N
   real, allocatable :: p(:), v1(:), v2(:)
   allocate( p(N), v1(N), v2(N) )

   !$omp parallel num_threads(2)

      !$omp single

         !$omp task depend(out:v1)
         call init(v1, N)
         !$omp end task

         !$omp task depend(out:v2)
         call init(v2, N)
         !$omp end task

         !$omp target nowait depend(in:v1,v2) depend(out:p) &amp;
         !$omp&amp;                 map(to:v1,v2)  map(from: p)
         !$omp parallel do
         do i=1,N
            p(i) = v1(i) * v2(i)
         end do
         !$omp end target


         !$omp task depend(in:p)
         call output(p, N)
         !$omp end task

     !$omp end single
   !$omp end parallel

   deallocate( p, v1, v2 )

end subroutine

</pre></div>
</div>
</div>
</div>
<p>../../devices/async_target_nowait_depend.tex</p>
</section>
</section>
<section id="device-routines">
<h2>Device Routines<a class="headerlink" href="#device-routines" title="Permalink to this headline">#</a></h2>
<section id="omp-is-initial-device-routine">
<h3><strong>omp_is_initial_device</strong> Routine<a class="headerlink" href="#omp-is-initial-device-routine" title="Permalink to this headline">#</a></h3>
<p><strong>routines!omp_is_initial_device <strong>omp_is_initial_device</strong></strong> <strong>omp_is_initial_device routine <strong>omp_is_initial_device</strong> routine</strong></p>
<p><strong>directives!declare target <strong>declare</strong> <strong>target</strong></strong> <strong>declare target directive <strong>declare</strong> <strong>target</strong> directive</strong></p>
<p><strong>directives!begin declare target <strong>begin</strong> <strong>declare</strong> <strong>target</strong></strong> <strong>begin declare target directive <strong>begin</strong> <strong>declare</strong> <strong>target</strong> directive</strong></p>
<p>The following example shows how the <strong>omp_is_initial_device</strong> runtime library routine  can be used to query if a code is executing on the initial host device or on a  target device. The example then sets the number of threads in the <strong>parallel</strong>  region based on where the code is executing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: device.1
* type: C
* version: omp_5.1
*/
#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

#pragma omp begin declare target
   void vec_mult(float *p, float *v1, float *v2, int N);
   extern float *p, *v1, *v2;
   extern int N;
#pragma omp end declare target

extern void init_vars(float *, float *, int);
extern void output(float *, int);

void foo()
{
   init_vars(v1, v2, N);
   #pragma omp target device(42) map(p[:N], v1[:N], v2[:N])
   {
      vec_mult(p, v1, v2, N);
   }
   output(p, N);
}

void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   int nthreads;
   if (!omp_is_initial_device())
   {
      printf(&quot;1024 threads on target device\n&quot;);
      nthreads = 1024;
   }
   else
   {
      printf(&quot;8 threads on initial device\n&quot;);
      nthreads = 8;
   }
   #pragma omp parallel for private(i) num_threads(nthreads)
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: device.1
! type: F-free
! version:    omp_4.0
module params
   integer,parameter :: N=1024
end module params
module vmult
contains
   subroutine vec_mult(p, v1, v2, N)
   use omp_lib, ONLY : omp_is_initial_device
   !$omp declare target
   real    :: p(N), v1(N), v2(N)
   integer :: i, nthreads, N
      if (.not. omp_is_initial_device()) then
         print*, &quot;1024 threads on target device&quot;
         nthreads = 1024
      else
         print*, &quot;8 threads on initial device&quot;
         nthreads = 8
      endif
      !$omp parallel do private(i) num_threads(nthreads)
      do i = 1,N
        p(i) = v1(i) * v2(i)
      end do
   end subroutine vec_mult
end module vmult
program prog_vec_mult
use params
use vmult
real :: p(N), v1(N), v2(N)
   call init(v1,v2,N)
   !$omp target device(42) map(p, v1, v2)
      call vec_mult(p, v1, v2, N)
   !$omp end target
   call output(p, N)
end program

</pre></div>
</div>
</div>
</div>
</section>
<section id="omp-get-num-devices-routine">
<h3><strong>omp_get_num_devices</strong> Routine<a class="headerlink" href="#omp-get-num-devices-routine" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>omp_get_num_devices</strong> runtime library routine  can be used to determine the number of devices.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: device.2
* type: C
* version: omp_4.0
*/
#include &lt;omp.h&gt;
extern void init(float *, float *, int);
extern void output(float *, int);
void vec_mult(float *p, float *v1, float *v2, int N)
{
   int i;
   init(v1, v2, N);
   int ndev = omp_get_num_devices();
   int do_offload = (ndev&gt;0 &amp;&amp; N&gt;1000000);
   #pragma omp target if(do_offload) \
                      map(to: v1[0:N], v2[:N]) \
                      map(from: p[0:N])
   #pragma omp parallel for if(N&gt;1000) private(i)
   for (i=0; i&lt;N; i++)
     p[i] = v1[i] * v2[i];
   output(p, N);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: device.2
! type: F-free
! version:    omp_4.0
subroutine vec_mult(p, v1, v2, N)
use omp_lib, ONLY : omp_get_num_devices
real    :: p(N), v1(N), v2(N)
integer :: N, i, ndev
logical :: do_offload
   call init(v1, v2, N)
   ndev = omp_get_num_devices()
   do_offload = (ndev&gt;0) .and. (N&gt;1000000)
   !$omp target if(do_offload) map(to: v1, v2) map(from: p)
   !$omp parallel do if(N&gt;1000)
      do i=1,N
         p(i) = v1(i) * v2(i)
      end do
   !$omp end target
   call output(p, N)
end subroutine

</pre></div>
</div>
</div>
</div>
</section>
<section id="omp-set-default-device-and-omp-get-default-device-routines">
<h3><strong>omp_set_default_device</strong> and  <strong>omp_get_default_device</strong> Routines<a class="headerlink" href="#omp-set-default-device-and-omp-get-default-device-routines" title="Permalink to this headline">#</a></h3>
<p><strong>routines!omp_set_default_device <strong>omp_set_default_device</strong></strong> <strong>omp_set_default_device routine <strong>omp_set_default_device</strong> routine</strong></p>
<p>The following example shows how the <strong>omp_set_default_device</strong> and <strong>omp_get_default_device</strong>  runtime library routines can be used to set the default device and determine the  default device respectively.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: device.3
* type: C
* version: omp_4.0
*/
#include &lt;omp.h&gt;
#include &lt;stdio.h&gt;
void foo(void)
{
   int default_device = omp_get_default_device();
   printf(&quot;Default device = %d\n&quot;, default_device);
   omp_set_default_device(default_device+1);
   if (omp_get_default_device() != default_device+1)
      printf(&quot;Default device is still = %d\n&quot;, default_device);
}

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: device.3
! type: F-free
! version:    omp_4.0
program foo
use omp_lib, ONLY : omp_get_default_device, omp_set_default_device
integer :: old_default_device, new_default_device
   old_default_device = omp_get_default_device()
   print*, &quot;Default device = &quot;, old_default_device
   new_default_device = old_default_device + 1
   call omp_set_default_device(new_default_device)
   if (omp_get_default_device() == old_default_device) &amp;
      print*,&quot;Default device is STILL = &quot;, old_default_device
end program

</pre></div>
</div>
</div>
</div>
<p>../../devices/target_associate_ptr.tex</p>
</section>
<section id="target-memory-and-device-pointers-routines">
<h3>Target Memory and Device Pointers Routines<a class="headerlink" href="#target-memory-and-device-pointers-routines" title="Permalink to this headline">#</a></h3>
<p><strong>routines!omp_target_alloc <strong>omp_target_alloc</strong></strong> <strong>omp_target_alloc routine <strong>omp_target_alloc</strong> routine</strong> <strong>routines!omp_target_memcpy <strong>omp_target_memcpy</strong></strong> <strong>omp_target_memcpy routine <strong>omp_target_memcpy</strong> routine</strong> <strong>routines!omp_target_free <strong>omp_target_free</strong></strong> <strong>omp_target_free routine <strong>omp_target_free</strong> routine</strong></p>
<p>The following example shows how to create space on a device, transfer data to and from that space, and free the space, using API calls. The API calls directly execute allocation, copy and free operations on the device, without invoking any mapping through a <strong>target</strong> directive. The <strong>omp_target_alloc</strong> routine allocates space and returns a device pointer for referencing the space in the <strong>omp_target_memcpy</strong> API routine on the host. The <strong>omp_target_free</strong> routine frees the space on the device.</p>
<p><strong>target construct <strong>target</strong> construct!is_device_ptr clause <strong>is_device_ptr</strong> clause</strong> <strong>is_device_ptr clause <strong>is_device_ptr</strong> clause</strong> <strong>clauses!is_device_ptr <strong>is_device_ptr</strong></strong> The example also illustrates how to access that space in a <strong>target</strong> region by exposing the device pointer in an <strong>is_device_ptr</strong> clause.</p>
<p>The example creates an array of cosine values on the default device, to be used on the host device. The function fails if a default device is not available.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//%compiler: clang
//%cflags: -fopenmp

/*
* name: device.4
* type: C
* version: omp_4.5
*/
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;omp.h&gt;

void get_dev_cos(double *mem, size_t s)
{
   int h, t, i;
   double * mem_dev_cpy;
   h = omp_get_initial_device();
   t = omp_get_default_device();

   if (omp_get_num_devices() &lt; 1 || t &lt; 0){
      printf(&quot; ERROR: No device found.\n&quot;);
      exit(1);
   }

   mem_dev_cpy = (double *)omp_target_alloc( sizeof(double) * s, t);
   if(mem_dev_cpy == NULL){
      printf(&quot; ERROR: No space left on device.\n&quot;);
      exit(1);
   }

                          /* dst  src */
   omp_target_memcpy(mem_dev_cpy, mem, sizeof(double)*s,
                              0,    0,
                              t,   h);

   #pragma omp target is_device_ptr(mem_dev_cpy) device(t)
   #pragma omp teams distribute parallel for
     for(i=0;i&lt;s;i++){ mem_dev_cpy[i] = cos((double)i); } /* init data */

                   /* dst  src */
    omp_target_memcpy(mem, mem_dev_cpy, sizeof(double)*s,
                      0,             0,
                      h,             t);

    omp_target_free(mem_dev_cpy, t);
}

</pre></div>
</div>
</div>
</div>
<p><strong>routines!omp_target_is_present <strong>omp_target_is_present</strong></strong> <strong>omp_target_is_present routine <strong>omp_target_is_present</strong> routine</strong> <strong>routines!omp_target_associate_ptr <strong>omp_target_associate_ptr</strong></strong> <strong>omp_target_associate_ptr routine <strong>omp_target_associate_ptr</strong> routine</strong> The following Fortran example illustrates how to use the <strong>omp_target_alloc</strong> and <strong>omp_target_memcpy</strong> functions to directly allocate device storage and transfer data to and from a device. It also shows how to check for the presence of device data with the <strong>omp_target_is_present</strong> function and to associate host and device storage with the <strong>omp_target_associate_ptr</strong> function.</p>
<p>In Section 1 of the code, 40 bytes of storage are allocated on the default device with the <strong>omp_target_alloc</strong> function, which returns a value (of type  <strong>C_PTR</strong> ) that contains the device address of the storage. In the subsequent <strong>target</strong> construct,  <strong>cp</strong>  is specified on the <strong>is_device_ptr</strong> clause to instruct the compiler that  <strong>cp</strong>  is a device pointer. The device pointer ( <strong>cp</strong> ) is then associated with the Fortran pointer ( <strong>fp</strong> ) via the  <strong>c_f_pointer</strong>  routine inside the <strong>target</strong> construct. As a result,  <strong>fp</strong>  points to the storage on the device that is allocated by the <strong>omp_target_alloc</strong> routine. In the <strong>target</strong> region, the value 4 is assigned to the storage on the device, using the Fortran pointer. A trivial test checks that all values were correctly assigned. The Fortran pointer ( <strong>fp</strong> ) is nullified before the end of the <strong>target</strong> region. After the <strong>target</strong> construct, the space on the device is freed with the <strong>omp_target_free</strong> function, using the device  <strong>cp</strong>  pointer which is set to null after the call.</p>
<p>In Section 2, the content of the storage allocated on the host is directly copied to the OpenMP allocated storage on the device. First, storage is allocated for the device and host using <strong>omp_target_alloc</strong>. Next, on the host the device pointer, returned from the allocation <strong>omp_target_alloc</strong> function, is associated with a Fortran pointer, and values are assigned to the storage. Similarly, values are assigned on the device to the device storage, after associating a Fortran pointer ( <strong>fp_dst</strong> ) with the device’s storage pointer ( <strong>cp_dst</strong> ).</p>
<p>Next the <strong>omp_target_memcpy</strong> function directly copies the host data to the device storage, specified by the respective host and device pointers. This copy will overwrite -1 values in the device storage, and is checked in the next <strong>target</strong> construct. Keyword arguments are used here for clarity. (A positional argument list is used in the next Section.)</p>
<p>In Section 3, space is allocated (with a Fortran ALLOCATE statement) and initialized using a host Fortran pointer ( <strong>h_fp</strong> ), and the address of the storage is directly assigned to a host C pointer ( <strong>h_cp</strong> ). The following <strong>omp_target_is_present</strong> function returns  <strong>0</strong>  (false, of integer(C_INT) type) to indicate that  <strong>h_cp</strong>  does not have any corresponding storage on the default device.</p>
<p>Next, the same amount of space is allocated on the default device with the <strong>omp_target_alloc</strong> function, which returns a device pointer ( <strong>d_cp</strong> ). The device pointer  <strong>d_cp</strong>  and host pointer  <strong>h_cp</strong>  are then associated using the <strong>omp_target_associate_ptr</strong> function. The device storage to which  <strong>d_cp</strong>  points becomes the corresponding storage of the host storage to which  <strong>h_cp</strong>  points. The following <strong>omp_target_is_present</strong> call confirms this, by returning a non-zero value of integer(C_INT) type for true.</p>
<p>After the association, the content of the  host storage is copied to the device using the <strong>omp_target_memcpy</strong> function. In the final <strong>target</strong> construct an array section of  <strong>h_fp</strong>   is mapped to the device, and evaluated for correctness. The mapping establishes a connection of  <strong>h_fp</strong>  with the corresponding device data in the <strong>target</strong> construct, but does not produce an update on the device because the previous <strong>omp_target_associate_ptr</strong> routine sets the  reference count of the mapped object to infinity, meaning a mapping  without the <strong>always</strong> modifier will not  update the device object.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>
! name: device.4
! type: F-free
! version: omp_5.0
program device_mem
  use omp_lib
  use, intrinsic            :: iso_c_binding

  integer(kind=4),parameter :: N = 10
  type(c_ptr)               :: cp
  integer(c_int), pointer   :: fp(:)
  integer(c_int)            :: rc, host_dev, targ_dev
  integer(c_size_t)         :: int_bytes

  integer, pointer  :: fp_src(:), fp_dst(:)    ! Section 2 vars
  type(c_ptr)       :: cp_src,    cp_dst       ! Section 2 vars

  integer, pointer  :: h_fp(:)                 ! Section 3 vars
  type(c_ptr)       :: h_cp,    d_cp           ! Section 3 vars

  integer :: i

  host_dev  = omp_get_initial_device()
  targ_dev  = omp_get_default_device()
  int_bytes = C_SIZEOF(rc)

!------------------------------------------------Section 1 vv-----------
  cp = omp_target_alloc(N*int_bytes, targ_dev)

  !$omp target is_device_ptr(cp) device(targ_dev) !fp implicit map
     call c_f_pointer(cp, fp, [ N ])              !fp becomes associated
     fp(:) = 4
     if( all(fp == 4) ) print*,&quot;PASSED 1 of 5&quot;
     nullify(fp)                   !fp must be returned as disassociated
  !$omp end target

  call omp_target_free(cp, targ_dev)
  cp = c_null_ptr

!------------------------------------------------Section 2 vv-----------

   cp_src = omp_target_alloc((N+1)*int_bytes, host_dev)
   cp_dst = omp_target_alloc(  N  *int_bytes, targ_dev)

!           Initialize host array (src)
   call c_f_pointer(cp_src, fp_src, [N+1])
   fp_src = [(i,i=1,N+1)]

   !$omp target device(targ_dev) is_device_ptr(cp_dst)
     call c_f_pointer(cp_dst, fp_dst, [N])   ! fp_dst becomes associated
     fp_dst(:) = -1                          ! Initial device storage
     nullify(fp_dst)                         ! return as disassociated
   !$omp end target

!  Copy subset of host (src) array to device (dst) array
   rc = omp_target_memcpy(                                             &amp;
            dst=cp_dst,             src=cp_src,    length=N*int_bytes, &amp;
            dst_offset=0_c_size_t,  src_offset=int_bytes,              &amp;
            dst_device_num=targ_dev,src_device_num=host_dev)

!  Check dst array on device

   !$omp target device(targ_dev) is_device_ptr(cp_dst)
     call c_f_pointer(cp_dst, fp_dst, [N])
     if ( all(fp_dst == [(i,i=1,N)]) ) print*,&quot;PASSED 2 of 5&quot;
     nullify(fp_dst)
   !$omp end target

!------------------------------------------------Section 3 vv-----------

   !allocate host memory and initialize.
   allocate(h_fp(N), source=[(i,i=1,N)])

   h_cp = c_loc(h_fp)
             ! Device is not aware of allocation on host
   if(omp_target_is_present(h_cp, targ_dev) == 0) &amp;
      print*, &quot;PASSED 3 of 5&quot;

             ! Allocate device memory
   d_cp = omp_target_alloc(c_sizeof(h_fp(1))*size(h_fp), targ_dev)

             ! now associate host and device storage
   rc=omp_target_associate_ptr(h_cp,d_cp,c_sizeof(h_fp(1))*size(h_fp), &amp;
                               0_c_size_t,targ_dev)

             ! check presence of device data, associated w. host pointer
   if(omp_target_is_present(h_cp, targ_dev) /= 0) &amp;
      print*,&quot;PASSED 4 of 5&quot;

             ! copy from host to device via C pointers
   rc=omp_target_memcpy(d_cp,       h_cp,c_sizeof(h_fp(1))*size(h_fp), &amp;
                        0_c_size_t, 0_c_size_t,                        &amp;
                        targ_dev,   host_dev)

             ! validate the device data in the target region
             ! no data copy here since the reference count is infinity
   !$omp target device(targ_dev) map(h_fp)
     if ( all(h_fp == [(i,i=1,N)]) ) print*, &quot;PASSED 5 of 5&quot;
   !$omp end target

   call omp_target_free(d_cp,targ_dev)
   deallocate(h_fp)
end program

</pre></div>
</div>
</div>
</div>
<p>../../devices/device.tex</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="Chap_tasking.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Tasking</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Chap_SIMD.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">SIMD</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The OpenMP Community<br/>
  
      &copy; <a href="../copyright.html">Copyright</a> 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>