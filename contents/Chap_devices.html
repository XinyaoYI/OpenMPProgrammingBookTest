
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Devices &#8212; OpenMP Application Programming Interface Examples</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="SIMD" href="Chap_SIMD.html" />
    <link rel="prev" title="Tasking" href="Chap_tasking.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OpenMP Application Programming Interface Examples</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Welcome to OMP Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Title_Page.html">
   Cover
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Foreword_Chapt.html">
   Foreword
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_introduction.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_directives.html">
   OpenMP Directive Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_parallel_execution.html">
   Parallel Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_affinity.html">
   OpenMP Affinity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_tasking.html">
   Tasking
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Devices
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_SIMD.html">
   SIMD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_loop_transformations.html">
   Loop Transformations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_synchronization.html">
   Synchronization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_data_environment.html">
   Data Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_memory_model.html">
   Memory Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Chap_program_control.html">
   Program Control
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/passlab/Examples/main?urlpath=lab/tree/notebook/contents/Chap_devices.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/passlab/Examples"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/passlab/Examples/issues/new?title=Issue%20on%20page%20%2Fcontents/Chap_devices.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/contents/Chap_devices.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-construct">
   <strong>
    target
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-on-parallel-construct">
     <strong>
      target
     </strong>
     Construct on
     <strong>
      parallel
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-with-map-clause">
     <strong>
      target
     </strong>
     Construct with
     <strong>
      map
     </strong>
     Clause
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map-clause-with-to-from-map-types">
     <strong>
      map
     </strong>
     Clause with
     <strong>
      to
     </strong>
     /
     <strong>
      from
     </strong>
     map-types
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map-clause-with-array-sections">
     <strong>
      map
     </strong>
     Clause with Array Sections
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-with-if-clause">
     <strong>
      target
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-reverse-offload">
     Target Reverse Offload
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defaultmap-clause">
   <strong>
    defaultmap
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pointer-mapping">
   Pointer Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#structure-mapping">
   Structure Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fortran-allocatable-array-mapping">
   Fortran Allocatable Array Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-sections-in-device-constructs">
   Array Sections in Device Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#c-virtual-functions">
   C++ Virtual Functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-shaping">
   Array Shaping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-mapper-directive">
   <strong>
    declare mapper
   </strong>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-data-construct">
   <strong>
    target
   </strong>
   <strong>
    data
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-target-data-construct">
     Simple
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-region-enclosing-multiple-target-regions">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Region Enclosing Multiple
     <strong>
      target
     </strong>
     Regions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-construct-with-orphaned-call">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct with Orphaned Call
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-construct-with-if-clause">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-enter-data-and-target-exit-data-constructs">
   <strong>
    target
   </strong>
   <strong>
    enter
   </strong>
   <strong>
    data
   </strong>
   and
   <strong>
    target
   </strong>
   <strong>
    exit
   </strong>
   <strong>
    data
   </strong>
   Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-update-construct">
   <strong>
    target
   </strong>
   <strong>
    update
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-target-data-and-target-update-constructs">
     Simple
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     and
     <strong>
      target
     </strong>
     <strong>
      update
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-update-construct-with-if-clause">
     <strong>
      target
     </strong>
     <strong>
      update
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-target-directive">
   Declare Target Directive
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-a-procedure">
     Declare Target Directive for a Procedure
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-class-type">
     Declare Target Directive for Class Type
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-variables">
     Declare Target Directive for Variables
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-with-declare-simd">
     Declare Target Directive with
     <strong>
      declare
     </strong>
     <strong>
      simd
     </strong>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-with-link-clause">
     Declare Target Directive with
     <strong>
      link
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lambda-expressions">
   Lambda Expressions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#teams-construct-and-related-combined-constructs">
   <strong>
    teams
   </strong>
   Construct and Related Combined Constructs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-and-teams-constructs-with-omp-get-num-teams-and-omp-get-team-num-routines">
     <strong>
      target
     </strong>
     and
     <strong>
      teams
     </strong>
     Constructs with
     <strong>
      omp_get_num_teams
     </strong>
     and
     <strong>
      omp_get_team_num
     </strong>
     Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-constructs">
     <strong>
      target
     </strong>
     ,
     <strong>
      teams
     </strong>
     , and
     <strong>
      distribute
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     , and Distribute Parallel Loop Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-constructs-with-scheduling-clauses">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and Distribute Parallel Loop  Constructs with Scheduling Clauses
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-simd-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and
     <strong>
      distribute
     </strong>
     <strong>
      simd
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-simd-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and Distribute Parallel Loop SIMD Constructs
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#asynchronous-target-execution-and-dependences">
   Asynchronous
   <strong>
    target
   </strong>
   Execution and Dependences
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-target-with-tasks">
     Asynchronous
     <strong>
      target
     </strong>
     with Tasks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nowait-clause-on-target-construct">
     <strong>
      nowait
     </strong>
     Clause on
     <strong>
      target
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-target-with-nowait-and-depend-clauses">
     Asynchronous
     <strong>
      target
     </strong>
     with
     <strong>
      nowait
     </strong>
     and
     <strong>
      depend
     </strong>
     Clauses
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#device-routines">
   Device Routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-is-initial-device-routine">
     <strong>
      omp_is_initial_device
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-get-num-devices-routine">
     <strong>
      omp_get_num_devices
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-set-default-device-and-omp-get-default-device-routines">
     <strong>
      omp_set_default_device
     </strong>
     and
     <strong>
      omp_get_default_device
     </strong>
     Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#device-and-host-memory-association">
     Device and Host Memory Association
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-memory-and-device-pointers-routines">
     Target Memory and Device Pointers Routines
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Devices</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-construct">
   <strong>
    target
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-on-parallel-construct">
     <strong>
      target
     </strong>
     Construct on
     <strong>
      parallel
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-with-map-clause">
     <strong>
      target
     </strong>
     Construct with
     <strong>
      map
     </strong>
     Clause
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map-clause-with-to-from-map-types">
     <strong>
      map
     </strong>
     Clause with
     <strong>
      to
     </strong>
     /
     <strong>
      from
     </strong>
     map-types
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#map-clause-with-array-sections">
     <strong>
      map
     </strong>
     Clause with Array Sections
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-construct-with-if-clause">
     <strong>
      target
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-reverse-offload">
     Target Reverse Offload
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defaultmap-clause">
   <strong>
    defaultmap
   </strong>
   Clause
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pointer-mapping">
   Pointer Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#structure-mapping">
   Structure Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fortran-allocatable-array-mapping">
   Fortran Allocatable Array Mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-sections-in-device-constructs">
   Array Sections in Device Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#c-virtual-functions">
   C++ Virtual Functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-shaping">
   Array Shaping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-mapper-directive">
   <strong>
    declare mapper
   </strong>
   Directive
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-data-construct">
   <strong>
    target
   </strong>
   <strong>
    data
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-target-data-construct">
     Simple
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-region-enclosing-multiple-target-regions">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Region Enclosing Multiple
     <strong>
      target
     </strong>
     Regions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-construct-with-orphaned-call">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct with Orphaned Call
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-data-construct-with-if-clause">
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-enter-data-and-target-exit-data-constructs">
   <strong>
    target
   </strong>
   <strong>
    enter
   </strong>
   <strong>
    data
   </strong>
   and
   <strong>
    target
   </strong>
   <strong>
    exit
   </strong>
   <strong>
    data
   </strong>
   Constructs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#target-update-construct">
   <strong>
    target
   </strong>
   <strong>
    update
   </strong>
   Construct
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-target-data-and-target-update-constructs">
     Simple
     <strong>
      target
     </strong>
     <strong>
      data
     </strong>
     and
     <strong>
      target
     </strong>
     <strong>
      update
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-update-construct-with-if-clause">
     <strong>
      target
     </strong>
     <strong>
      update
     </strong>
     Construct with
     <strong>
      if
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#declare-target-directive">
   Declare Target Directive
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-a-procedure">
     Declare Target Directive for a Procedure
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-class-type">
     Declare Target Directive for Class Type
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-for-variables">
     Declare Target Directive for Variables
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-with-declare-simd">
     Declare Target Directive with
     <strong>
      declare
     </strong>
     <strong>
      simd
     </strong>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#declare-target-directive-with-link-clause">
     Declare Target Directive with
     <strong>
      link
     </strong>
     Clause
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lambda-expressions">
   Lambda Expressions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#teams-construct-and-related-combined-constructs">
   <strong>
    teams
   </strong>
   Construct and Related Combined Constructs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-and-teams-constructs-with-omp-get-num-teams-and-omp-get-team-num-routines">
     <strong>
      target
     </strong>
     and
     <strong>
      teams
     </strong>
     Constructs with
     <strong>
      omp_get_num_teams
     </strong>
     and
     <strong>
      omp_get_team_num
     </strong>
     Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-constructs">
     <strong>
      target
     </strong>
     ,
     <strong>
      teams
     </strong>
     , and
     <strong>
      distribute
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     , and Distribute Parallel Loop Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-constructs-with-scheduling-clauses">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and Distribute Parallel Loop  Constructs with Scheduling Clauses
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-simd-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and
     <strong>
      distribute
     </strong>
     <strong>
      simd
     </strong>
     Constructs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-teams-and-distribute-parallel-loop-simd-constructs">
     <strong>
      target
     </strong>
     <strong>
      teams
     </strong>
     and Distribute Parallel Loop SIMD Constructs
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#asynchronous-target-execution-and-dependences">
   Asynchronous
   <strong>
    target
   </strong>
   Execution and Dependences
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-target-with-tasks">
     Asynchronous
     <strong>
      target
     </strong>
     with Tasks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nowait-clause-on-target-construct">
     <strong>
      nowait
     </strong>
     Clause on
     <strong>
      target
     </strong>
     Construct
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-target-with-nowait-and-depend-clauses">
     Asynchronous
     <strong>
      target
     </strong>
     with
     <strong>
      nowait
     </strong>
     and
     <strong>
      depend
     </strong>
     Clauses
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#device-routines">
   Device Routines
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-is-initial-device-routine">
     <strong>
      omp_is_initial_device
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-get-num-devices-routine">
     <strong>
      omp_get_num_devices
     </strong>
     Routine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#omp-set-default-device-and-omp-get-default-device-routines">
     <strong>
      omp_set_default_device
     </strong>
     and
     <strong>
      omp_get_default_device
     </strong>
     Routines
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#device-and-host-memory-association">
     Device and Host Memory Association
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#target-memory-and-device-pointers-routines">
     Target Memory and Device Pointers Routines
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="devices">
<h1>Devices<a class="headerlink" href="#devices" title="Permalink to this headline">#</a></h1>
<p>The <strong>target</strong> construct consists of a <strong>target</strong> directive  and an execution region. The <strong>target</strong> region is executed on the default device or the device specified in the <strong>device</strong>  clause.</p>
<p>In OpenMP version 4.0, by default, all variables within the lexical scope of the construct are copied  <em>to</em>  and  <em>from</em>  the device, unless the device is the host, or the data exists on the device from a previously executed data-type construct that has created space on the device and possibly copied host data to the device storage.</p>
<p>The constructs that explicitly create storage, transfer data, and free storage on the device are categorized as structured and unstructured. The <strong>target</strong> <strong>data</strong> construct is structured. It creates a data region around <strong>target</strong> constructs, and is convenient for providing persistent data throughout multiple <strong>target</strong> regions. The <strong>target</strong> <strong>enter</strong> <strong>data</strong> and  <strong>target</strong> <strong>exit</strong> <strong>data</strong> constructs are unstructured, because  they can occur anywhere and do not support a “structure”  (a region) for enclosing <strong>target</strong> constructs, as does the <strong>target</strong> <strong>data</strong> construct.</p>
<p>The <strong>map</strong> clause is used on <strong>target</strong>  constructs and the data-type constructs to map host data. It  specifies the device storage and data movement <strong>to</strong> and <strong>from</strong> the device, and controls on the storage duration.</p>
<p>There is an important change in the OpenMP 4.5 specification that alters the data model for scalar variables and C/C++ pointer variables. The default behavior for scalar variables and C/C++ pointer variables in a 4.5 compliant code is <strong>firstprivate</strong>. Example codes that have been updated to reflect this new behavior are annotated with a description that describes changes required for correct execution. Often it is a simple matter of mapping the variable as <strong>tofrom</strong> to obtain the intended 4.0 behavior.</p>
<p>In OpenMP version 4.5 the mechanism for target execution is specified as occurring through a  <em>target task</em> .  When the <strong>target</strong> construct is encountered a new   <em>target task</em>  is generated. The  <em>target task</em>   completes after the <strong>target</strong> region has executed and all data  transfers have finished.</p>
<p>This new specification does not affect the execution of  pre-4.5 code; it is a necessary element for asynchronous  execution of the <strong>target</strong> region when using the new <strong>nowait</strong>  clause introduced in OpenMP 4.5.</p>
<section id="target-construct">
<h2><strong>target</strong> Construct<a class="headerlink" href="#target-construct" title="Permalink to this headline">#</a></h2>
<section id="target-construct-on-parallel-construct">
<h3><strong>target</strong> Construct on <strong>parallel</strong> Construct<a class="headerlink" href="#target-construct-on-parallel-construct" title="Permalink to this headline">#</a></h3>
<p>This following example shows how the <strong>target</strong> construct offloads a code  region to a target device. The variables  <em>p</em> ,  <em>v1</em> ,  <em>v2</em> , and  <em>N</em>  are implicitly mapped  to the target device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for private(i)</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-construct-with-map-clause">
<h3><strong>target</strong> Construct with <strong>map</strong> Clause<a class="headerlink" href="#target-construct-with-map-clause" title="Permalink to this headline">#</a></h3>
<p>This following example shows how the <strong>target</strong> construct offloads a code  region to a target device. The variables  <em>p</em> ,  <em>v1</em>  and  <em>v2</em>  are explicitly mapped to the  target device using the <strong>map</strong> clause. The variable  <em>N</em>  is implicitly mapped to  the target device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(v1, v2, p)</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="map-clause-with-to-from-map-types">
<h3><strong>map</strong> Clause with <strong>to</strong>/<strong>from</strong> map-types<a class="headerlink" href="#map-clause-with-to-from-map-types" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> construct offloads a code region  to a target device. In the <strong>map</strong> clause, the <strong>to</strong> and <strong>from</strong>  map-types define the mapping between the original (host) data and the target (device)  data. The <strong>to</strong> map-type specifies that the data will only be read on the  device, and the <strong>from</strong> map-type specifies that the data will only be written  to on the device. By specifying a guaranteed access on the device, data transfers  can be reduced for the <strong>target</strong> region.</p>
<p>The <strong>to</strong> map-type indicates that at the start of the <strong>target</strong> region  the variables  <em>v1</em>  and  <em>v2</em>  are initialized with the values of the corresponding variables  on the host device, and at the end of the <strong>target</strong> region the variables   <em>v1</em>  and  <em>v2</em>  are not assigned to their corresponding variables on the host device.</p>
<p>The <strong>from</strong> map-type indicates that at the start of the <strong>target</strong> region  the variable  <em>p</em>  is not initialized with the value of the corresponding variable  on the host device, and at the end of the <strong>target</strong> region the variable  <em>p</em>   is assigned to the corresponding variable on the host device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(to: v1, v2) map(from: p)</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The <strong>to</strong> and <strong>from</strong> map-types allow programmers to optimize data  motion. Since data for the  <em>v</em>  arrays are not returned, and data for the  <em>p</em>  array  are not transferred to the device, only one-half of the data is moved, compared  to the default behavior of an implicit mapping.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="map-clause-with-array-sections">
<h3><strong>map</strong> Clause with Array Sections<a class="headerlink" href="#map-clause-with-array-sections" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> construct offloads a code region  to a target device. In the <strong>map</strong> clause, map-types are used to optimize  the mapping of variables to the target device. Because variables  <em>p</em> ,  <em>v1</em>  and  <em>v2</em>  are  pointers, array section notation must be used to map the arrays. The notation <strong>:N</strong>  is equivalent to <strong>0:N</strong>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(to: v1[0:N], v2[:N]) map(from: p[0:N])</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In C, the length of the pointed-to array must be specified. In Fortran the extent  of the array is known and the length need not be specified. A section of the array  can be specified with the usual Fortran syntax, as shown in the following example.  The value 1 is assumed for the lower bound for array section  <em>v2(:N)</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">mults</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="p">,</span><span class="n">pointer</span><span class="p">,</span><span class="n">dimension</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w">                   </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="o">:</span><span class="n">N</span><span class="p">))</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="p">))</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>A more realistic situation in which an assumed-size array is passed to <strong>vec_mult</strong>  requires that the length of the arrays be specified, because the compiler does  not know the size of the storage. A section of the array must be specified with  the usual Fortran syntax, as shown in the following example. The value 1 is assumed  for the lower bound for array section  <em>v2(:N)</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="mf">.4</span><span class="n">b</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">mults</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="p">,</span><span class="n">dimension</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w">           </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="o">:</span><span class="n">N</span><span class="p">))</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="p">))</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-construct-with-if-clause">
<h3><strong>target</strong> Construct with <strong>if</strong> Clause<a class="headerlink" href="#target-construct-with-if-clause" title="Permalink to this headline">#</a></h3>
<p><strong>target construct <strong>target</strong> construct!if clause <strong>if</strong> clause</strong> <strong>clauses!if <strong>if</strong></strong> <strong>if clause <strong>if</strong> clause</strong></p>
<p>The following example shows how the <strong>target</strong> construct offloads a code region  to a target device.</p>
<p>The <strong>if</strong> clause on the <strong>target</strong> construct indicates that if the variable   <em>N</em>  is smaller than a given threshold, then the <strong>target</strong> region will be executed  by the host device.</p>
<p>The <strong>if</strong> clause on the <strong>parallel</strong> construct indicates that if the  variable  <em>N</em>  is smaller than a second threshold then the <strong>parallel</strong> region  is inactive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target.5</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define THRESHOLD1 1000000</span>
<span class="cp">#define THRESHOLD2 1000</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target if(N&gt;THRESHOLD1) map(to: v1[0:N], v2[:N])\</span>
<span class="cp"> map(from: p[0:N])</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for if(N&gt;THRESHOLD2)</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="mf">.5</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">THRESHOLD1</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="n">THRESHHOLD2</span><span class="o">=</span><span class="mi">1000</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="n">THRESHHOLD1</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="n">THRESHOLD2</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is a modification of the above  <em>target.5</em>  code to show the combined <strong>target</strong> and parallel loop directives. It uses the  <em>directive-name</em>  modifier in multiple <strong>if</strong> clauses to specify the component directive to which it applies.</p>
<p>The <strong>if</strong> clause with the <strong>target</strong> modifier applies to the <strong>target</strong> component of the  combined directive, and the <strong>if</strong> clause with the <strong>parallel</strong> modifier applies  to the <strong>parallel</strong> component of the combined directive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target.6</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.5</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define THRESHOLD1 1000000</span>
<span class="cp">#define THRESHOLD2 1000</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target parallel for \</span>
<span class="cp">        if(target: N&gt;THRESHOLD1) if(parallel: N&gt;THRESHOLD2) \</span>
<span class="cp">        map(to: v1[0:N], v2[:N]) map(from: p[0:N])</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="mf">.6</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.5</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">THRESHOLD1</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="n">THRESHHOLD2</span><span class="o">=</span><span class="mi">1000</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w">  </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="o">:</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="n">THRESHHOLD1</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">parallel</span><span class="o">:</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="n">THRESHOLD2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">   </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-reverse-offload">
<h3>Target Reverse Offload<a class="headerlink" href="#target-reverse-offload" title="Permalink to this headline">#</a></h3>
<p>Beginning with OpenMP 5.0, implementations are allowed to offload back to the host (reverse offload).</p>
<p>In the example below the  <em>error_handler</em>  function is executed back on the host, if an erroneous value is detected in the  <em>A</em>  array on the device.</p>
<p>This is accomplished by specifying the  <em>device-modifier</em>  <strong>ancestor</strong> modifier, along with a device number of <strong>1</strong>, to indicate that the execution is to be performed on the immediate parent ( <em>1st ancestor</em> )– the host.</p>
<p>The <strong>requires</strong> directive (another 5.0 feature) uses the <strong>reverse_offload</strong> clause to guarantee that the reverse offload is implemented.</p>
<p>Note that the <strong>declare</strong> <strong>target</strong> directive uses the <strong>device_type</strong> clause (another 5.0 feature) to specify that the  <em>error_handler</em>  function is compiled to execute on the  <em>host</em>  only. This ensures that no attempt will be made to create a device version of the function.  This feature may be necessary if the function exists in another compile unit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_reverse_offload.7</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define N 100</span>

<span class="cp">#pragma omp requires reverse_offload</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">error_handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">wrong_value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; Error in offload: A[%d]=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="n">wrong_value</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;        Expecting: A[i ]=i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="c1">// output:  Error in offload: A[99]=-1</span>
<span class="c1">//                 Expecting: A[i ]=i</span>

<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp declare target device_type(host) enter(error_handler)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]</span><span class="o">=</span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target map(A)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cp">#pragma omp target device(ancestor: 1) map(always,to: A[i:1])</span>
<span class="w">               </span><span class="n">error_handler</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! name:       target_reverse_offload.7
! type:       F-free
! version:    omp_5.0

!$omp requires reverse_offload

subroutine error_handler(wrong_value, index)
  integer :: wrong_value,index
  !$omp declare target device_type(host)

   write( *,&#39;(&quot;Error in offload: A(&quot;,i3,&quot;)=&quot;,i3)&#39; ) index,wrong_value
   write( *,&#39;(&quot;       Expecting: A(  i)=  i&quot;)&#39;    )
   stop
     !!output: Error in offload: A( 99)= -1
     !!               Expecting: A(  i)=  i
end subroutine

program rev_off
  use omp_lib
  integer, parameter :: N=100
  integer            :: A(N) = (/ (i, i=1,100) /)

   A(N-1)=-1

   !$omp target map(A)
      do i=1,N
         if (A(i) /= i)  then
           !$omp target device(ancestor: 1) map(always,to :A(i))
               call error_handler(A(i), i)
           !$omp end target
         endif
      end do
   !$omp end target

end program
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="defaultmap-clause">
<h2><strong>defaultmap</strong> Clause<a class="headerlink" href="#defaultmap-clause" title="Permalink to this headline">#</a></h2>
<p>The implicitly-determined, data-mapping and data-sharing attribute rules of variables referenced in a <strong>target</strong> construct can be changed by the <strong>defaultmap</strong> clause introduced in OpenMP 5.0. The implicit behavior is specified as <strong>alloc</strong>, <strong>to</strong>, <strong>from</strong>, <strong>tofrom</strong>, <strong>firstprivate</strong>, <strong>none</strong>, <strong>default</strong> or <strong>present</strong>, and is applied to a variable-category, where <strong>scalar</strong>, <strong>aggregate</strong>, <strong>allocatable</strong>, and <strong>pointer</strong> are the variable categories.</p>
<p>In OpenMP, a “category’’ has a common data-mapping and data-sharing  behavior for variable types within the category. In C/C++, <strong>scalar</strong> refers to base-language scalar variables, except pointers. In Fortran it refers to a scalar variable, as defined by the base language,  with intrinsic type, and excludes character type.</p>
<p>Also, <strong>aggregate</strong> refers to arrays and structures (C/C++) and derived types (Fortran). Fortran has the additional category of <strong>allocatable</strong>.</p>
<p>In the example below, the first <strong>target</strong> construct uses  <strong>defaultmap</strong> clauses to set data-mapping and possibly data-sharing attributes that reproduce  the default implicit mapping (data-mapping and data-sharing attributes).  That is,  if the <strong>defaultmap</strong> clauses were removed, the results would be identical.</p>
<p>In the second <strong>target</strong> construct all implicit behavior is removed by specifying the <strong>none</strong> implicit behavior in the <strong>defaultmap</strong> clause. Hence, all variables must be explicitly mapped.   In the C/C++ code a scalar ( <strong>s</strong> ), an array ( <strong>A</strong> ) and a structure  ( <strong>S</strong> ) are explicitly mapped <strong>tofrom</strong>.   The Fortran code uses a derived type ( <strong>D</strong> ) in lieu of structure.</p>
<p>The third <strong>target</strong> construct shows another usual case for using the <strong>defaultmap</strong> clause. The default mapping for (non-pointer) scalar variables is specified as <strong>tofrom</strong>. Here, the default implicit mapping for  <strong>s3</strong>  is <strong>tofrom</strong> as specified  in the <strong>defaultmap</strong> clause, and  <strong>s1</strong>  and  <strong>s2</strong>  are explicitly  mapped with the <strong>firstprivate</strong> data-sharing attribute.</p>
<p>In the fourth <strong>target</strong> construct all arrays, structures (C/C++) and derived  types (Fortran) are mapped with <strong>firstprivate</strong> data-sharing behavior by a  <strong>defaultmap</strong> clause with an <strong>aggregate</strong> variable category. For the  <strong>H</strong>  allocated array in the Fortran code, the <strong>allocable</strong>  category must be used in a separate <strong>defaultmap</strong> clause to acquire  <strong>firsprivate</strong> data-sharing behavior ( <strong>H</strong>  has the Fortran allocatable attribute).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_defaultmap.1</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 2</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S_struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">S_struct_t</span><span class="p">;</span><span class="w"></span>


<span class="w">  </span><span class="kt">int</span><span class="w">         </span><span class="n">s</span><span class="p">;</span><span class="w">       </span><span class="c1">//scalar int variable (scalar)</span>
<span class="w">  </span><span class="kt">int</span><span class="w">         </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w">    </span><span class="c1">//aggregate variable  (array)</span>
<span class="w">  </span><span class="n">S_struct_t</span><span class="w">  </span><span class="n">S</span><span class="p">;</span><span class="w">       </span><span class="c1">//aggregate variable  (structure)</span>
<span class="w">  </span><span class="kt">int</span><span class="w">         </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w">    </span><span class="c1">//scalar, pointer variable (pointer)</span>

<span class="w">  </span><span class="kt">int</span><span class="w">         </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Initialize everything to zero;</span>
<span class="w">   </span><span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">s1</span><span class="o">=</span><span class="n">s2</span><span class="o">=</span><span class="n">s3</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">S</span><span class="p">.</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Target Region 1</span>
<span class="w">                   </span><span class="c1">// Uses defaultmap to set scalars, aggregates &amp;</span>
<span class="w">                   </span><span class="c1">// pointers to normal defaults.</span>
<span class="w">    </span><span class="cp">#pragma omp target \</span>
<span class="cp">            defaultmap(firstprivate: scalar)   </span><span class="c1">//could also be default \</span>
<span class="w">            </span><span class="n">defaultmap</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w">       </span><span class="n">aggregate</span><span class="p">)</span><span class="c1">//could also be default \</span>
<span class="c1">            defaultmap(default:      pointer)  //must be default       \</span>
<span class="c1">            map(ptr2m[:N])</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">s</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">            </span><span class="c1">//SCALAR firstprivate, value not returned</span>

<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">  </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">//AGGREGATE array, default map tofrom</span>

<span class="w">                                </span><span class="c1">//AGGREGATE structure, default tofrom</span>
<span class="w">        </span><span class="n">S</span><span class="p">.</span><span class="n">s</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">            </span><span class="c1">//POINTER is private</span>
<span class="w">        </span><span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">   </span><span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">s</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; PASSED 1 of 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>


<span class="c1">// Target Region 2</span>
<span class="w">                   </span><span class="c1">// no implicit mapping allowed.</span>
<span class="w">    </span><span class="cp">#pragma omp target defaultmap(none) map(tofrom: s, A, S)</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">s</span><span class="w">     </span><span class="o">+=</span><span class="mi">5</span><span class="p">;</span><span class="w">           </span><span class="c1">// All variables must be explicitly mapped</span>
<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="o">+=</span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">S</span><span class="p">.</span><span class="n">s</span><span class="w">   </span><span class="o">+=</span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="mi">7</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">7</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">s</span><span class="o">==</span><span class="mi">7</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; PASSED 2 of 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>


<span class="c1">// Target Region 3</span>
<span class="w">            </span><span class="c1">// defaultmap &amp; explicit map with variables in same category</span>
<span class="w">    </span><span class="n">s1</span><span class="o">=</span><span class="n">s2</span><span class="o">=</span><span class="n">s3</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma  omp defaultmap(tofrom: scalar) map(firstprivate: s1,s2)</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">s1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">         </span><span class="c1">// firstprivate (s1 value not returned to host)</span>
<span class="w">        </span><span class="n">s2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">         </span><span class="c1">// firstprivate (s2 value not returned to host)</span>
<span class="w">        </span><span class="n">s3</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span><span class="w">   </span><span class="c1">// mapped as tofrom</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">s1</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s2</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s3</span><span class="o">==</span><span class="mi">13</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; PASSED 3 of 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>


<span class="c1">// Target Region 4</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// arrays and structure are firstprivate, and scalars are from</span>
<span class="w">    </span><span class="cp">#pragma omp target defaultmap(firstprivate: aggregate) \</span>
<span class="cp">                       map(from: s1, s2)</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//Aggregate changes not returned to host</span>
<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//Aggregate changes not returned to host</span>
<span class="w">        </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">//s1 value returned to host</span>
<span class="w">        </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="c1">//s1 value returned to host</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s1</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; PASSED 4 of 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w">       </span><span class="n">target_defaultmap</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w">       </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">defaultmap</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="w"></span>

<span class="w">  </span><span class="n">type</span><span class="w"> </span><span class="n">DDT_sA</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">type</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="w">             </span><span class="o">::</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s3</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">SCALAR</span><span class="o">:</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="p">(</span><span class="n">integer</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="n">target</span><span class="w">      </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w">       </span><span class="o">!!</span><span class="w"> </span><span class="n">AGGREGATE</span><span class="o">:</span><span class="w"> </span><span class="n">Array</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="p">(</span><span class="n">DDT_sA</span><span class="p">)</span><span class="w">        </span><span class="o">::</span><span class="w"> </span><span class="n">D</span><span class="w">          </span><span class="o">!!</span><span class="w"> </span><span class="n">AGGREGATE</span><span class="o">:</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="n">allocatable</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w">       </span><span class="o">!!</span><span class="w"> </span><span class="n">ALLOCATABLE</span><span class="o">:</span><span class="w"> </span><span class="n">Heap</span><span class="w"> </span><span class="n">allocated</span><span class="w"> </span><span class="n">array</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="n">pointer</span><span class="w">     </span><span class="o">::</span><span class="w"> </span><span class="n">ptrA</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w">    </span><span class="o">!!</span><span class="w"> </span><span class="n">POINTER</span><span class="o">:</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">Array</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">Assign</span><span class="w"> </span><span class="n">vaues</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">scalar</span><span class="p">,</span><span class="w"> </span><span class="n">Array</span><span class="p">,</span><span class="w"> </span><span class="n">Allocatable</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Pointers</span><span class="w"></span>

<span class="w">    </span><span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">s1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="n">s2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w">     </span><span class="n">s3</span><span class="o">=</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">D</span><span class="o">%</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="w"></span>

<span class="w">    </span><span class="n">allocate</span><span class="p">(</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="w"></span>

<span class="o">!!</span><span class="w"> </span><span class="n">Target</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                   </span><span class="o">!!</span><span class="w"> </span><span class="n">Using</span><span class="w"> </span><span class="n">defaultmap</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">scalars</span><span class="p">,</span><span class="w"> </span><span class="n">aggregates</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">                   </span><span class="o">!!</span><span class="w"> </span><span class="n">pointers</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">allocatables</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="n">defaults</span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w">                                        </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">defaultmap</span><span class="p">(</span><span class="w"> </span><span class="n">firstprivate</span><span class="o">:</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w">      </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">defaultmap</span><span class="p">(</span><span class="w"> </span><span class="n">tofrom</span><span class="o">:</span><span class="w">       </span><span class="n">aggregate</span><span class="p">)</span><span class="w">   </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">defaultmap</span><span class="p">(</span><span class="w"> </span><span class="n">tofrom</span><span class="o">:</span><span class="w">       </span><span class="n">allocatable</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">defaultmap</span><span class="p">(</span><span class="w"> </span><span class="k">default</span><span class="o">:</span><span class="w">      </span><span class="n">pointer</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w">                     </span><span class="o">!!</span><span class="w"> </span><span class="n">SCALAR</span><span class="w"> </span><span class="n">firstprivate</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">returned</span><span class="w"></span>

<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w">                  </span><span class="o">!!</span><span class="w"> </span><span class="n">AGGREGATE</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">tofrom</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>

<span class="w">        </span><span class="n">D</span><span class="o">%</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">                   </span><span class="o">!!</span><span class="w"> </span><span class="n">AGGR</span><span class="p">.</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="n">Type</span><span class="p">,</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">tofrom</span><span class="w"></span>
<span class="w">        </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>

<span class="w">        </span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">    </span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">     </span><span class="o">!!</span><span class="w"> </span><span class="n">ALLOCATABLE</span><span class="p">,</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">tofrom</span><span class="w"></span>

<span class="w">        </span><span class="n">ptrA</span><span class="o">=&gt;</span><span class="n">A</span><span class="w">                   </span><span class="o">!!</span><span class="w"> </span><span class="n">POINTER</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">private</span><span class="w"></span>
<span class="w">        </span><span class="n">ptrA</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">ptrA</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>

<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">s</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">       </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot; PASSED 1 of 4&quot;</span><span class="w"></span>

<span class="o">!!</span><span class="w"> </span><span class="n">Target</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">                   </span><span class="o">!!</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">implicit</span><span class="w"> </span><span class="n">mapping</span><span class="w"> </span><span class="n">allowed</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">defaultmap</span><span class="p">(</span><span class="n">none</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="o">+</span><span class="mi">5</span><span class="w">                 </span><span class="o">!!</span><span class="w"> </span><span class="n">All</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">explicitly</span><span class="w"> </span><span class="n">mapped</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">;</span><span class="w">       </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="w"></span>
<span class="w">        </span><span class="n">D</span><span class="o">%</span><span class="n">s</span><span class="o">=</span><span class="n">D</span><span class="o">%</span><span class="n">s</span><span class="o">+</span><span class="mi">5</span><span class="w"></span>
<span class="w">        </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="w"></span>

<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="mi">7</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">7</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">s</span><span class="o">==</span><span class="mi">7</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">        </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot; PASSED 2 of 4&quot;</span><span class="w"></span>

<span class="o">!!</span><span class="w"> </span><span class="n">Target</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">                </span><span class="o">!!</span><span class="n">defaultmap</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">explicit</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">category</span><span class="w"></span>
<span class="w">    </span><span class="n">s1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">s2</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">s3</span><span class="o">=</span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">defaultmap</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">firstprivate</span><span class="o">:</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="o">+</span><span class="mi">5</span><span class="p">;</span><span class="w">          </span><span class="o">!!</span><span class="w"> </span><span class="n">firstprivate</span><span class="w"> </span><span class="p">(</span><span class="n">s1</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">returned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">host</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="o">+</span><span class="mi">5</span><span class="p">;</span><span class="w">          </span><span class="o">!!</span><span class="w"> </span><span class="n">firstprivate</span><span class="w"> </span><span class="p">(</span><span class="n">s2</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">returned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">host</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">s3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="o">+</span><span class="n">s1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span><span class="w">   </span><span class="o">!!</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">tofrom</span><span class="w"></span>

<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">s1</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">s2</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">s3</span><span class="o">==</span><span class="mi">13</span><span class="p">)</span><span class="w"> </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot; PASSED 3 of 4&quot;</span><span class="w"></span>

<span class="o">!!</span><span class="w"> </span><span class="n">Target</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="w"></span>
<span class="w">              </span><span class="o">!!</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">allocated</span><span class="w"> </span><span class="n">arrays</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">derived</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">AGGREGATE</span><span class="w"> </span><span class="n">cat</span><span class="p">.</span><span class="w"></span>
<span class="w">              </span><span class="o">!!</span><span class="w"> </span><span class="n">Allocatable</span><span class="w"> </span><span class="n">Arrays</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">ALLOCATABLE</span><span class="w"> </span><span class="n">category</span><span class="w"></span>
<span class="w">              </span><span class="o">!!</span><span class="w"> </span><span class="n">Scalars</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">explicitly</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">from</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">defaultmap</span><span class="p">(</span><span class="n">firstprivate</span><span class="o">:</span><span class="w"> </span><span class="n">aggregate</span><span class="w"> </span><span class="p">)</span><span class="w">  </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">defaultmap</span><span class="p">(</span><span class="n">firstprivate</span><span class="o">:</span><span class="w"> </span><span class="n">allocatable</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">changes</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">!!</span><span class="w">   </span><span class="n">not</span><span class="w"> </span><span class="n">returned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">host</span><span class="w"></span>
<span class="w">        </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">                     </span><span class="o">!!</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="n">returned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">host</span><span class="w"></span>
<span class="w">        </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">                     </span><span class="o">!!</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="n">returned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">host</span><span class="w"></span>

<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">D</span><span class="o">%</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="n">s1</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">       </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot; PASSED 4 of 4&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">deallocate</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>

</pre></div>
</div>
</div>
</div>
</section>
<section id="pointer-mapping">
<h2>Pointer Mapping<a class="headerlink" href="#pointer-mapping" title="Permalink to this headline">#</a></h2>
<p>Pointers that contain host addresses require that those addresses are translated to device addresses for them to be useful in the context of a device data environment. Broadly speaking, there are two scenarios where this is important.</p>
<p>The first scenario is where the pointer is mapped to the device data environment, such that references to the pointer inside a <strong>target</strong> region are to the corresponding pointer. Pointer attachment ensures that the corresponding pointer will contain a device address when all of the following conditions are true:</p>
<ul class="simple">
<li><p>the pointer is mapped by directive  A  to a device;</p></li>
<li><p>a list item that uses the pointer as its base pointer (call it the <em>pointee</em>) is mapped, to the same device, by directive  B , which may be the same as  A ;</p></li>
<li><p>the effect of directive  B  is to create either the corresponding pointer or pointee in the device data environment of the device.</p></li>
</ul>
<p>Given the above conditions, pointer attachment is initiated as a result of directive  B  and subsequent references to the pointee list item in a target region that use the pointer will access the corresponding pointee. The corresponding pointer remains in this <em>attached</em> state until it is removed from the device data environment.</p>
<p>The second scenario, which is only applicable for C/C++, is where the pointer is implicitly privatized inside a <strong>target</strong> construct when it appears as the base pointer to a list item on the construct and does not appear explicitly as a list item in a <strong>map</strong> clause, <strong>is_device_ptr</strong> clause, or data-sharing attribute clause. This scenario can be further split into two cases: the list item is a zero-length array section (e.g.,  <em>p[:0]</em> ) or it is not.</p>
<p>If it is a zero-length array section, this will trigger a runtime check on entry to the <strong>target</strong> region for a previously mapped list item where the value of the pointer falls within the range of its base address and ending address. If such a match is found the private pointer is initialized to the device address corresponding to the value of the original pointer, and otherwise it is initialized to NULL (or retains its original value if the <strong>unified_address</strong> requirement is specified for that compilation unit).</p>
<p>If the list item (again, call it the <em>pointee</em>) is not a zero-length array section, the private pointer will be initialized such that references in the <strong>target</strong> region to the pointee list item that use the pointer will access the corresponding pointee.</p>
<p>The following example shows the basics of mapping pointers with and without associated storage on the host.</p>
<p>Storage for pointers  <em>ptr1</em>  and  <em>ptr2</em>  is created on the host.  To map storage that is associated with a pointer on the host, the data can be explicitly mapped as an array section so that the compiler knows  the amount of data to be assigned in the device (to the “corresponding” data storage area). On the <strong>target</strong> construct array sections are mapped; however, the pointer  <em>ptr1</em>  is mapped, while  <em>ptr2</em>  is not. Since  <em>ptr2</em>  is not explicitly mapped, it is firstprivate.  This creates a subtle difference in the way these pointers can be used.</p>
<p>As a firstprivate pointer,  <em>ptr2</em>  can be manipulated on the device; however, as an explicitly mapped pointer,   <em>ptr1</em>  becomes an <em>attached</em> pointer and cannot be manipulated. In both cases the host pointer is not updated with the device pointer  address—as one would expect for distributed memory.  The storage data on the host is updated from the corresponding device data at the end of the <strong>target</strong> region.</p>
<p>As a comparison, note that the  <em>aray</em>  array is automatically mapped,  since the compiler knows the extent of the array.</p>
<p>The pointer  <em>ptr3</em>  is used inside the <strong>target</strong> construct, but it does not appear in a data-mapping or data-sharing clause. Nor is there a <strong>defaultmap</strong> clause on the construct to indicate what its implicit data-mapping or data-sharing attribute should be. For such a case,  <em>ptr3</em>  will be implicitly privatized within the construct and there will be a runtime check to see if the host memory to which it is pointing has corresponding memory in the device data environment. If this runtime check passes, the private  <em>ptr3</em>  would be initialized to point to the corresponding memory. But in this case the check does not pass and so it is initialized to null. Since  <em>ptr3</em>  is private, the value to which it is assigned in the <strong>target</strong> region is not returned into the original  <em>ptr3</em>  on the host.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.1</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">aray</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target map(ptr1, ptr1[:N]) map(ptr2[:N] )</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">ptr1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">ptr2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">aray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">     </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">//*(++ptr1) = 9;  //NOT ALLOWED since ptr1 is an attached pointer</span>
<span class="w">     </span><span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">ptr2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w">  </span><span class="c1">//    allowed since ptr2 is firstprivate</span>

<span class="w">     </span><span class="n">ptr3</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"> </span><span class="c1">// ptr3 is firstprivate</span>
<span class="w">                                        </span><span class="c1">// ptr3 value not returned</span>
<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">ptr3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">ptr1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ptr3</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">     </span><span class="n">free</span><span class="p">(</span><span class="n">ptr3</span><span class="p">);</span><span class="w">     </span><span class="c1">// explicitly free allocated storage on device</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ptr1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ptr2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="c1">//        6  9</span>

<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">ptr2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the following example the global pointer  <em>p</em>  appears in a declare target directive.  Hence, the pointer  <em>p</em>  will  persist on the device throughout executions in all <strong>target</strong> regions.</p>
<p>The pointer is also used in an array section of a <strong>map</strong> clause on  a <strong>target</strong> construct.  When the pointer of storage associated with  a declare target directive is mapped, as for the array section  <em>p[:N]</em>  in the <strong>target</strong> construct, the array section on the device is <em>attached</em> to the device pointer  <em>p</em>  on entry to the construct, and the value of the device pointer  <em>p</em>  becomes undefined on exit.  (Of course, storage allocation for the array section on the device will occur before the  pointer on the device is <em>attached</em>.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.2</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>

<span class="cp">#pragma omp begin declare target</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">use_arg_p</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">use_global_p</span><span class="p">(</span><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target map(p[:N])  </span><span class="c1">// device p attached to array section</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">use_arg_p</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">use_global_p</span><span class="p">(</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w">                              </span><span class="c1">// value of host p is preserved</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %3.3d %3.3d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">         </span><span class="c1">// 003   297   &lt;- output</span>

<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// A #pragma omp begin declare target is optional here</span>
<span class="c1">// because of prototype spec</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">use_arg_p</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">use_global_p</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">   </span><span class="c1">// valid since p is in declare target and called from</span>
<span class="w">                 </span><span class="c1">// inside target region where p was attached to</span>
<span class="w">                 </span><span class="c1">// valid memory</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// A #pragma omp end declare target is optional here</span>
<span class="c1">// because of prototype spec</span>
</pre></div>
</div>
</div>
</div>
<p>The following two examples illustrate subtle differences in pointer attachment to device address because of the order of data mapping.</p>
<p>In example  <em>target_ptr_map.3a</em>   the global pointer  <em>p1</em>  points to array  <em>x</em>  and  <em>p2</em>  points to array  <em>y</em>  on the host. The array section  <em>x[:N]</em>  is mapped by the <strong>target</strong> <strong>enter</strong> <strong>data</strong> directive while array  <em>y</em>  is mapped on the <strong>target</strong> construct.  Since the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> directive is applied to the declaration of  <em>p1</em> ,  <em>p1</em>  is a treated like a mapped variable on the <strong>target</strong> construct and references to  <em>p1</em>  inside the construct will be to the corresponding  <em>p1</em>  that exists on the device.  However, the corresponding  <em>p1</em>  will be undefined since there is no pointer attachment for it. Pointer attachment for  <em>p1</em>  would require that (1)  <em>p1</em>  (or an lvalue expression that refers to the same storage as  <em>p1</em> ) appears as a base pointer to a list item in a <strong>map</strong> clause, and (2) the construct that has the <strong>map</strong> clause causes the list item to transition from <strong>not mapped</strong> to <strong>mapped</strong>. The conditions are clearly not satisfied for this example.</p>
<p>The problem for  <em>p2</em>  in this example is also subtle. It will be privatized inside the <strong>target</strong> construct, with a runtime check for whether the memory to which it is pointing has corresponding memory that is accessible on the device. If this check is successful, then the  <em>p2</em>  inside the construct would be appropriately initialized to point to that corresponding memory. Unfortunately, despite there being an implicit map of the array  <em>y</em>  (to which  <em>p2</em>  is pointing) on the construct, the order of this map relative to the initialization of  <em>p2</em>  is unspecified. Therefore, the initial value of  <em>p2</em>  will also be undefined.</p>
<p>Thus, referencing values via either  <em>p1</em>  or  <em>p2</em>  inside the <strong>target</strong> region would be invalid.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.3a</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 100</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="cp">#pragma omp begin declare target</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Explicitly map array section x[:N]</span>
<span class="w">  </span><span class="cp">#pragma omp target enter data map(x[:N])</span>

<span class="w">  </span><span class="cp">#pragma omp target  </span><span class="c1">// as if .. map(p1) map(p1[:0]) map(p2[:0]) map(y)</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Accessing the mapped arrays x,y is OK here.</span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Pointer attachment for p1 does not occur here</span>
<span class="w">    </span><span class="c1">//   because p1[:0] does not allocate a new array section and</span>
<span class="w">    </span><span class="c1">//   array x is present on the target construct as it was mapped</span>
<span class="w">    </span><span class="c1">//   before by the target enter data directive.</span>
<span class="w">    </span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">      </span><span class="c1">// accessing p1 is undefined</span>

<span class="w">    </span><span class="c1">// The initial value of p2 in the target region is undefined</span>
<span class="w">    </span><span class="c1">//   because map(y) may occur after map(p2[:0]).</span>
<span class="w">    </span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">      </span><span class="c1">// accessing p2 is undefined</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In example  <em>target_ptr_map.3b</em>  the mapping orders for arrays  <em>x</em>  and  <em>y</em>  were rearranged to allow proper pointer attachments. On the <strong>target</strong> construct, the <strong>map(x)</strong> clause triggers pointer attachment for  <em>p1</em>  to the device address of  <em>x</em> .  Pointer  <em>p2</em>  is assigned the device address of the previously mapped  array  <em>y</em> . Referencing values via either  <em>p1</em>  or  <em>p2</em>  inside the <strong>target</strong> region is now valid.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.3b</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 100</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="cp">#pragma omp begin declare target</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Explicitly map array section y[:N]</span>
<span class="w">  </span><span class="cp">#pragma omp target enter data map(y[:N])</span>

<span class="w">  </span><span class="cp">#pragma omp target map(x[:N]) map(p1[:N]) map(p2[:0])</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Accessing the mapped arrays x,y is OK here.</span>
<span class="w">    </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Pointer attachment for p1 occurs here when array x is mapped</span>
<span class="w">    </span><span class="c1">//   on the target construct (as p1 = &amp;x[0] on the device)</span>
<span class="w">    </span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">      </span><span class="c1">// accessing p1 is OK</span>

<span class="w">    </span><span class="c1">// p2 in the target region is initialized to &amp;y[0]</span>
<span class="w">    </span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">      </span><span class="c1">// accessing p2 is OK</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the following example, storage allocated on the host is not mapped in a <strong>target</strong> region if it is determined that the host memory is accessible from the device. On platforms that support host memory access from a target device,  it may be more efficient to omit map clauses and avoid the potential memory allocation  and data transfers that may result from the map. The <strong>omp_target_is_accessible</strong> API routine is used to determine if the  host storage of size  <em>buf_size</em>  is accessible on the device, and a metadirective is used to select the directive variant (a <strong>target</strong> with/without a <strong>map</strong> clause).</p>
<p>The <strong>omp_target_is_accessible</strong> routine will return true if the storage indicated  by the first and second arguments is accessible on the target device. In this case,  the host pointer  <em>ptr</em>  may be directly dereferenced in the subsequent  <strong>target</strong> region to access this storage, rather than mapping an array section based  off the pointer. By explicitly specifying the host pointer in a <strong>firstprivate</strong>  clause on the construct, its original value will be used directly in the <strong>target</strong> region.  In OpenMP 5.1, removing the <strong>firstprivate</strong> clause will result in an implicit presence  check of the storage to which  <em>ptr</em>  points, and since this storage is not mapped by the  program,  <em>ptr</em>  will be NULL-initialized in the <strong>target</strong> region.  In the next version of the OpenMP Specification, a false presence check without  the <strong>firstprivate</strong> clause will cause the pointer to retain its original value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.4</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">do_work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buf_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">buf_size</span><span class="p">);</span><span class="w"> </span><span class="c1">// possibly compiled on</span>
<span class="w">                                        </span><span class="c1">// Unified Shared Memory system</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">accessible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_is_accessible</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">buf_size</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">      when(user={condition(accessible)}: target firstprivate(ptr) ) \</span>
<span class="cp">      otherwise(                         target map(ptr[:n])      )</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">do_work</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

</pre></div>
</div>
</div>
</div>
<p>Similar to the previous example, the <strong>omp_target_is_accessible</strong> routine is used to discover if a deep copy is required for the platform.  Here, the  <em>deep_copy</em>  map, defined in the <strong>declare</strong> <strong>mapper</strong> directive, is used if the host storage referenced by   <em>s.ptr</em>  (or  <em>sptr</em>  in Fortran) is not accessible from the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_ptr_map.5</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">buf_size</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp declare mapper(deep_copy: T s) map(s, s.ptr[:s.buf_size])</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">do_work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buf_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">T</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">buf_size</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">s</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">buf_size</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">accessible</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">omp_target_is_accessible</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">buf_size</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp metadirective \</span>
<span class="cp">      when(user={condition(accessible)}: target) \</span>
<span class="cp">      otherwise(target map(mapper(deep_copy),tofrom:s) )</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">do_work</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w">       </span><span class="n">target_ptr_map</span><span class="mf">.5</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w">       </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>

<span class="w">   </span><span class="n">use</span><span class="p">,</span><span class="w"> </span><span class="n">intrinsic</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">iso_c_binding</span><span class="p">,</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c_loc</span><span class="p">,</span><span class="w"> </span><span class="n">c_size_t</span><span class="p">,</span><span class="w"> </span><span class="n">c_sizeof</span><span class="p">,</span><span class="w"> </span><span class="n">c_int</span><span class="w"></span>
<span class="w">   </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">   </span><span class="n">external</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">do_work</span><span class="w"></span>

<span class="w">   </span><span class="n">type</span><span class="w"> </span><span class="n">T</span><span class="w"></span>
<span class="w">     </span><span class="n">integer</span><span class="p">,</span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">ptr</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">integer</span><span class="w">         </span><span class="o">::</span><span class="w"> </span><span class="n">buf_size</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">type</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">mapper</span><span class="p">(</span><span class="n">deep_copy</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">(</span><span class="o">:</span><span class="n">s</span><span class="o">%</span><span class="n">buf_size</span><span class="p">))</span><span class="w"></span>

<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">accessible</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">(</span><span class="n">c_size_t</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">buf_size</span><span class="w"></span>

<span class="w">   </span><span class="n">type</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="w">   </span><span class="n">allocate</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="w"></span>

<span class="w">   </span><span class="n">buf_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">n</span><span class="w"></span>
<span class="w">   </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">()</span><span class="w"></span>

<span class="w">   </span><span class="n">accessible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_is_accessible</span><span class="p">(</span><span class="n">c_loc</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="w"> </span><span class="n">buf_size</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">begin</span><span class="w"> </span><span class="n">metadirective</span><span class="w">                              </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">when</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="p">{</span><span class="n">condition</span><span class="p">(</span><span class="n">accessible</span><span class="p">)}</span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">otherwise</span><span class="p">(</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">(</span><span class="n">deep_copy</span><span class="p">),</span><span class="n">tofrom</span><span class="o">:</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">do_work</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">end</span><span class="w">   </span><span class="n">metadirective</span><span class="w"></span>

<span class="w">   </span><span class="n">deallocate</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">ptr</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="structure-mapping">
<h2>Structure Mapping<a class="headerlink" href="#structure-mapping" title="Permalink to this headline">#</a></h2>
<p>In the example below, only structure elements  <em>S.a</em> ,  <em>S.b</em>  and  <em>S.p</em>   of the  <em>S</em>  structure appear in <strong>map</strong> clauses of a <strong>target</strong> construct. Only these components have corresponding variables and storage on the device.   Hence, the large arrays,  <em>S.buffera</em>  and  <em>S.bufferb</em> , and the  <em>S.x</em>  component have no storage  on the device and cannot be accessed.</p>
<p>Also, since the pointer member  <em>S.p</em>  is used in an array section of a  <strong>map</strong> clause, the array storage of the array section on the device,   <em>S.p[:N]</em> , is <em>attached</em> to the pointer member  <em>S.p</em>  on the device. Explicitly mapping the pointer member  <em>S.p</em>  is optional in this case.</p>
<p>Note: The buffer arrays and the  <em>x</em>  variable have been grouped together, so that the components that will reside on the device are all together (without gaps). This allows the runtime to optimize the transfer and the storage footprint on the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_struct_map.1</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>
<span class="cp">#define BAZILLION 2000000</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buffera</span><span class="p">[</span><span class="n">BAZILLION</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">bufferb</span><span class="p">[</span><span class="n">BAZILLION</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">saxpyfun</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">S</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target map(alloc:S.p) map(S.p[:N]) map(to:S.a, S.b)</span>
<span class="w">  </span><span class="n">saxpyfun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %4.0f %4.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="c1">//     4  202  &lt;- output</span>

<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example is a slight modification of the above example for  a C++ class.  In the member function  <em>SAXPY::driver</em>   the array section  <em>p[:N]</em>  is <em>attached</em> to the pointer member  <em>p</em>  on the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_struct_map.2</span>
<span class="cm">* type:       C++</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>

<span class="n">class</span><span class="w"> </span><span class="n">SAXPY</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">private</span><span class="o">:</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="n">SAXPY</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">arg_a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">arg_b</span><span class="p">){</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="n">arg_a</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="n">arg_b</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="n">driver</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="nf">saxpyfun</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">SAXPY::saxpyfun</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">SAXPY::driver</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp target map(alloc:p) map(to:p[:N]) map(to:a,b) \</span>
<span class="cp">              map(from:buffer[:N])   </span><span class="c1">// attach(p) to device_malloc()</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">saxpyfun</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">SAXPY</span><span class="w"> </span><span class="n">my_saxpy</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">4.0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">my_saxpy</span><span class="p">.</span><span class="n">driver</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %4.0f %4.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_saxpy</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">my_saxpy</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">         </span><span class="c1">//   4   202     &lt;- output</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The next example shows two ways in which the structure may be <em>incorrectly</em> mapped.</p>
<p>In Case 1, the array section  <em>S1.p[:N]</em>  is first mapped in an enclosing <strong>target</strong> <strong>data</strong> construct, and the <strong>target</strong> construct then implicitly maps the structure  <em>S1</em> . The initial map of the array section does not map the base pointer  <em>S1.p</em>  – it only maps the elements of the array section.  Furthermore, the implicit map is not sufficient to ensure pointer attachment for the structure member  <em>S1.p</em>  (refer to the conditions for pointer attachment described in Section 6.3). Consequentially, the dereference operation  <em>S1.p[i]</em>  in the call to  <em>saxpyfun</em>  will probably fail because  <em>S1.p</em>  contains a host address.</p>
<p>In Case 2, again an array section is mapped on an enclosing <strong>target</strong> <strong>data</strong> construct. This time, the nested <strong>target</strong> construct explicitly maps  <em>S2.p</em> ,  <em>S2.a</em> , and  <em>S2.b</em> . But as in Case 1, this does not satisfy the conditions for pointer attachment since the construct must map a list item for which  <em>S2.p</em>  is a base pointer, and it must do so when the  <em>S2.p</em>  is already present on the device or will be created on the device as a result of the same construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_struct_map.3</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>
<span class="cp">#define BAZILLION 2000000</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buffera</span><span class="p">[</span><span class="n">BAZILLION</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">bufferb</span><span class="p">[</span><span class="n">BAZILLION</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">saxpyfun</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// S-&gt;p[i] invalid</span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="n">S1</span><span class="p">,</span><span class="w"> </span><span class="n">S2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Case 1</span>

<span class="w">  </span><span class="n">S1</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S1</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// No pointer attachment for S1.p here</span>
<span class="w">  </span><span class="cp">#pragma omp target data map(S1.p[:N])</span>
<span class="w">  </span><span class="cp">#pragma omp target </span><span class="c1">// implicit map of S1</span>
<span class="w">  </span><span class="n">saxpyfun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S1</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Case 2</span>

<span class="w">  </span><span class="n">S2</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S2</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// No pointer attachment for S2.p here either</span>
<span class="w">  </span><span class="cp">#pragma omp target data map(S2.p[:N])</span>
<span class="w">  </span><span class="cp">#pragma omp target map(S2.p, S2.a, S2.b) </span><span class="c1">// implicit map of S2</span>
<span class="w">  </span><span class="n">saxpyfun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// These print statement may not execute because the</span>
<span class="w">  </span><span class="c1">// above code is invalid</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %4.0f %4.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %4.0f %4.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>

<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example correctly implements pointer attachment cases that involve implicit structure maps.</p>
<p>In Case 1, members  <em>p</em> ,  <em>a</em> , and  <em>b</em>  of the structure  <em>S1</em>  are explicitly mapped by the <strong>target</strong> <strong>data</strong> construct, to avoid mapping parts of  <em>S1</em>  that aren’t required on the device. The mapped  <em>S1.p</em>  is attached to the array section  <em>S1.p[:N]</em> , and remains attached while it exists on the device (for the duration of <strong>target</strong> <strong>data</strong> region).  Due to the  <em>S1</em>  reference inside the nested <strong>target</strong> construct, the construct implicitly maps  <em>S1</em>  so that the reference refers to the corresponding storage created by the enclosing <strong>target</strong> <strong>data</strong> region. Note that only the members  <em>a</em> ,  <em>b</em> , and  <em>p</em>  may be accessed from this storage.</p>
<p>In Case 2, only the storage for the array section  <em>S2.p[:N]</em>  is mapped by the <strong>target</strong> <strong>data</strong> construct.  The nested <strong>target</strong> construct explicitly maps  <em>S2.a</em>  and  <em>S2.b</em>  and explicitly maps an array section for which  <em>S2.p</em>  is a base pointer. This satisfies the conditions for  <em>S2.p</em>  becoming an attached pointer. The array section in this case is zero-length, but the effect would be the same if the length was a positive integer less than or equal to  <em>N</em> . There is also an implicit map of the containing structure  <em>S2</em> , again due to the reference to  <em>S2</em>  inside the construct. The effect of this implicit map permits access only to members  <em>a</em> ,  <em>b</em> , and  <em>p</em> , as for Case 1.</p>
<p>In Case 3, there is no <strong>target</strong> <strong>data</strong> construct. The <strong>target</strong> construct explicitly maps  <em>S3.a</em>  and  <em>S3.b</em>  and explicitly maps an array section for which  <em>S3.p</em>  is a base pointer. Again, there is an implicit map of the structure referenced in the construct,  <em>S3</em> . This implicit map also causes  <em>S3.p</em>  to be implicitly mapped, because no other part of  <em>S3</em>  is present prior to the construct being encountered. The result is an attached pointer  <em>S3.p</em>  on the device. As for Cases 1 and 2, this implicit map only ensures that storage for the members  <em>a</em> ,  <em>b</em> , and  <em>p</em>  are accessible within the corresponding  <em>S3</em>  that is created on the device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       target_struct_map.4</span>
<span class="cm">* type:       C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>
<span class="cp">#define BAZILLION 2000000</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buffera</span><span class="p">[</span><span class="n">BAZILLION</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">bufferb</span><span class="p">[</span><span class="n">BAZILLION</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">saxpyfun</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="n">S1</span><span class="p">,</span><span class="w"> </span><span class="n">S2</span><span class="p">,</span><span class="w"> </span><span class="n">S3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Case 1</span>

<span class="w">  </span><span class="n">S1</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S1</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// The target data construct results in pointer attachment for S1.p.</span>
<span class="w">  </span><span class="c1">// Explicitly mapping S1.p, S1.a, and S1.b rather than S1 avoids</span>
<span class="w">  </span><span class="c1">// mapping the entire structure (including members buffera, bufferb,</span>
<span class="w">  </span><span class="c1">// and x).</span>
<span class="w">  </span><span class="cp">#pragma omp target data map(S1.p[:N],S1.p,S1.a,S1.b)</span>
<span class="w">  </span><span class="cp">#pragma omp target </span><span class="c1">//implicit map of S1</span>
<span class="w">  </span><span class="n">saxpyfun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S1</span><span class="p">);</span><span class="w"></span>


<span class="w">  </span><span class="c1">// Case 2</span>

<span class="w">  </span><span class="n">S2</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S2</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// The target construct results in pointer attachment for S2.p.</span>
<span class="w">  </span><span class="cp">#pragma omp target data map(S2.p[:N])</span>
<span class="w">  </span><span class="cp">#pragma omp target map(S2.p[:0], S2.a, S2.b) </span><span class="c1">// implicit map of S2</span>
<span class="w">  </span><span class="n">saxpyfun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Case 3</span>

<span class="w">  </span><span class="n">S3</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S3</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S3</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">S3</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// The target construct results in pointer attachment for S3.p.</span>
<span class="w">  </span><span class="c1">// Note that S3.p is implicitly mapped due to the implicit map of S3</span>
<span class="w">  </span><span class="c1">// (but corresponding storage is NOT created for members buffera,</span>
<span class="w">  </span><span class="c1">// bufferb, and x).</span>
<span class="w">  </span><span class="cp">#pragma omp target map(S3.p[:N], S3.a, S3.b)  </span><span class="c1">// implicit map of S3</span>
<span class="w">  </span><span class="n">saxpyfun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S3</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %4.0f %4.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w">  </span><span class="c1">//OUT1 4 202</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %4.0f %4.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w">  </span><span class="c1">//OUT2 4 202</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; %4.0f %4.0f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">S3</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">S3</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w">  </span><span class="c1">//OUT3 4 202</span>

<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">S1</span><span class="p">.</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">S2</span><span class="p">.</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">S3</span><span class="p">.</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="fortran-allocatable-array-mapping">
<h2>Fortran Allocatable Array Mapping<a class="headerlink" href="#fortran-allocatable-array-mapping" title="Permalink to this headline">#</a></h2>
<p>The following examples illustrate the use of Fortran allocatable arrays in <strong>target</strong> regions.</p>
<p>In the first example,  allocatable variables (<em>a</em> and <em>b</em>) are first allocated
on the host, and then mapped onto a device in the Target 1 and 2 sections, respectively.
For <em>a</em> the map is implicit and for <em>b</em> an explicit map is used.
Both are mapped with the default <strong>tofrom</strong> map type.
The user-level behavior is similar to non-allocatable arrays.
However, the mapping operations include creation of the allocatable variable,
creation of the allocated storage, setting the allocation status to allocated,
and making sure the allocatable variable references the storage.</p>
<p>In Target 3 and 4 sections, allocatable variables are mapped in two
different ways before they are allocated on the host and subsequently used on the device.
In one case, a <strong>target data</strong> construct creates an enclosing region for
the allocatable variable to persist, and in the other case a
<strong>declare target</strong> directive maps the allocation variable for all device executions.
In both cases the new array storage is mapped <strong>tofrom</strong> with the <strong>always</strong> modifier.
An explicit map is used here with an <strong>always</strong> modifier to ensure that the allocatable
variable status is updated on the device.</p>
<p>Note: OpenMP 5.1 specifies that an <strong>always</strong> map modifier guarantees the
allocation status update for an existing allocatable variable on the device.
In OpenMP 6.0, this restriction may be relaxed to also guarantee updates
without the <strong>always</strong> modifier.</p>
<p>In Target 3 and 4 sections, the behavior of an allocatable variable is very
much like a Fortran pointer, in which a pointer can be mapped to a device with an associated
or disassociated status, and associated storage can be mapped and attached as needed.
For allocatable variables, the update of the allocation status to allocated (allowing
reference to allocated storage) on the device, is similar to pointer attachment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! @@name:       target_fort_allocatable_map.1
! @@type:       F-free
! @@compilable: yes
! @@linkable:   yes
! @@expect:     success
! @@version:    omp_5.1
program main
  implicit none
  integer :: i

  integer, save, allocatable :: d(:)
  !$omp    declare target(d)

  integer, allocatable :: a(:)
  integer, allocatable :: b(:)
  integer, allocatable :: c(:)

  allocate(a(4))
  !$omp target                      ! Target 1
    a(:) = 4
  !$omp end target
  print *, a ! prints 4*4

  allocate(b(4))
  !$omp target map(b)               ! Target 2 
    b(:) = 4
  !$omp end target
  print *, b ! prints 4*4

  !$omp target data map(c)
  
    allocate(c(4), source=[1,2,3,4])
    !$omp target map(always,tofrom:c) ! Target 3 
       c(:) = 4
    !$omp end target 
    print *, c ! prints 4*4

    deallocate(c)
  
  !$omp end target data

  allocate(d(4), source=[1,2,3,4])
  !$omp target map(always,tofrom:d) ! Target 4
     d(:) = d(:) + [ ( i,i=size(d),1,-1) ]
  !$omp end target
  print *, d ! prints 4*5

  deallocate(a, b, d)

end program
</pre></div>
</div>
</div>
</div>
<p>Once an allocatable variable has been allocated on the host,
its allocation status may not be changed in a <strong>target</strong> region, either
explicitly or implicitly. The following example illustrates typical
operations on allocatable variables that violate this restriction.
Note, an assignment that reshapes or reassigns (causing a deallocation
and allocation) in a <strong>target</strong> region is not conforming.
Also, an initial intrinsic assignment of an allocatable variable
requires deallocation before the <strong>target</strong> region ends.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! @@name:       target_fort_allocatable_map.2
! @@type:       F-free
! @@compilable: yes
! @@linkable:   yes
! @@expect:     unspecified
! @@version:    omp_5.1
program main
  implicit none

  integer, allocatable :: a(:,:), b(:), c(:)
  integer              :: x(10,2)

  allocate(a(2,10))

  !$omp target
     a = x             ! Reshape (or resize) NOT ALLOWED (implicit change)

     deallocate(a)     ! Allocation status change of &quot;a&quot; NOT ALLOWED.

     allocate(b(20))   ! Allocation of  b *

     c = 10            ! Intrinsic assignment allocates c *

     ! * Since an explicit deallocation for b and c does not occur before 
     ! the end of the target region, the PROGRAM BEHAVIOR IS UNSPECIFIED.
  !$omp end target

end program
</pre></div>
</div>
</div>
</div>
<p>The next example illustrates a corner case of this restriction (allocatable status
change in a <strong>target</strong> region).
Two allocatable arrays are passed to a subroutine within a <strong>target</strong>
region. The dummy-variable arrays are declared allocatable.
Also, the <em>ain</em> variable has the <em>intent(in)</em> attribute, and <em>bout</em>
has the <em>intent(out)</em> attribute.
For the dummy argument with the attributes <em>allocatable</em> and <em>intent(out)</em>,
the compiler will deallocate the associated actual argument when the subroutine is invoked.
(However, the allocation on procedure entry can be avoided by specifying the intent
as <em>intent(inout)</em>, making the intended use conforming.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! @@name:       target_fort_allocatable_map.3
! @@type:       F-free
! @@compilable: yes
! @@linkable:   no
! @@expect:     fail
! @@version:    omp_5.1
module corfu
contains
  subroutine foo(ain,bout)
    implicit none
    integer, allocatable, intent( in) :: ain(:)
    integer, allocatable, intent(out) :: bout(:) !&quot;out&quot; causes de/realloc
    !$omp declare target
    bout = ain
  end subroutine
end module

program  main
  use corfu
  implicit none

  integer, allocatable :: a(:)
  integer, allocatable :: b(:)
  allocate(a(10),b(10))
  a(:)=10
  b(:)=10

  !$omp target

  call foo(a,b) !ERROR: b deallocation/reallocation not allowed
                !  in target region

  !$omp end target

end program
</pre></div>
</div>
</div>
</div>
</section>
<section id="array-sections-in-device-constructs">
<h2>Array Sections in Device Constructs<a class="headerlink" href="#array-sections-in-device-constructs" title="Permalink to this headline">#</a></h2>
<p>The following examples show the usage of array sections in <strong>map</strong> clauses  on <strong>target</strong> and <strong>target</strong> <strong>data</strong> constructs.</p>
<p>This example shows the invalid usage of two separate sections of the same array  inside of a <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: array_sections.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span><span class="w"></span>
<span class="cp">#pragma omp target data map( A[0:4] )</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cm">/* Cannot map distinct parts of the same array */</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map( A[7:20] )</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">array_sections</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"></span>
<span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="w"> </span><span class="n">Cannot</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">distinct</span><span class="w"> </span><span class="n">parts</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">array</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">8</span><span class="o">:</span><span class="mi">27</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>This example shows the invalid usage of two separate sections of the same array  inside of a <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: array_sections.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">30</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp target data map( A[0:4] )</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="cm">/* invalid because p[3] and A[3] are the same</span>
<span class="cm">    * location on the host but the array section</span>
<span class="cm">    * specified via p[...] is not a subset of A[0:4] */</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map( p[3:20] )</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">array_sections</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">target</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">A</span><span class="o">=</span><span class="mi">1</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="o">=&gt;</span><span class="n">A</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="w"> </span><span class="n">invalid</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">section</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="w"> </span><span class="n">specified</span><span class="w"> </span><span class="n">via</span><span class="w"> </span><span class="n">p</span><span class="p">(...)</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">4</span><span class="o">:</span><span class="mi">23</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>This example shows the valid usage of two separate sections of the same array inside  of a <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: array_sections.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">30</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp target data map( A[0:4] )</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map( p[7:20] )</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">array_sections</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">target</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="o">=&gt;</span><span class="n">A</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">8</span><span class="o">:</span><span class="mi">27</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>This example shows the valid usage of a wholly contained array section of an already  mapped array section inside of a <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: array_sections.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">30</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp target data map( A[0:10] )</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map( p[3:7] )</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">array_sections</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">target</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="o">=&gt;</span><span class="n">A</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">4</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="c-virtual-functions">
<h2>C++ Virtual Functions<a class="headerlink" href="#c-virtual-functions" title="Permalink to this headline">#</a></h2>
<p>The 5.2 OpenMP Specification clarified restrictions on the use
of polymorphic classes and virtual functions when used within
<strong>target</strong> regions.  The following example identifies
problem cases in which the restrictions are not followed
(for Unified Shared Memory, as prescribed by the <strong>requires</strong>
directive).</p>
<p>The first section illustrates the restriction
that when mapping an object for the first time,
the static and dynamic types must match.</p>
<p>For the first target region the behavior of the implicit map of <em>ar</em>
is not specified - its static type (A) doesn’t match its dynamic type (D).<br />
Hence access to the virtual functions is undefined.
However, the second target region can access <em>D::vf()</em>
since the object to which <em>ap</em> points is not mapped and
therefore the restriction does not apply.</p>
<p>The second section illustrates the restriction:</p>
<p><em>“Invoking a virtual member function of an object on a device other than the device on which the
object was constructed results in unspecified behavior, unless the object is accessible and was
constructed on the host device.”</em></p>
<p>An instantiation of a polymorphic class (<em>A</em>) occurs in the
<strong>target</strong> region, and access of its virtual function
is incorrectly attempted on the host (another device).
However, once the object is deleted on
the target device and instantiated on the host, access within
the next <strong>target</strong> region is permitted.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* @@name:       virtual_functions.1</span>
<span class="cm">* @@type:       C++</span>
<span class="cm">* @@compilable: yes</span>
<span class="cm">* @@linkable:   no</span>
<span class="cm">* @@expect:     success</span>
<span class="cm">* @@version:	omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#pragma omp requires unified_shared_memory</span>

<span class="cp">#pragma omp begin declare target</span>
<span class="n">class</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">  </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">   </span><span class="n">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">vf</span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;In A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">class</span><span class="w"> </span><span class="n">D</span><span class="o">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="n">vf</span><span class="p">()</span><span class="w"> </span><span class="n">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;In D</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Section 1 --------------------------------------------------------</span>
<span class="w">   </span><span class="n">D</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">               </span><span class="c1">// D derives from A, and A::vf() is virtual</span>
<span class="w">   </span><span class="n">A</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">         </span><span class="c1">// reference to Derived object d</span>

<span class="w">   </span><span class="cp">#pragma omp target </span><span class="c1">// implicit map of ar is illegal here</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ar</span><span class="p">.</span><span class="n">vf</span><span class="p">();</span><span class="w">        </span><span class="c1">// unspecified whether A::vf() or D::vf() is called</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="n">ap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">;</span><span class="w">        </span><span class="c1">// pointer to derived object d</span>
<span class="w">   </span><span class="cp">#pragma omp target </span><span class="c1">// No need for mapping with Unified Share Memory</span>
<span class="w">   </span><span class="p">{</span><span class="w">                  </span><span class="c1">// implicit ap[:0] map is fine </span>
<span class="w">      </span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">vf</span><span class="p">();</span><span class="w">       </span><span class="c1">// calls D::vf()</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Section 2 --------------------------------------------------------</span>
<span class="w">   </span><span class="n">ap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(ap)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">A</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">vf</span><span class="p">();</span><span class="w">     </span><span class="c1">// illegal</span>

<span class="w">   </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">delete</span><span class="w"> </span><span class="n">ap</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">ap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">A</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target  </span><span class="c1">// No need for mapping with Unified Share Memory</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">vf</span><span class="p">();</span><span class="w">  </span><span class="c1">// ok</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="array-shaping">
<h2>Array Shaping<a class="headerlink" href="#array-shaping" title="Permalink to this headline">#</a></h2>
<p>A pointer variable can be shaped to a multi-dimensional array to facilitate data access. This is achieved by a  <em>shape-operator</em>  casted in front of  a pointer (lvalue expression):<br />
<strong>([ s<sub>1</sub>][ s<sub>2</sub>]…[ s<sub>n</sub>])</strong> <em>pointer</em><br />
where each  s<sub>i</sub>  is an integral-type expression of positive value. The shape-operator can appear in either the  <em>motion-clause</em>  of the <strong>target</strong> <strong>update</strong> directive or the <strong>depend</strong> clause.</p>
<p>The following example shows the use of the shape-operator in the  <strong>target</strong> <strong>update</strong> directive. The shape-operator <strong>([nx][ny+2])</strong> casts pointer variable <em>a</em> to a 2-dimentional array of size  <em>nx</em>  x  <em>(ny+2)</em> .  The resulting array is then accessed as array sections (such as <strong>[0:nx][1]</strong> and <strong>[0:nx][ny]</strong>)  in the <strong>from</strong> or <strong>to</strong> clause for transferring two columns of  noncontiguous boundary data from or to the device.   Note the use of additional parentheses around the shape-operator and <em>a</em> to ensure the correct precedence  over array-section operations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: array_shaping.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#pragma omp begin declare target</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">do_work</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">other_work</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="p">);</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">exch_data</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">array_shaping</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// map data to device and do work</span>
<span class="w">   </span><span class="cp">#pragma omp target data map(a[0:nx*(ny+2)])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// do work on the device</span>
<span class="w">      </span><span class="cp">#pragma omp target  </span><span class="c1">// map(a[0:nx*(ny+2)]) is optional here</span>
<span class="w">      </span><span class="n">do_work</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// update boundary points (two columns of 2D array) on the host</span>
<span class="w">      </span><span class="c1">// pointer is shaped to 2D array using the shape-operator</span>
<span class="w">      </span><span class="cp">#pragma omp target update from( (([nx][ny+2])a)[0:nx][1], \</span>
<span class="cp">                                      (([nx][ny+2])a)[0:nx][ny] )</span>

<span class="w">      </span><span class="c1">// exchange ghost points with neighbors</span>
<span class="w">      </span><span class="n">exch_data</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// update ghost points (two columns of 2D array) on the device</span>
<span class="w">      </span><span class="c1">// pointer is shaped to 2D array using the shape-operator</span>
<span class="w">      </span><span class="cp">#pragma omp target update to( (([nx][ny+2])a)[0:nx][0], \</span>
<span class="cp">                                    (([nx][ny+2])a)[0:nx][ny+1] )</span>

<span class="w">      </span><span class="c1">// perform other work on the device</span>
<span class="w">      </span><span class="cp">#pragma omp target  </span><span class="c1">// map(a[0:nx*(ny+2)]) is optional here</span>
<span class="w">      </span><span class="n">other_work</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The shape operator is not defined for Fortran.  Explicit array shaping of procedure arguments can be used instead to achieve a similar goal. Below is the Fortran-equivalent of the above example that illustrates the support of transferring two rows of noncontiguous boundary data in the <strong>target</strong> <strong>update</strong> directive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">array_shaping</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.2</span><span class="w"></span>

<span class="n">module</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">   </span><span class="n">interface</span><span class="w"></span>
<span class="w">      </span><span class="n">subroutine</span><span class="w"> </span><span class="n">do_work</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">enter</span><span class="p">(</span><span class="n">do_work</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="w"></span>
<span class="w">         </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="o">:</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">do_work</span><span class="w"></span>

<span class="w">      </span><span class="n">subroutine</span><span class="w"> </span><span class="n">other_work</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">enter</span><span class="p">(</span><span class="n">other_work</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="w"></span>
<span class="w">         </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="o">:</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">other_work</span><span class="w"></span>

<span class="w">      </span><span class="n">subroutine</span><span class="w"> </span><span class="n">exch_data</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="w"></span>
<span class="w">         </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="o">:</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">exch_data</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">interface</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="n">m</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">array_shaping</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">   </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="w"></span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="o">:</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">work</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">device</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">optional</span><span class="w"> </span><span class="n">here</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">do_work</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">boundary</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="p">(</span><span class="n">two</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">2</span><span class="n">D</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">host</span><span class="p">.</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">transferred</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">noncontiguous</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">from</span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="n">ny</span><span class="p">),</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="n">ny</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">exchange</span><span class="w"> </span><span class="n">ghost</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">neighbors</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">exch_data</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">ghost</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="p">(</span><span class="n">two</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">2</span><span class="n">D</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">transferred</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">noncontiguous</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">to</span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="n">ny</span><span class="p">),</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="n">ny</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">device</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w">      </span><span class="o">!</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">optional</span><span class="w"> </span><span class="n">here</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">other_work</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-mapper-directive">
<h2><strong>declare mapper</strong> Directive<a class="headerlink" href="#declare-mapper-directive" title="Permalink to this headline">#</a></h2>
<p>The following examples show how to use the <strong>declare mapper</strong> directive to prescribe a map for later use. It is also quite useful for pre-defining partitioned and nested  structure elements.</p>
<p>In the first example the <strong>declare mapper</strong> directive specifies  that any structure of type  <em>myvec_t</em>  for which implicit data-mapping rules apply will be mapped according to its <strong>map</strong> clause. The variable  <em>v</em>  is used for referencing the structure and its  elements within the <strong>map</strong> clause.  Within the <strong>map</strong> clause the  <em>v</em>  variable specifies that all elements of the structure are to be mapped.  Additionally, the array section  <em>v.data[0:v.len]</em>  specifies that the dynamic  storage for data is to be mapped.</p>
<p>Within the main program the  <em>s</em>  variable is typed as  <em>myvec_t</em> . Since the variable is found within the target region and the type has a mapping prescribed by a <strong>declare mapper</strong> directive, it will be automatically mapped according to its prescription:  full structure, plus the dynamic storage of the  <em>data</em>  element.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_mapper.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w">  </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">   </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#define N 100</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">myvec</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">myvec_t</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp declare mapper(myvec_t v) \</span>
<span class="cp">                    map(v, v.data[0:v.len])</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">myvec_t</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">   </span><span class="n">myvec_t</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;s.data[%d]=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">N</span><span class="mi">-1</span><span class="p">,</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">]);</span><span class="w">  </span><span class="c1">//s.data[99]=99.000000</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">myvec_t</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w">       </span><span class="n">target_mapper</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w">       </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>

<span class="n">module</span><span class="w"> </span><span class="n">my_structures</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="w"> </span><span class="n">myvec_t</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="w">                     </span><span class="o">::</span><span class="w"> </span><span class="n">len</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w">   </span><span class="o">::</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">my_structures</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">declare</span><span class="w"> </span><span class="n">mapper</span><span class="p">(</span><span class="n">myvec_t</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">         </span><span class="n">map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">%</span><span class="n">data</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">v</span><span class="o">%</span><span class="n">len</span><span class="p">))</span><span class="w"></span>

<span class="w">  </span><span class="n">type</span><span class="p">(</span><span class="n">myvec_t</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="w">  </span><span class="n">allocate</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="n">data</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">s</span><span class="o">%</span><span class="n">data</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="n">d0</span><span class="w"></span>
<span class="w">  </span><span class="n">s</span><span class="o">%</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">  </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">  </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot;s%data(&quot;</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="s">&quot;)=&quot;</span><span class="p">,</span><span class="n">s</span><span class="o">%</span><span class="n">data</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w">  </span><span class="o">!!</span><span class="w"> </span><span class="n">s</span><span class="o">%</span><span class="n">data</span><span class="p">(</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">)</span><span class="o">=</span><span class="mf">100.000000000000</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">my_structures</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="p">(</span><span class="n">myvec_t</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">s</span><span class="w"></span>

<span class="w">  </span><span class="n">s</span><span class="o">%</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">%</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The next example illustrates the use of the  <em>mapper-identifier</em>  and deep copy within a structure.  The structure,  <em>dzmat_t</em> ,  represents a complex matrix,  with separate real ( <em>r_m</em> ) and imaginary ( <em>i_m</em> ) elements. Two map identifiers are created for partitioning the  <em>dzmat_t</em>  structure.</p>
<p>For the C/C++ code the first identifier is named  <em>top_id</em>  and maps the top half of two matrices of type  <em>dzmat_t</em> ; while the second identifier,  <em>bottom_id</em> , maps the lower half of two matrices.  Each identifier is applied to a different <strong>target</strong> construct, as  <strong>map(mapper(top_id), tofrom: a,b)</strong>  and <strong>map(mapper(bottom_id), tofrom: a,b)</strong>. Each target offload is allowed to execute concurrently on two different devices  ( <em>0</em>  and  <em>1</em> ) through the <strong>nowait</strong> clause.</p>
<p>The Fortran code uses the  <em>left_id</em>  and  <em>right_id</em>  map identifiers in the <strong>map(mapper(left_id),tofrom: a,b)</strong> and <strong>map(mapper(right_id),tofrom: a,b)</strong> map clauses.   The array sections for these left and right contiguous portions of the matrices  were defined previously in the <strong>declare mapper</strong> directive.</p>
<p>Note, the  <em>is</em>  and  <em>ie</em>  scalars are firstprivate  by default for a target region, but are declared firstprivate anyway to remind the user of important firstprivate data-sharing properties required here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_mapper.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="c1">//                   N MUST BE EVEN</span>
<span class="cp">#define N  100</span>

<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dzmat</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">r_m</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">i_m</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">dzmat_t</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp declare mapper( top_id: dzmat_t v) \</span>
<span class="cp">                      map(v.r_m[0:N/2][0:N],     \</span>
<span class="cp">                          v.i_m[0:N/2][0:N]      )</span>

<span class="w">  </span><span class="cp">#pragma omp declare mapper(bottom_id: dzmat_t v) \</span>
<span class="cp">                      map(v.r_m[N/2:N/2][0:N],     \</span>
<span class="cp">                          v.i_m[N/2:N/2][0:N]      )</span>
<span class="c1">//initialization</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">dzmat_init</span><span class="p">(</span><span class="n">dzmat_t</span><span class="w"> </span><span class="o">*</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">is</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ie</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="c1">//matrix add: c=a+b</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">host_add</span><span class="p">(</span><span class="w">  </span><span class="n">dzmat_t</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dzmat_t</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">dzmat_t</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>


<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">dzmat_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w">     </span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">is</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ie</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="mi">2-1</span><span class="p">;</span><span class="w">       </span><span class="c1">//top N/2 rows on device 0</span>
<span class="w">  </span><span class="cp">#pragma omp target map(mapper(top_id), tofrom: a,b) device(0) \</span>
<span class="cp">                     firstprivate(is,ie) nowait</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">dzmat_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dzmat_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">is</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">ie</span><span class="o">=</span><span class="n">N</span><span class="mi">-1</span><span class="p">;</span><span class="w">       </span><span class="c1">//bottom N/2 rows on device 1</span>
<span class="w">  </span><span class="cp">#pragma omp target map(mapper(bottom_id), tofrom: a,b) device(1) \</span>
<span class="cp">                     firstprivate(is,ie) nowait</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">dzmat_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dzmat_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp taskwait</span>

<span class="w">  </span><span class="n">host_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w">       </span><span class="n">target_mapper</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w">       </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">complex_mats</span><span class="w"></span>

<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="w">    </span><span class="o">!</span><span class="n">N</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">even</span><span class="w"></span>
<span class="w">   </span><span class="n">type</span><span class="w"> </span><span class="n">dzmat_t</span><span class="w"></span>
<span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">r_m</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">i_m</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">type</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">declare</span><span class="w"> </span><span class="n">mapper</span><span class="p">(</span><span class="w"> </span><span class="n">left_id</span><span class="o">:</span><span class="w"> </span><span class="n">dzmat_t</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">v</span><span class="o">%</span><span class="n">r_m</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">                                             </span><span class="n">v</span><span class="o">%</span><span class="n">i_m</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">declare</span><span class="w"> </span><span class="n">mapper</span><span class="p">(</span><span class="n">right_id</span><span class="o">:</span><span class="w"> </span><span class="n">dzmat_t</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">v</span><span class="o">%</span><span class="n">r_m</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">                                             </span><span class="n">v</span><span class="o">%</span><span class="n">i_m</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">:</span><span class="n">N</span><span class="p">))</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>


<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w">  </span><span class="n">complex_mats</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="p">(</span><span class="n">dzmat_t</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="w"></span>
<span class="w">  </span><span class="n">external</span><span class="w"> </span><span class="n">dzmat_init</span><span class="p">,</span><span class="w"> </span><span class="n">host_add</span><span class="w">  </span><span class="o">!</span><span class="n">initialization</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="n">add</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="w"></span>


<span class="w">  </span><span class="n">is</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ie</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="w">            </span><span class="o">!</span><span class="n">left</span><span class="w"> </span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">columns</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">(</span><span class="w"> </span><span class="n">left_id</span><span class="p">),</span><span class="w"> </span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">firstprivate</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">)</span><span class="w"> </span><span class="n">nowait</span><span class="w"></span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">dzmat_init</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">dzmat_init</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">  </span><span class="n">is</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ie</span><span class="o">=</span><span class="n">N</span><span class="w">         </span><span class="o">!</span><span class="n">right</span><span class="w"> </span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">columns</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">(</span><span class="n">right_id</span><span class="p">),</span><span class="w"> </span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">       </span><span class="n">firstprivate</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">)</span><span class="w"> </span><span class="n">nowait</span><span class="w"></span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">dzmat_init</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">dzmat_init</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">is</span><span class="p">,</span><span class="n">ie</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">taskwait</span><span class="w"></span>

<span class="w">  </span><span class="n">call</span><span class="w"> </span><span class="n">host_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the third example  <em>myvec</em>  structures are nested within a  <em>mypoints</em>  structure. The  <em>myvec_t</em>  type is mapped as in the first example.  Following the  <em>mypoints</em>  structure declaration,  the  <em>mypoints_t</em>  type is mapped by a <strong>declare mapper</strong> directive.  For this structure the  <em>hostonly_data</em>  element will not be mapped; also the array section of  <em>x</em>  ( <em>v.x[:1]</em> ) and  <em>x</em>  will be mapped; and  <em>scratch</em>  will be allocated and used as scratch storage on the device. The default map-type mapping, <strong>tofrom</strong>, applies to the  <em>x</em>  array section, but not to  <em>scratch</em>  which is explicitly mapped with the <strong>alloc</strong> map-type.  Note: the variable  <em>v</em>  is not included in the map list (otherwise the  <em>hostonly_data</em>  would be mapped) - just the elements  to be mapped are listed.</p>
<p>The two mappers are combined when a  <em>mypoints_t</em>  structure type is mapped, because the mapper  <em>myvec_t</em>  structure type is used within a  <em>mypoints_t</em>  type structure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_mapper.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w">  </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#define N 100</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">myvec</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">myvec_t</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp declare mapper(myvec_t v) \</span>
<span class="cp">                    map(v, v.data[0:v.len])</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mypoints</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">myvec</span><span class="w"> </span><span class="n">scratch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">myvec</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">hostonly_data</span><span class="p">[</span><span class="mi">500000</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">mypoints_t</span><span class="p">;</span><span class="w"></span>

<span class="cp">#pragma omp declare mapper(mypoints_t v)  \</span>
<span class="cp">                    map(v.x, v.x[0] ) map(alloc:v.scratch)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init_mypts_array</span><span class="p">(</span><span class="n">mypoints_t</span><span class="w"> </span><span class="o">*</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">eval_mypts_array</span><span class="p">(</span><span class="n">mypoints_t</span><span class="w"> </span><span class="o">*</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>

<span class="w">   </span><span class="n">mypoints_t</span><span class="w"> </span><span class="n">P</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">init_mypts_array</span><span class="p">(</span><span class="o">&amp;</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target map(P)</span>
<span class="w">   </span><span class="n">eval_mypts_array</span><span class="p">(</span><span class="o">&amp;</span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w">       </span><span class="n">target_mapper</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w">       </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>

<span class="n">module</span><span class="w"> </span><span class="n">my_structures</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="w"> </span><span class="n">myvec_t</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="w">                   </span><span class="o">::</span><span class="w"> </span><span class="n">len</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">declare</span><span class="w"> </span><span class="n">mapper</span><span class="p">(</span><span class="n">myvec_t</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">         </span><span class="n">map</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">type</span><span class="w"> </span><span class="n">mypoints_t</span><span class="w"></span>
<span class="w">     </span><span class="n">type</span><span class="p">(</span><span class="n">myvec_t</span><span class="p">)</span><span class="w">            </span><span class="o">::</span><span class="w"> </span><span class="n">scratch</span><span class="w"></span>
<span class="w">     </span><span class="n">type</span><span class="p">(</span><span class="n">myvec_t</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w">   </span><span class="o">::</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w">         </span><span class="o">::</span><span class="w"> </span><span class="n">hostonly_data</span><span class="p">(</span><span class="mi">500000</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w">  </span><span class="n">type</span><span class="w"></span>
<span class="w"> </span><span class="o">!</span><span class="n">$omp</span><span class="w">  </span><span class="n">declare</span><span class="w"> </span><span class="n">mapper</span><span class="p">(</span><span class="n">mypoints_t</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w">  </span><span class="o">&amp;</span><span class="w"></span>
<span class="w"> </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">         </span><span class="n">map</span><span class="p">(</span><span class="n">v</span><span class="o">%</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">%</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">alloc</span><span class="o">:</span><span class="n">v</span><span class="o">%</span><span class="n">scratch</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>


<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">my_structures</span><span class="w"></span>
<span class="w">  </span><span class="n">external</span><span class="w">  </span><span class="n">init_mypts_array</span><span class="p">,</span><span class="w"> </span><span class="n">eval_mypts_array</span><span class="w"></span>

<span class="w">  </span><span class="n">type</span><span class="p">(</span><span class="n">mypoints_t</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init_mypts_array</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">eval_mypts_array</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-data-construct">
<h2><strong>target</strong> <strong>data</strong> Construct<a class="headerlink" href="#target-data-construct" title="Permalink to this headline">#</a></h2>
<section id="simple-target-data-construct">
<h3>Simple <strong>target</strong> <strong>data</strong> Construct<a class="headerlink" href="#simple-target-data-construct" title="Permalink to this headline">#</a></h3>
<p>This example shows how the <strong>target</strong> <strong>data</strong> construct maps variables  to a device data environment. The <strong>target</strong> <strong>data</strong> construct creates  a new device data environment and maps the variables  <em>v1</em> ,  <em>v2</em> , and  <em>p</em>  to the new device  data environment. The <strong>target</strong> construct enclosed in the <strong>target</strong>  <strong>data</strong> region creates a new device data environment, which inherits the  variables  <em>v1</em> ,  <em>v2</em> , and  <em>p</em>  from the enclosing device data environment. The variable   <em>N</em>  is mapped into the new device data environment from the encountering task’s data  environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_data.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target data map(to: v1[0:N], v2[:N]) map(from: p[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran code passes a reference and specifies the extent of the arrays in the  declaration. No length information is necessary in the map clause, as is required  with C/C++ pointers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_data</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-data-region-enclosing-multiple-target-regions">
<h3><strong>target</strong> <strong>data</strong> Region Enclosing Multiple <strong>target</strong> Regions<a class="headerlink" href="#target-data-region-enclosing-multiple-target-regions" title="Permalink to this headline">#</a></h3>
<p>The following examples show how the <strong>target</strong> <strong>data</strong> construct maps  variables to a device data environment of a <strong>target</strong> region. The <strong>target</strong>  <strong>data</strong> construct creates a device data environment and encloses <strong>target</strong>  regions, which have their own device data environments. The device data environment  of the <strong>target</strong> <strong>data</strong> region is inherited by the device data environment  of an enclosed <strong>target</strong> region. The <strong>target</strong> <strong>data</strong> construct  is used to create variables that will persist throughout the <strong>target</strong> <strong>data</strong>  region.</p>
<p>In the following example the variables  <em>v1</em>  and  <em>v2</em>  are mapped at each <strong>target</strong>  construct. Instead of mapping the variable  <em>p</em>  twice, once at each <strong>target</strong>  construct,  <em>p</em>  is mapped once by the <strong>target</strong> <strong>data</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_data.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_again</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target data map(from: p[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target map(to: v1[:N], v2[:N])</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">init_again</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target map(to: v1[:N], v2[:N])</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran code uses reference and specifies the extent of the  <em>p</em> ,  <em>v1</em>  and  <em>v2</em>  arrays.  No length information is necessary in the <strong>map</strong> clause, as is required with  C/C++ pointers. The arrays  <em>v1</em>  and  <em>v2</em>  are mapped at each <strong>target</strong> construct.  Instead of mapping the array  <em>p</em>  twice, once at each target construct,  <em>p</em>  is mapped  once by the <strong>target</strong> <strong>data</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_data</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">init_again</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the following example, the array  <em>Q</em>  is mapped once at the enclosing  <strong>target</strong> <strong>data</strong> region instead of at each <strong>target</strong> construct.  In OpenMP 4.0, a scalar variable is implicitly mapped with the <strong>tofrom</strong> map-type. But since OpenMP 4.5, a scalar variable, such as the  <em>tmp</em>  variable, has to be explicitly mapped with  the <strong>tofrom</strong> map-type at the first <strong>target</strong> construct in order to return  its reduced value from the parallel loop construct to the host. The variable defaults to firstprivate at the second <strong>target</strong> construct.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_data.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>
<span class="cp">#define COLS 100</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">gramSchmidt</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">Q</span><span class="p">[][</span><span class="n">COLS</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">COLS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp target data map(Q[0:rows][0:cols])</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cp">#pragma omp target map(tofrom: tmp)</span>
<span class="w">        </span><span class="cp">#pragma omp parallel for reduction(+:tmp)</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">tmp</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>

<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cp">#pragma omp target</span>
<span class="w">        </span><span class="cp">#pragma omp parallel for</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Note:  The variable tmp is now mapped with tofrom, for correct</span>
<span class="cm">          execution with 4.5 (and pre-4.5) compliant compilers.</span>
<span class="cm">          See Devices Intro.</span>
<span class="cm"> */</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_data</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">gramSchmidt</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="w">             </span><span class="o">::</span><span class="w">   </span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">,</span><span class="w">  </span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">Q</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">),</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">cols</span><span class="w"></span>
<span class="w">         </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="n">d0</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">rows</span><span class="w"></span>
<span class="w">              </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">))</span><span class="w"></span>
<span class="w">           </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">          </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="n">d0</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">           </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">           </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">rows</span><span class="w"></span>
<span class="w">               </span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">tmp</span><span class="w"></span>
<span class="w">           </span><span class="n">enddo</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">Note</span><span class="o">:</span><span class="w">  </span><span class="n">The</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">tofrom</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">correct</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">(</span><span class="n">and</span><span class="w"> </span><span class="n">pre</span><span class="mf">-4.5</span><span class="p">)</span><span class="w"> </span><span class="n">compliant</span><span class="w"> </span><span class="n">compilers</span><span class="p">.</span><span class="w"> </span><span class="n">See</span><span class="w"> </span><span class="n">Devices</span><span class="w"> </span><span class="n">Intro</span><span class="p">.</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-data-construct-with-orphaned-call">
<h3><strong>target</strong> <strong>data</strong> Construct with Orphaned Call<a class="headerlink" href="#target-data-construct-with-orphaned-call" title="Permalink to this headline">#</a></h3>
<p>The following two examples show how the <strong>target</strong> <strong>data</strong> construct  maps variables to a device data environment. The <strong>target</strong> <strong>data</strong>  construct’s device data environment encloses the <strong>target</strong> construct’s device  data environment in the function <strong>vec_mult()</strong>.</p>
<p>When the type of the variable appearing in an array section is pointer, the pointer  variable and the storage location of the corresponding array section are mapped  to the device data environment. The pointer variable is treated as if it had appeared  in a <strong>map</strong> clause with a map-type of <strong>alloc</strong>. The array section’s  storage location is mapped according to the map-type in the <strong>map</strong> clause  (the default map-type is <strong>tofrom</strong>).</p>
<p>The <strong>target</strong> construct’s device data environment inherits the storage locations  of the array sections  <em>v1[0:N]</em> ,  <em>v2[:n]</em> , and  <em>p0[0:N]</em>  from the enclosing <strong>target</strong> <strong>data</strong> construct’s device data environment. Neither initialization nor assignment is performed  for the array sections in the new device data environment.</p>
<p>The pointer variables  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are mapped into the <strong>target</strong> construct’s device  data environment with an implicit map-type of alloc and they are assigned the address  of the storage location associated with their corresponding array sections. Note  that the following pairs of array section storage locations are equivalent ( <em>p0[:N]</em> ,   <em>p1[:N]</em> ), ( <em>v1[:N]</em> , <em>v3[:N]</em> ), and ( <em>v2[:N]</em> , <em>v4[:N]</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_data.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>


<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target data map(to: v1[0:N], v2[:N]) map(from: p0[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v4</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(to: v3[0:N], v4[:N]) map(from: p1[0:N])</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v4</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran code maps the pointers and storage in an identical manner (same extent,  but uses indices from 1 to  <em>N</em> ).</p>
<p>The <strong>target</strong> construct’s device data environment inherits the storage locations  of the arrays  <em>v1</em> ,  <em>v2</em>  and  <em>p0</em>  from the enclosing <strong>target</strong> <strong>data</strong> constructs’s  device data environment. However, in Fortran the associated data of the pointer  is known, and the shape is not required.</p>
<p>The pointer variables  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are mapped into the <strong>target</strong> construct’s  device data environment with an implicit map-type of <strong>alloc</strong> and they are  assigned the address of the storage location associated with their corresponding  array sections. Note that the following pair of array storage locations are equivalent  ( <em>p0</em> , <em>p1</em> ), ( <em>v1</em> , <em>v3</em> ), and ( <em>v2</em> , <em>v4</em> ).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_data</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">mults</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">real</span><span class="p">,</span><span class="n">pointer</span><span class="p">,</span><span class="n">dimension</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"></span>
<span class="n">integer</span><span class="w">                   </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="n">i</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">real</span><span class="p">,</span><span class="n">pointer</span><span class="p">,</span><span class="n">dimension</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="w"></span>
<span class="n">integer</span><span class="w">                   </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="n">i</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">p1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v4</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the following example, the variables  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are references to the pointer  variables  <em>p0</em> ,  <em>v1</em>  and  <em>v2</em>  respectively. The <strong>target</strong> construct’s device data  environment inherits the pointer variables  <em>p0</em> ,  <em>v1</em> , and  <em>v2</em>  from the enclosing <strong>target</strong>  <strong>data</strong> construct’s device data environment. Thus,  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are already  present in the device data environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_data.5</span>
<span class="cm">* type: C++</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target data map(to: v1[0:N], v2[:N]) map(from: p0[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v4</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(to: v3[0:N], v4[:N]) map(from: p1[0:N])</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v4</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the following example, the usual Fortran approach is used for dynamic memory.  The  <em>p0</em> ,  <em>v1</em> , and  <em>v2</em>  arrays are allocated in the main program and passed as references  from one routine to another. In <strong>vec_mult</strong>,  <em>p1</em> ,  <em>v3</em>  and  <em>v4</em>  are references to the   <em>p0</em> ,  <em>v1</em> , and  <em>v2</em>  arrays, respectively. The <strong>target</strong> construct’s device data  environment inherits the arrays  <em>p0</em> ,  <em>v1</em> , and  <em>v2</em>  from the enclosing target data construct’s  device data environment. Thus,  <em>p1</em> ,  <em>v3</em> , and  <em>v4</em>  are already present in the device  data environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_data</span><span class="mf">.5</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">my_mult</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">real</span><span class="p">,</span><span class="n">dimension</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"></span>
<span class="n">integer</span><span class="w">           </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">v3</span><span class="p">,</span><span class="n">v4</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">real</span><span class="p">,</span><span class="n">dimension</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="w"></span>
<span class="n">integer</span><span class="w">           </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">p1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v3</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v4</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">main</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">my_mult</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">1024</span><span class="w"></span>
<span class="n">real</span><span class="p">,</span><span class="n">allocatable</span><span class="p">,</span><span class="w"> </span><span class="n">dimension</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"></span>
<span class="w">   </span><span class="n">allocate</span><span class="p">(</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">deallocate</span><span class="p">(</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-data-construct-with-if-clause">
<h3><strong>target</strong> <strong>data</strong> Construct with <strong>if</strong> Clause<a class="headerlink" href="#target-data-construct-with-if-clause" title="Permalink to this headline">#</a></h3>
<p>The following two examples show how the <strong>target</strong> <strong>data</strong> construct  maps variables to a device data environment.</p>
<p>In the following example, the if clause on the <strong>target</strong> <strong>data</strong> construct  indicates that if the variable  <em>N</em>  is smaller than a given threshold, then the <strong>target</strong>  <strong>data</strong> construct will not create a device data environment.</p>
<p>The <strong>target</strong> constructs enclosed in the <strong>target</strong> <strong>data</strong> region  must also use an <strong>if</strong> clause on the same condition, otherwise the pointer  variable  <em>p</em>  is implicitly mapped with a map-type of <strong>tofrom</strong>, but the storage  location for the array section  <em>p[0:N]</em>  will not be mapped in the device data environments  of the <strong>target</strong> constructs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_data.6</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define THRESHOLD 1000000</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_again</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target data if(N&gt;THRESHOLD) map(from: p[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target if (N&gt;THRESHOLD) map(to: v1[:N], v2[:N])</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">init_again</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target if (N&gt;THRESHOLD) map(to: v1[:N], v2[:N])</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The <strong>if</strong> clauses work the same way for the following Fortran code. The <strong>target</strong>  constructs enclosed in the <strong>target</strong> <strong>data</strong> region should also use  an <strong>if</strong> clause with the same condition, so that the <strong>target</strong> <strong>data</strong>  region and the <strong>target</strong> region are either both created for the device, or  are both ignored.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_data</span><span class="mf">.6</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">THRESHOLD</span><span class="o">=</span><span class="mi">1000000</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="n">THRESHOLD</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="n">THRESHOLD</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">init_again</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="n">THRESHOLD</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>In the following example, when the <strong>if</strong> clause conditional expression on  the <strong>target</strong> construct evaluates to  <em>false</em> , the target region will  execute on the host device. However, the <strong>target</strong> <strong>data</strong> construct  created an enclosing device data environment that mapped  <em>p[0:N]</em>  to a device data  environment on the default device. At the end of the <strong>target</strong> <strong>data</strong>  region the array section  <em>p[0:N]</em>  will be assigned from the device data environment  to the corresponding variable in the data environment of the task that encountered  the <strong>target</strong> <strong>data</strong> construct, resulting in undefined values in  <em>p[0:N]</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_data.7</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define THRESHOLD 1000000</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target data map(from: p[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target if (N&gt;THRESHOLD) map(to: v1[:N], v2[:N])</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="cm">/* UNDEFINED behavior if N&lt;=THRESHOLD */</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The <strong>if</strong> clauses work the same way for the following Fortran code. When  the <strong>if</strong> clause conditional expression on the <strong>target</strong> construct  evaluates to  <em>false</em> , the <strong>target</strong> region will execute on the host  device. However, the <strong>target</strong> <strong>data</strong> construct created an enclosing  device data environment that mapped the  <em>p</em>  array (and  <em>v1</em>  and  <em>v2</em> ) to a device data  environment on the default target device. At the end of the <strong>target</strong> <strong>data</strong>  region the  <em>p</em>  array will be assigned from the device data environment to the corresponding  variable in the data environment of the task that encountered the <strong>target</strong>  <strong>data</strong> construct, resulting in undefined values in  <em>p</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_data</span><span class="mf">.7</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">THRESHOLD</span><span class="o">=</span><span class="mi">1000000</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="n">THRESHOLD</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w">  </span><span class="o">!***</span><span class="w"> </span><span class="n">UNDEFINED</span><span class="w"> </span><span class="n">behavior</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">N</span><span class="o">&lt;=</span><span class="n">THRESHOLD</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="target-enter-data-and-target-exit-data-constructs">
<h2><strong>target</strong> <strong>enter</strong> <strong>data</strong> and <strong>target</strong> <strong>exit</strong> <strong>data</strong> Constructs<a class="headerlink" href="#target-enter-data-and-target-exit-data-constructs" title="Permalink to this headline">#</a></h2>
<p>The structured data construct (<strong>target</strong> <strong>data</strong>) provides persistent data on a device for subsequent <strong>target</strong> constructs as shown in the  <strong>target</strong> <strong>data</strong> examples above. This is accomplished by creating a single <strong>target</strong> <strong>data</strong> region containing <strong>target</strong> constructs.</p>
<p>The unstructured data constructs allow the creation and deletion of data on the device at any appropriate point within the host code, as shown below  with the <strong>target</strong> <strong>enter</strong> <strong>data</strong> and <strong>target</strong> <strong>exit</strong> <strong>data</strong> constructs.</p>
<p>The following C++ code creates/deletes a vector in a constructor/destructor  of a class. The constructor creates a vector with <strong>target</strong> <strong>enter</strong> <strong>data</strong> and uses an <strong>alloc</strong> modifier in the <strong>map</strong> clause to avoid copying values to the device. The destructor deletes the data (<strong>target</strong> <strong>exit</strong> <strong>data</strong>) and uses the <strong>delete</strong> modifier in the <strong>map</strong> clause to avoid copying data back to the host. Note, the stand-alone <strong>target</strong> <strong>enter</strong> <strong>data</strong> occurs  after the host vector is created, and the <strong>target</strong> <strong>exit</strong> <strong>data</strong> construct occurs before the host data is deleted.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:        target_unstructured_data.1</span>
<span class="cm">* type:        C++</span>
<span class="cm">* version:     omp_4.5</span>
<span class="cm">*/</span><span class="w"></span>
<span class="n">class</span><span class="w"> </span><span class="n">Matrix</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">Matrix</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">double</span><span class="p">[</span><span class="n">len</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp target enter data map(alloc:v[0:len])</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="o">~</span><span class="n">Matrix</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// NOTE: delete map type should be used, since the corresponding</span>
<span class="w">    </span><span class="c1">// host data will cease to exist after the deconstructor is called.</span>

<span class="w">    </span><span class="cp">#pragma omp target exit data map(delete:v[0:len])</span>
<span class="w">    </span><span class="n">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>

<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following C code allocates and frees the data member of a Matrix structure. The <strong>init_matrix</strong> function allocates the memory used in the structure and uses the <strong>target</strong> <strong>enter</strong> <strong>data</strong> directive to map it to the target device. The <strong>free_matrix</strong> function removes the mapped array from the target device and then frees the memory on the host.  Note, the stand-alone  <strong>target</strong> <strong>enter</strong> <strong>data</strong> occurs after the host memory is allocated, and the  <strong>target</strong> <strong>exit</strong> <strong>data</strong> construct occurs before the host data is freed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm"> * name:        target_unstructured_data.1</span>
<span class="cm"> * type:        C</span>
<span class="cm"> * version:     omp_4.5</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Matrix</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init_matrix</span><span class="p">(</span><span class="n">Matrix</span><span class="w"> </span><span class="o">*</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">mat</span><span class="o">-&gt;</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">mat</span><span class="o">-&gt;</span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp target enter data map(alloc:mat-&gt;A[:n])</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">free_matrix</span><span class="p">(</span><span class="n">Matrix</span><span class="w"> </span><span class="o">*</span><span class="n">mat</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp target exit data map(delete:mat-&gt;A[:mat-&gt;N])</span>
<span class="w">  </span><span class="n">mat</span><span class="o">-&gt;</span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">mat</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">mat</span><span class="o">-&gt;</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following Fortran code allocates and deallocates a module array.  The <strong>initialize</strong> subroutine allocates the module array and uses the <strong>target</strong> <strong>enter</strong> <strong>data</strong> directive to map it to the target device. The <strong>finalize</strong> subroutine removes the mapped array from the target device and then deallocates the array on the host.  Note, the stand-alone  <strong>target</strong> <strong>enter</strong> <strong>data</strong> occurs after the host memory is allocated, and the  <strong>target</strong> <strong>exit</strong> <strong>data</strong> construct occurs before the host data is deallocated.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w">        </span><span class="n">target_unstructured_data</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w">        </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">     </span><span class="n">omp_4</span><span class="mf">.5</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">example</span><span class="w"></span>
<span class="w">  </span><span class="n">real</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="n">allocatable</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">contains</span><span class="w"></span>
<span class="w">    </span><span class="n">subroutine</span><span class="w"> </span><span class="n">initialize</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"></span>

<span class="w">      </span><span class="n">allocate</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">enter</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">alloc</span><span class="o">:</span><span class="n">A</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">initialize</span><span class="w"></span>

<span class="w">    </span><span class="n">subroutine</span><span class="w"> </span><span class="n">finalize</span><span class="p">()</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">exit</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">delete</span><span class="o">:</span><span class="n">A</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">deallocate</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">finalize</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="n">example</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-update-construct">
<h2><strong>target</strong> <strong>update</strong> Construct<a class="headerlink" href="#target-update-construct" title="Permalink to this headline">#</a></h2>
<section id="simple-target-data-and-target-update-constructs">
<h3>Simple <strong>target</strong> <strong>data</strong> and <strong>target</strong> <strong>update</strong> Constructs<a class="headerlink" href="#simple-target-data-and-target-update-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>update</strong> construct updates  variables in a device data environment.</p>
<p>The <strong>target</strong> <strong>data</strong> construct maps array sections  <em>v1[:N]</em>  and  <em>v2[:N]</em>   (arrays  <em>v1</em>  and  <em>v2</em>  in the Fortran code) into a device data environment.</p>
<p>The task executing on the host device encounters the first <strong>target</strong> region  and waits for the completion of the region.</p>
<p>After the execution of the first <strong>target</strong> region, the task executing on  the host device then assigns new values to  <em>v1[:N]</em>  and  <em>v2[:N]</em>  ( <em>v1</em>  and  <em>v2</em>  arrays  in Fortran code) in the task’s data environment by calling the function <strong>init_again()</strong>.</p>
<p>The <strong>target</strong> <strong>update</strong> construct assigns the new values of  <em>v1</em>  and   <em>v2</em>  from the task’s data environment to the corresponding mapped array sections  in the device data environment of the <strong>target</strong> <strong>data</strong> construct.</p>
<p>The task executing on the host device then encounters the second <strong>target</strong>  region and waits for the completion of the region.</p>
<p>The second <strong>target</strong> region uses the updated values of  <em>v1[:N]</em>  and  <em>v2[:N]</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_update.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_again</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target data map(to: v1[:N], v2[:N]) map(from: p[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">init_again</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target update to(v1[:N], v2[:N])</span>
<span class="w">      </span><span class="cp">#pragma omp target</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_update</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">     </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">init_again</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">to</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-update-construct-with-if-clause">
<h3><strong>target</strong> <strong>update</strong> Construct with <strong>if</strong> Clause<a class="headerlink" href="#target-update-construct-with-if-clause" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>update</strong> construct updates  variables in a device data environment.</p>
<p>The <strong>target</strong> <strong>data</strong> construct maps array sections  <em>v1[:N]</em>  and  <em>v2[:N]</em>   (arrays  <em>v1</em>  and  <em>v2</em>  in the Fortran code) into a device data environment. In between  the two <strong>target</strong> regions, the task executing on the host device conditionally  assigns new values to  <em>v1</em>  and  <em>v2</em>  in the task’s data environment. The function <strong>maybe_init_again()</strong>  returns  <em>true</em>  if new data is written.</p>
<p>When the conditional expression (the return value of <strong>maybe_init_again()</strong>) in the  <strong>if</strong> clause is  <em>true</em> , the <strong>target</strong> <strong>update</strong> construct  assigns the new values of  <em>v1</em>  and  <em>v2</em>  from the task’s data environment to the corresponding  mapped array sections in the <strong>target</strong> <strong>data</strong> construct’s device data  environment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: target_update.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">maybe_init_again</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target data map(to: v1[:N], v2[:N]) map(from: p[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">changed</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybe_init_again</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w">  </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target update if (changed) to(v1[:N])</span>
<span class="w">      </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybe_init_again</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w">  </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp target update if (changed) to(v2[:N])</span>
<span class="w">      </span><span class="cp">#pragma omp target</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">target_update</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">     </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">interface</span><span class="w"></span>
<span class="w">      </span><span class="n">logical</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">maybe_init_again</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">real</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">interface</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">logical</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">changed</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybe_init_again</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">changed</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="p">(</span><span class="n">v1</span><span class="p">(</span><span class="o">:</span><span class="n">N</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybe_init_again</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">changed</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="p">(</span><span class="n">v2</span><span class="p">(</span><span class="o">:</span><span class="n">N</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="declare-target-directive">
<h2>Declare Target Directive<a class="headerlink" href="#declare-target-directive" title="Permalink to this headline">#</a></h2>
<section id="declare-target-directive-for-a-procedure">
<h3>Declare Target Directive for a Procedure<a class="headerlink" href="#declare-target-directive-for-a-procedure" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the declare target directive  is used to indicate that the corresponding call inside a <strong>target</strong> region  is to a <strong>fib</strong> function that can execute on the default target device.</p>
<p>A version of the function is also available on the host device. When the <strong>if</strong>  clause conditional expression on the <strong>target</strong> construct evaluates to  <em>false</em> ,  the <strong>target</strong> region (thus <strong>fib</strong>) will execute on the host device.</p>
<p>For the following C/C++ code the declaration of the function <strong>fib</strong> appears between the  <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong> directives.  In the corresponding Fortran code, the <strong>declare</strong> <strong>target</strong> directive appears at the end of the specification part of the subroutine.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: declare_target.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#pragma omp begin declare target</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">fib</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="cp">#define THRESHOLD 1000000</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">fib_wrapper</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target if(n &gt; THRESHOLD)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran <strong>fib</strong> subroutine contains a <strong>declare</strong> <strong>target</strong> declaration  to indicate to the compiler to create an device executable version of the procedure.  The subroutine name has not been included on the <strong>declare</strong> <strong>target</strong>  directive and is, therefore, implicitly assumed.</p>
<p>The program uses the <strong>module_fib</strong> module, which presents an explicit interface to  the compiler with the <strong>declare</strong> <strong>target</strong> declarations for processing  the <strong>fib</strong> call.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">declare_target</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">module_fib</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="w">   </span><span class="n">subroutine</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">THRESHOLD</span><span class="o">=</span><span class="mi">1000000</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">my_fib</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">module_fib</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">THRESHOLD</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The next Fortran example shows the use of an external subroutine. As the subroutine is neither use associated nor an internal procedure, the <strong>declare</strong> <strong>target</strong> declarations within a external subroutine are unknown to the main program unit;  therefore, a <strong>declare</strong> <strong>target</strong> must be provided within the program scope for the compiler to determine that a target binary should be available.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">declare_target</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">my_fib</span><span class="w"></span>
<span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="n">interface</span><span class="w"></span>
<span class="w">  </span><span class="n">subroutine</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">  </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">fib</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">interface</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">     </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot;hello from fib&quot;</span><span class="w"></span>
<span class="w">     </span><span class="o">!</span><span class="p">...</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-target-directive-for-class-type">
<h3>Declare Target Directive for Class Type<a class="headerlink" href="#declare-target-directive-for-class-type" title="Permalink to this headline">#</a></h3>
<p>The following example shows the use of the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong> pair to designate the beginning and end of the affected declarations, as introduced in OpenMP 5.1. The <strong>begin</strong> <strong>declare</strong> <strong>target</strong> directive was defined to symmetrically complement the terminating (“end’’) directive.</p>
<p>The example also shows 3 different ways to use a declare target directive for a  class and an external member-function definition (for the  <em>XOR1</em> ,  <em>XOR2</em> ,  and  <em>XOR3</em>  classes and definitions for their corresponding  <em>foo</em>  member functions).</p>
<p>For  <em>XOR1</em> , a <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and  <strong>end</strong> <strong>declare</strong> <strong>target</strong> directive enclose both the class and its member function definition. The compiler immediately knows to create a device version of the function for execution in a <strong>target</strong> region.</p>
<p>For  <em>XOR2</em> , the class member function definition is not specified with a declare target directive. An implicit declare target is created for the member function definition. The same applies if this declaration arrangement for the class and function  are included through a header file.</p>
<p>For  <em>XOR3</em> , the class and its member function are not enclosed by <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong> directives, but there is an implicit declare target since the class, its function and the <strong>target</strong> construct are in the same file scope. That is, the class and its function are treated as if delimited by a declare target directive. The same applies if the class and function are included through a header file.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       declare_target.2a</span>
<span class="cm">* type:       C++</span>
<span class="cm">* version:    omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="n">using</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">std</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#pragma omp begin declare target </span><span class="c1">// declare target--class and function</span>
<span class="w">  </span><span class="n">class</span><span class="w"> </span><span class="n">XOR1</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="n">XOR1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">XOR1</span><span class="o">::</span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">^</span><span class="mh">0x01</span><span class="p">;}</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp end declare target</span>

<span class="w">  </span><span class="cp">#pragma omp begin declare target </span><span class="c1">// declare target--class, not function</span>
<span class="w">  </span><span class="n">class</span><span class="w"> </span><span class="n">XOR2</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="n">XOR2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp end declare target</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">XOR2::foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">^</span><span class="mh">0x01</span><span class="p">;}</span><span class="w"></span>

<span class="w">  </span><span class="n">class</span><span class="w"> </span><span class="n">XOR3</span><span class="w">                </span><span class="c1">// declare target--neither class nor function</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="n">XOR3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">XOR3::foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">^</span><span class="mh">0x01</span><span class="p">;}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(){</span><span class="w"></span>

<span class="w">    </span><span class="n">XOR1</span><span class="w"> </span><span class="n">my_XOR1</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">XOR2</span><span class="w"> </span><span class="n">my_XOR2</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">XOR3</span><span class="w"> </span><span class="n">my_XOR3</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">res1</span><span class="p">,</span><span class="w"> </span><span class="n">res2</span><span class="p">,</span><span class="w"> </span><span class="n">res3</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#pragma omp target map(tofrom:res1)</span>
<span class="w">    </span><span class="n">res1</span><span class="o">=</span><span class="n">my_XOR1</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="cp">#pragma omp target map(tofrom:res2)</span>
<span class="w">    </span><span class="n">res2</span><span class="o">=</span><span class="n">my_XOR2</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="cp">#pragma omp target map(tofrom:res3)</span>
<span class="w">    </span><span class="n">res3</span><span class="o">=</span><span class="n">my_XOR3</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">res1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// OUT1: 2</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">res2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// OUT2: 2</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">res3</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// OUT3: 2</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>Often class definitions and their function definitions are included in separate files, as shown in  <em>declare_target.2b_classes.hpp</em>  and  <em>declare_target.2b_functions.cpp</em>  below. In this case, it is necessary to specify in a declare target directive for the classes. However, as long as the  <em>2b_functions.cpp</em>  file includes the corresponding declare target classes, there is no need to specify the functions with a declare target directive. The functions are treated as if they are specified with a declare target directive. Compiling the  <em>declare_target.2b_functions.cpp</em>  and  <em>declare_target.2b_main.cpp</em>  files  separately and linking them, will create appropriate executable device functions for the target device.</p>
<p>\srcnexample[5.1]{declare_target}{2b_classes}{hpp}</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="w"> </span><span class="cp">#pragma omp begin declare target</span>
<span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="n">XOR1</span><span class="w"></span>
<span class="w"> </span><span class="p">{</span><span class="w">    </span>
<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">     </span><span class="n">XOR1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span><span class="w"></span>
<span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w"> </span><span class="cp">#pragma omp end declare target</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* @@name:       declare_target.2b_functions</span>
<span class="cm">* @@type:       C++</span>
<span class="cm">* @@compilable: yes</span>
<span class="cm">* @@linkable:   no</span>
<span class="cm">* @@expect:     failure</span>
<span class="cm">* @@version:    omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;classes.hpp&quot;</span><span class="cp"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">XOR1::foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">^</span><span class="mh">0x01</span><span class="p">;}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       declare_target.2b_main</span>
<span class="cm">* type:       C++</span>
<span class="cm">* version:    omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="n">using</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">std</span><span class="p">;</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;classes.hpp&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(){</span><span class="w"></span>

<span class="w">   </span><span class="n">XOR1</span><span class="w"> </span><span class="n">my_XOR1</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">res1</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target map(from: res1)</span>
<span class="w">   </span><span class="n">res1</span><span class="o">=</span><span class="n">my_XOR1</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">res1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// OUT1: 2</span>
<span class="p">}</span><span class="w"></span>

</pre></div>
</div>
</div>
</div>
<p>The following example shows how the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong>  <strong>declare</strong> <strong>target</strong> directives are used to enclose the declaration  of a variable  <em>varY</em>  with a class type <strong>typeY</strong>.</p>
<p>This example shows pre-OpenMP 5.0 behavior for the  <em>varY.foo()</em>  function call (an error). The member function <strong>typeY::foo()</strong> cannot be accessed on a target device because its  declaration does not appear between <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and  <strong>end</strong> <strong>declare</strong> <strong>target</strong> directives. As of OpenMP 5.0, the function is implicitly declared with a declare target directive  and will successfully execute the function on the device.  See previous examples.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: declare_target.2c</span>
<span class="cm">* type: C++</span>
<span class="cm">* version: omp_5.2</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">typeX</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">class</span><span class="w"> </span><span class="n">typeY</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">public</span><span class="o">:</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">^</span><span class="mh">0x01</span><span class="p">;}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">typeX</span><span class="w"> </span><span class="n">varX</span><span class="p">;</span><span class="w">  </span><span class="c1">// ok</span>
<span class="w">  </span><span class="n">class</span><span class="w"> </span><span class="n">typeY</span><span class="w"> </span><span class="n">varY</span><span class="p">;</span><span class="w"> </span><span class="c1">// ok if varY.foo() not called on target device</span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">varX</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="c1">// ok</span>
<span class="w">      </span><span class="n">varY</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// error foo() is not available on a target device</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-target-directive-for-variables">
<h3>Declare Target Directive for Variables<a class="headerlink" href="#declare-target-directive-for-variables" title="Permalink to this headline">#</a></h3>
<p>The following examples show how the declare target directive is used to indicate that global variables are mapped to the implicit device data environment of each target device.</p>
<p>In the following example, the declarations of the variables  <em>p</em> ,  <em>v1</em> , and  <em>v2</em>  appear  between <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong>  directives indicating that the variables are mapped to the implicit device data  environment of each target device. The <strong>target</strong> <strong>update</strong> directive  is then used to manage the consistency of the variables  <em>p</em> ,  <em>v1</em> , and  <em>v2</em>  between the  data environment of the encountering host device task and the implicit device data  environment of the default target device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: declare_target.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 1000</span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">float</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target update to(v1, v2)</span>
<span class="w">   </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target update from(p)</span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran version of the above C code uses a different syntax. Fortran modules  use a list syntax on the <strong>declare</strong> <strong>target</strong> directive to declare  mapped variables.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">declare_target</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">my_arrays</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="w"></span>
<span class="n">real</span><span class="w">               </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">()</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">my_arrays</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">to</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example also indicates that the function  <em>Pfun()</em>  is available on the  target device, as well as the variable  <em>Q</em> , which is mapped to the implicit device  data environment of each target device. The <strong>target</strong> <strong>update</strong> directive  is then used to manage the consistency of the variable  <em>Q</em>  between the data environment  of the encountering host device task and the implicit device data environment of  the default target device.</p>
<p>In the following example, the function and variable declarations appear between  the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and <strong>end</strong> <strong>declare</strong> <strong>target</strong>  directives.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: declare_target.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 10000</span>

<span class="cp">#pragma omp begin declare target</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="nf">Pfun</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">float</span><span class="w"> </span><span class="nf">accum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp target update to(Q)</span>
<span class="w">    </span><span class="cp">#pragma omp target map(tofrom: tmp)</span>
<span class="w">    </span><span class="cp">#pragma omp parallel for reduction(+:tmp)</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Pfun</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Note:  The variable tmp is now mapped with tofrom, for correct</span>
<span class="cm">          execution with 4.5 (and pre-4.5) compliant compilers.</span>
<span class="cm">          See Devices Intro.</span>
<span class="cm"> */</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran version of the above C code uses a different syntax. In Fortran modules  a list syntax on the <strong>declare</strong> <strong>target</strong> directive is used to declare  mapped variables and procedures. The  <em>N</em>  and  <em>Q</em>  variables are declared as a comma  separated list. When the <strong>declare</strong> <strong>target</strong> directive is used to  declare just the procedure, the procedure name need not be listed – it is implicitly  assumed, as illustrated in the  <em>Pfun()</em>  function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">declare_target</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">my_global_array</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="w"></span>
<span class="n">real</span><span class="w">               </span><span class="o">::</span><span class="w"> </span><span class="n">Q</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="n">function</span><span class="w"> </span><span class="n">Pfun</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">real</span><span class="w">               </span><span class="o">::</span><span class="w"> </span><span class="n">Pfun</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="w"></span>
<span class="w">   </span><span class="n">Pfun</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Q</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">))</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>

<span class="n">function</span><span class="w"> </span><span class="n">accum</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">my_global_array</span><span class="w"></span>
<span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="w">   </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0e0</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Pfun</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">Note</span><span class="o">:</span><span class="w">  </span><span class="n">The</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">tofrom</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">correct</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">(</span><span class="n">and</span><span class="w"> </span><span class="n">pre</span><span class="mf">-4.5</span><span class="p">)</span><span class="w"> </span><span class="n">compliant</span><span class="w"> </span><span class="n">compilers</span><span class="p">.</span><span class="w"> </span><span class="n">See</span><span class="w"> </span><span class="n">Devices</span><span class="w"> </span><span class="n">Intro</span><span class="p">.</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-target-directive-with-declare-simd">
<h3>Declare Target Directive with <strong>declare</strong> <strong>simd</strong><a class="headerlink" href="#declare-target-directive-with-declare-simd" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>begin</strong> <strong>declare</strong> <strong>target</strong> and  <strong>end</strong> <strong>declare</strong> <strong>target</strong> directives are used to indicate that a function  is available on a target device. The <strong>declare</strong> <strong>simd</strong> directive indicates  that there is a SIMD version of the function  <em>P()</em>  that is available on the target  device as well as one that is available on the host device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: declare_target.5</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 10000</span>
<span class="cp">#define M 1024</span>

<span class="cp">#pragma omp begin declare target</span>
<span class="kt">float</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="cp">#pragma omp declare simd uniform(i) linear(k) notinbranch</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">P</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">float</span><span class="w"> </span><span class="nf">accum</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp target map(tofrom: tmp)</span>
<span class="cp">#pragma omp parallel for reduction(+:tmp)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp simd reduction(+:tmp1)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">tmp1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">tmp1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Note:  The variable tmp is now mapped with tofrom, for correct</span>
<span class="cm">          execution with 4.5 (and pre-4.5) compliant compilers.</span>
<span class="cm">          See Devices Intro.</span>
<span class="cm"> */</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran version of the above C code uses a different syntax. Fortran modules  use a list syntax of the <strong>declare</strong> <strong>target</strong> declaration for the mapping.  Here the  <em>N</em>  and  <em>Q</em>  variables are declared in the list form as a comma separated list.  The function declaration does not use a list and implicitly assumes the function  name. In this Fortran example row and column indices are reversed relative to the  C/C++ example, as is usual for codes optimized for memory access.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">declare_target</span><span class="mf">.5</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">my_global_array</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">=</span><span class="mi">1024</span><span class="w"></span>
<span class="n">real</span><span class="w">               </span><span class="o">::</span><span class="w"> </span><span class="n">Q</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="n">function</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">simd</span><span class="w"> </span><span class="n">uniform</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">linear</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">notinbranch</span><span class="w"></span>
<span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">real</span><span class="w">               </span><span class="o">::</span><span class="w"> </span><span class="n">P</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">P</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">))</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>

<span class="n">function</span><span class="w"> </span><span class="n">accum</span><span class="p">()</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">my_global_array</span><span class="w"></span>
<span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">tmp1</span><span class="w"></span>
<span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0e0</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">tmp</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0e0</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">simd</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">tmp1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="w"></span>
<span class="w">         </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tmp1</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">Note</span><span class="o">:</span><span class="w">  </span><span class="n">The</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">tofrom</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">correct</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">(</span><span class="n">and</span><span class="w"> </span><span class="n">pre</span><span class="mf">-4.5</span><span class="p">)</span><span class="w"> </span><span class="n">compliant</span><span class="w"> </span><span class="n">compilers</span><span class="p">.</span><span class="w"> </span><span class="n">See</span><span class="w"> </span><span class="n">Devices</span><span class="w"> </span><span class="n">Intro</span><span class="p">.</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="declare-target-directive-with-link-clause">
<h3>Declare Target Directive with <strong>link</strong> Clause<a class="headerlink" href="#declare-target-directive-with-link-clause" title="Permalink to this headline">#</a></h3>
<p>In the OpenMP 4.5 standard the declare target directive was extended to allow static data to be mapped, <em>when needed</em>, through a <strong>link</strong> clause.</p>
<p>Data storage for items listed in the <strong>link</strong> clause becomes available on the device when it is mapped implicitly or explicitly in a <strong>map</strong> clause, and it persists for the scope of the mapping (as specified by a <strong>target</strong> construct,  a <strong>target</strong> <strong>data</strong> construct, or  <strong>target</strong> <strong>enter/exit</strong> <strong>data</strong> constructs).</p>
<p>Tip: When all the global data items will not fit on a device and are not needed simultaneously, use the <strong>link</strong> clause and map the data only when it is needed.</p>
<p>The following C and Fortran examples show two sets of data (single precision and double precision) that are global on the host for the entire execution on the host; but are only used globally on the device for part of the program execution. The single precision data are allocated and persist only for the first <strong>target</strong> region. Similarly, the double precision data are in scope on the device only for the second <strong>target</strong> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: declare_target.6</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 100000000</span>

<span class="kt">float</span><span class="w">  </span><span class="n">sp</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">sv1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">sv2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">dp</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">dv1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">dv2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="cp">#pragma omp declare target link(sp,sv1,sv2) \</span>
<span class="cp">                           link(dp,dv1,dv2)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">s_init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">d_init</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">s_output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">d_output</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="cp">#pragma omp begin declare target</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">s_vec_mult_accum</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sv1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sv2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">d_vec_mult_accum</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel for</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dv2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">s_init</span><span class="p">(</span><span class="n">sv1</span><span class="p">,</span><span class="w"> </span><span class="n">sv2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(to:sv1,sv2) map(from:sp)</span>
<span class="w">      </span><span class="n">s_vec_mult_accum</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">s_output</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">d_init</span><span class="p">(</span><span class="n">dv1</span><span class="p">,</span><span class="w"> </span><span class="n">dv2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(to:dv1,dv2) map(from:dp)</span>
<span class="w">      </span><span class="n">d_vec_mult_accum</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">d_output</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">declare_target</span><span class="mf">.6</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.5</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">m_dat</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">100000000</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">link</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span><span class="n">sv1</span><span class="p">,</span><span class="n">sv2</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">sp</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">sv1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">sv2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">link</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="n">dv1</span><span class="p">,</span><span class="n">dv2</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">dp</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">dv1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">dv2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="n">contains</span><span class="w"></span>
<span class="w">   </span><span class="n">subroutine</span><span class="w"> </span><span class="n">s_vec_mult_accum</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">        </span><span class="n">sp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sv1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sv2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">s_vec_mult_accum</span><span class="w"></span>

<span class="w">   </span><span class="n">subroutine</span><span class="w"> </span><span class="n">d_vec_mult_accum</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">        </span><span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dv2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="n">m_dat</span><span class="w"></span>

<span class="n">program</span><span class="w"> </span><span class="n">prec_vec_mult</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">m_dat</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">s_init</span><span class="p">(</span><span class="n">sv1</span><span class="p">,</span><span class="w"> </span><span class="n">sv2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="n">sv1</span><span class="p">,</span><span class="n">sv2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="n">sp</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">call</span><span class="w"> </span><span class="n">s_vec_mult_accum</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">s_output</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">d_init</span><span class="p">(</span><span class="n">dv1</span><span class="p">,</span><span class="w"> </span><span class="n">dv2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="n">dv1</span><span class="p">,</span><span class="n">dv2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="n">dp</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">call</span><span class="w"> </span><span class="n">d_vec_mult_accum</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">d_output</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="lambda-expressions">
<h2>Lambda Expressions<a class="headerlink" href="#lambda-expressions" title="Permalink to this headline">#</a></h2>
<p>The following example illustrates the usage of lambda expressions and their corresponding closure objects within a <strong>target</strong> region.</p>
<p>In CASE 1, a lambda expression is defined inside a <strong>target</strong> construct that implicitly maps the structure 	extit{s}. Inside the construct, the lambda captures (by reference) the corresponding <em>s</em>, and the resulting closure object is assigned to <em>lambda1</em>.  When the call operator is invoked on <em>lambda1</em>, the captured reference to <em>s</em> is used in the call.  The modified <em>s</em> is then copied back to the host device on exit from the <strong>target</strong> construct.</p>
<p>In CASE 2, a lambda expression is instead defined before the <strong>target</strong> construct and captures (by copy) the pointer <em>sp</em>. A <strong>target</strong> <strong>data</strong> construct is used to first map the structure, and then the <strong>target</strong> construct implicitly maps the closure object referenced by <em>lambda2</em>, a zero-length array section based on the structure pointer <em>sp</em>, and a zero-length array section based on the captured pointer in the closure object. The implicit maps result in attached pointers to the corresponding structure. The call for <em>lambda2</em> inside the <strong>target</strong> construct will access <em>sp-&gt;a</em> and <em>sp-&gt;b</em> from the corresponding structure.</p>
<p>CASE 3 is similar to CASE 2, except <em>s</em> is instead captured by reference by the lambda expression. As for CASE 2, the structure is first mapped by an enclosing <strong>target</strong> <strong>data</strong> construct, and then the <strong>target</strong> construct implicitly maps <em>s</em> and the closure object referenced by <em>lambda3</em>. The effect of the map is to make the the call for <em>lambda3</em> refer to the corresponding <em>s</em> inside the <strong>target</strong> construct rather than the original <em>s</em>.</p>
<p>In CASE 4, the program defines a static variable <em>ss</em> of the same structure type as <em>s</em>. While the body of the lambda expression refers to <em>ss</em>, it is not captured. In order for <em>lambda4</em> to be callable in the <strong>target</strong> region, the reference to <em>ss</em> should be to a device copy of <em>ss</em> that also has static storage. This is achieved with the use of the <strong>declare</strong> <strong>target</strong> directive.  Inside the <strong>target</strong> construct, all references to <em>ss</em>, including in the <em>lambda4()</em> call, will refer to the corresponding <em>ss</em> that results from the <strong>declare</strong> <strong>target</strong> directive. The <strong>always</strong> modifier is used on the <strong>map</strong> clause to transfer the updated values for the structure back to the host device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name:       lambda_expressions.1</span>
<span class="cm">* type:       C++</span>
<span class="cm">* version:   omp_5.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="n">using</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">std</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="c1">// CASE 1 Lambda defined in target region</span>

<span class="w">   </span><span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">lambda1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">s</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">      </span><span class="n">s</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lambda1</span><span class="p">();</span><span class="w"> </span><span class="c1">// s.a = 3 * 2</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//OUT 6 3</span>

<span class="c1">// CASE 2 Host defined lambda, Capture pointer to s</span>

<span class="w">   </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="n">S</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">sp</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">   </span><span class="c1">// closure object&#39;s sp attaches to corresponding s on target</span>
<span class="w">   </span><span class="c1">// construct</span>
<span class="w">   </span><span class="cp">#pragma omp target data map(sp[0])</span>
<span class="w">   </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lambda2</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//OUT 6 3</span>

<span class="c1">// CASE 3 Host defined lambda, Capture s by reference</span>

<span class="w">   </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">lambda3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">s</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">   </span><span class="c1">// closure object&#39;s s refers to corresponding s in target</span>
<span class="w">   </span><span class="c1">// construct</span>
<span class="w">   </span><span class="cp">#pragma omp target data map(s)</span>
<span class="w">   </span><span class="cp">#pragma omp target</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">s</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lambda3</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//OUT 6 3</span>

<span class="c1">// CASE 4 Host defined lambda, references static variable</span>

<span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">ss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp declare target enter(ss)</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">lambda4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="n">ss</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ss</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target map(always,from:ss)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ss</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">lambda4</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ss</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ss</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">//OUT 6 3</span>

<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="teams-construct-and-related-combined-constructs">
<h2><strong>teams</strong> Construct and Related Combined Constructs<a class="headerlink" href="#teams-construct-and-related-combined-constructs" title="Permalink to this headline">#</a></h2>
<section id="target-and-teams-constructs-with-omp-get-num-teams-and-omp-get-team-num-routines">
<h3><strong>target</strong> and <strong>teams</strong> Constructs with <strong>omp_get_num_teams</strong> and <strong>omp_get_team_num</strong> Routines<a class="headerlink" href="#target-and-teams-constructs-with-omp-get-num-teams-and-omp-get-team-num-routines" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> and <strong>teams</strong> constructs  are used to create a league of thread teams that execute a region. The <strong>teams</strong>  construct creates a league of at most two teams where the primary thread of each  team executes the <strong>teams</strong> region.</p>
<p>The <strong>omp_get_num_teams</strong> routine returns the number of teams executing in a <strong>teams</strong>  region. The <strong>omp_get_team_num</strong> routine returns the team number, which is an integer  between 0 and one less than the value returned by <strong>omp_get_num_teams</strong>. The following  example manually distributes a loop across two teams.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: teams.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">dotprod</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">C</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">sum0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target map(to: B[:N], C[:N]) map(tofrom: sum0, sum1)</span>
<span class="w">   </span><span class="cp">#pragma omp teams num_teams(2)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_num_teams</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_team_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel for reduction(+:sum0)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">sum0</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_team_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma omp parallel for reduction(+:sum1)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">sum1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">sum0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sum1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Note:  The variables sum0,sum1 are now mapped with tofrom, for</span>
<span class="cm">          correct execution with 4.5 (and pre-4.5) compliant compilers.</span>
<span class="cm">          See Devices Intro.</span>
<span class="cm"> */</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">teams</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">function</span><span class="w"> </span><span class="n">dotprod</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="p">,</span><span class="w"> </span><span class="n">ONLY</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">omp_get_num_teams</span><span class="p">,</span><span class="w"> </span><span class="n">omp_get_team_num</span><span class="w"></span>
<span class="w">    </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="n">sum0</span><span class="p">,</span><span class="w"> </span><span class="n">sum1</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">    </span><span class="n">sum0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0e0</span><span class="w"></span>
<span class="w">    </span><span class="n">sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0e0</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">sum0</span><span class="p">,</span><span class="w"> </span><span class="n">sum1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">num_teams</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_num_teams</span><span class="p">()</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="s">&quot;2 teams required&quot;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_team_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">sum0</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="w"></span>
<span class="w">            </span><span class="n">sum0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_team_num</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">sum1</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">if</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">teams</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sum1</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">Note</span><span class="o">:</span><span class="w">  </span><span class="n">The</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">sum0</span><span class="p">,</span><span class="n">sum1</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">tofrom</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">correct</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">(</span><span class="n">and</span><span class="w"> </span><span class="n">pre</span><span class="mf">-4.5</span><span class="p">)</span><span class="w"> </span><span class="n">compliant</span><span class="w"> </span><span class="n">compilers</span><span class="p">.</span><span class="w"> </span><span class="n">See</span><span class="w"> </span><span class="n">Devices</span><span class="w"> </span><span class="n">Intro</span><span class="p">.</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-constructs">
<h3><strong>target</strong>, <strong>teams</strong>, and <strong>distribute</strong> Constructs<a class="headerlink" href="#target-teams-and-distribute-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong>, <strong>teams</strong>, and <strong>distribute</strong>  constructs are used to execute a loop nest in a <strong>target</strong> region. The <strong>teams</strong>  construct creates a league and the primary thread of each team executes the <strong>teams</strong>  region. The <strong>distribute</strong> construct schedules the subsequent loop iterations  across the primary threads of each team.</p>
<p>The number of teams in the league is less than or equal to the variable  <em>num_blocks</em> .  Each team in the league has a number of threads less than or equal to the variable   <em>block_threads</em> . The iterations in the outer loop are distributed among the primary  threads of each team.</p>
<p>When a team’s primary thread encounters the parallel loop construct before the inner  loop, the other threads in its team are activated. The team executes the <strong>parallel</strong>  region and then workshares the execution of the loop.</p>
<p><strong>reduction clause <strong>reduction</strong> clause!on teams construct on <strong>teams</strong> construct</strong> Each primary thread executing the <strong>teams</strong> region has a private copy of the  variable  <em>sum</em>  that is created by the <strong>reduction</strong> clause on the <strong>teams</strong> construct.  The primary thread and all threads in its team have a private copy of the variable   <em>sum</em>  that is created by the <strong>reduction</strong> clause on the parallel loop construct.  The second private  <em>sum</em>  is reduced into the primary thread’s private copy of  <em>sum</em>   created by the <strong>teams</strong> construct. At the end of the <strong>teams</strong> region,  each primary thread’s private copy of  <em>sum</em>  is reduced into the final  <em>sum</em>  that is  implicitly mapped into the <strong>target</strong> region.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: teams.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define min(x, y) (((x) &lt; (y)) ? (x) : (y))</span>

<span class="kt">float</span><span class="w"> </span><span class="nf">dotprod</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">C</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">block_size</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">num_teams</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">block_threads</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp target map(to: B[0:N], C[0:N]) map(tofrom: sum)</span>
<span class="w">    </span><span class="cp">#pragma omp teams num_teams(num_teams) thread_limit(block_threads) \</span>
<span class="cp">      reduction(+:sum)</span>
<span class="w">    </span><span class="cp">#pragma omp distribute</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i0</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i0</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i0</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block_size</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="cp">#pragma omp parallel for reduction(+:sum)</span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">i0</span><span class="o">+</span><span class="n">block_size</span><span class="p">,</span><span class="n">N</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cm">/* Note:  The variable sum is now mapped with tofrom, for correct</span>
<span class="cm">   execution with 4.5 (and pre-4.5) compliant compilers. See</span>
<span class="cm">   Devices Intro.</span>
<span class="cm"> */</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">teams</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">function</span><span class="w"> </span><span class="n">dotprod</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">block_size</span><span class="p">,</span><span class="w"> </span><span class="n">num_teams</span><span class="p">,</span><span class="w"> </span><span class="n">block_threads</span><span class="p">)</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">    </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">sum</span><span class="w"></span>
<span class="w">    </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">block_size</span><span class="p">,</span><span class="w"> </span><span class="n">num_teams</span><span class="p">,</span><span class="w"> </span><span class="n">block_threads</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i0</span><span class="w"></span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0e0</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">num_teams</span><span class="p">(</span><span class="n">num_teams</span><span class="p">)</span><span class="w"> </span><span class="n">thread_limit</span><span class="p">(</span><span class="n">block_threads</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">  </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">distribute</span><span class="w"></span>
<span class="w">       </span><span class="k">do</span><span class="w"> </span><span class="n">i0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">block_size</span><span class="w"></span>
<span class="w">          </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i0</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">i0</span><span class="o">+</span><span class="n">block_size</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">       </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">teams</span><span class="w"></span>
<span class="w">    </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">Note</span><span class="o">:</span><span class="w">  </span><span class="n">The</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">tofrom</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">correct</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">(</span><span class="n">and</span><span class="w"> </span><span class="n">pre</span><span class="mf">-4.5</span><span class="p">)</span><span class="w"> </span><span class="n">compliant</span><span class="w"> </span><span class="n">compilers</span><span class="p">.</span><span class="w"> </span><span class="n">See</span><span class="w"> </span><span class="n">Devices</span><span class="w"> </span><span class="n">Intro</span><span class="p">.</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-parallel-loop-constructs">
<h3><strong>target</strong> <strong>teams</strong>, and Distribute Parallel Loop Constructs<a class="headerlink" href="#target-teams-and-distribute-parallel-loop-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>teams</strong> and distribute  parallel loop constructs are used to execute a <strong>target</strong> region. The <strong>target</strong>  <strong>teams</strong> construct creates a league of teams where the primary thread of each  team executes the <strong>teams</strong> region.</p>
<p>The distribute parallel loop construct schedules the loop iterations across the  primary threads of each team and then across the threads of each team.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: teams.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.5</span>
<span class="cm">*/</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">dotprod</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">C</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target teams map(to: B[0:N], C[0:N]) \</span>
<span class="cp">                            defaultmap(tofrom:scalar) reduction(+:sum)</span>
<span class="w">   </span><span class="cp">#pragma omp distribute parallel for reduction(+:sum)</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Note:  The variable sum is now mapped with tofrom from the defaultmap</span>
<span class="cm">          clause on the combined target teams construct, for correct</span>
<span class="cm">          execution with 4.5 (and pre-4.5) compliant compilers.</span>
<span class="cm">          See Devices Intro.</span>
<span class="cm"> */</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">teams</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.5</span><span class="w"></span>
<span class="n">function</span><span class="w"> </span><span class="n">dotprod</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">sum</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0e0</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w">  </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">             </span><span class="n">defaultmap</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">distribute</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">         </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">Note</span><span class="o">:</span><span class="w">  </span><span class="n">The</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">tofrom</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">defaultmap</span><span class="w"></span>
<span class="o">!</span><span class="w">  </span><span class="n">clause</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">combined</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">construct</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">correct</span><span class="w"></span>
<span class="o">!</span><span class="w">  </span><span class="n">execution</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">(</span><span class="n">and</span><span class="w"> </span><span class="n">pre</span><span class="mf">-4.5</span><span class="p">)</span><span class="w"> </span><span class="n">compliant</span><span class="w"> </span><span class="n">compilers</span><span class="p">.</span><span class="w"> </span><span class="n">See</span><span class="w"> </span><span class="n">Devices</span><span class="w"> </span><span class="n">Intro</span><span class="p">.</span><span class="w"></span>

</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-parallel-loop-constructs-with-scheduling-clauses">
<h3><strong>target</strong> <strong>teams</strong> and Distribute Parallel Loop  Constructs with Scheduling Clauses<a class="headerlink" href="#target-teams-and-distribute-parallel-loop-constructs-with-scheduling-clauses" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>teams</strong> and distribute  parallel loop constructs are used to execute a <strong>target</strong> region. The <strong>teams</strong>  construct creates a league of at most eight teams where the primary thread of each  team executes the <strong>teams</strong> region. The number of threads in each team is  less than or equal to 16.</p>
<p>The <strong>distribute</strong> parallel loop construct schedules the subsequent loop iterations  across the primary threads of each team and then across the threads of each team.</p>
<p>The <strong>dist_schedule</strong> clause on the distribute parallel loop construct indicates  that loop iterations are distributed to the primary thread of each team in chunks  of 1024 iterations.</p>
<p>The <strong>schedule</strong> clause indicates that the 1024 iterations distributed to  a primary thread are then assigned to the threads in its associated team in chunks  of 64 iterations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: teams.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#define N 1024*1024</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">dotprod</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">C</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cp">#pragma omp target map(to: B[0:N], C[0:N]) map(tofrom: sum)</span>
<span class="w">    </span><span class="cp">#pragma omp teams num_teams(8) thread_limit(16) reduction(+:sum)</span>
<span class="w">    </span><span class="cp">#pragma omp distribute parallel for reduction(+:sum) \</span>
<span class="cp">                dist_schedule(static, 1024) schedule(static, 64)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* Note:  The variable sum is now mapped with tofrom, for correct</span>
<span class="cm">          execution with 4.5 (and pre-4.5) compliant compilers.</span>
<span class="cm">          See Devices Intro.</span>
<span class="cm"> */</span><span class="w"></span>

</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">teams</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">arrays</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="w"></span>
<span class="n">real</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
<span class="n">function</span><span class="w"> </span><span class="n">dotprod</span><span class="p">()</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">arrays</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">sum</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0e0</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">tofrom</span><span class="o">:</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">num_teams</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="n">thread_limit</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">sum</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">distribute</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">reduction</span><span class="p">(</span><span class="o">+:</span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">  </span><span class="n">dist_schedule</span><span class="p">(</span><span class="k">static</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="n">schedule</span><span class="p">(</span><span class="k">static</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">         </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">teams</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">Note</span><span class="o">:</span><span class="w">  </span><span class="n">The</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">tofrom</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">correct</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">(</span><span class="n">and</span><span class="w"> </span><span class="n">pre</span><span class="mf">-4.5</span><span class="p">)</span><span class="w"> </span><span class="n">compliant</span><span class="w"> </span><span class="n">compilers</span><span class="p">.</span><span class="w"> </span><span class="n">See</span><span class="w"> </span><span class="n">Devices</span><span class="w"> </span><span class="n">Intro</span><span class="p">.</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-simd-constructs">
<h3><strong>target</strong> <strong>teams</strong> and <strong>distribute</strong> <strong>simd</strong> Constructs<a class="headerlink" href="#target-teams-and-distribute-simd-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>teams</strong> and <strong>distribute</strong>  <strong>simd</strong> constructs are used to execute a loop in a <strong>target</strong> region.  The <strong>target</strong> <strong>teams</strong> construct creates a league of teams where the  primary thread of each team executes the <strong>teams</strong> region.</p>
<p>The <strong>distribute</strong> <strong>simd</strong> construct schedules the loop iterations across  the primary thread of each team and then uses SIMD parallelism to execute the iterations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: teams.5</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target teams map(to: v1[0:N], v2[:N]) map(from: p[0:N])</span>
<span class="w">   </span><span class="cp">#pragma omp distribute simd</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">teams</span><span class="mf">.5</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">distribute</span><span class="w"> </span><span class="n">simd</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-teams-and-distribute-parallel-loop-simd-constructs">
<h3><strong>target</strong> <strong>teams</strong> and Distribute Parallel Loop SIMD Constructs<a class="headerlink" href="#target-teams-and-distribute-parallel-loop-simd-constructs" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>target</strong> <strong>teams</strong> and the distribute  parallel loop SIMD constructs are used to execute a loop in a <strong>target</strong> <strong>teams</strong>  region. The <strong>target</strong> <strong>teams</strong> construct creates a league of teams  where the primary thread of each team executes the <strong>teams</strong> region.</p>
<p>The distribute parallel loop SIMD construct schedules the loop iterations across  the primary thread of each team and then across the threads of each team where each  thread uses SIMD parallelism.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: teams.6</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target teams map(to: v1[0:N], v2[:N]) map(from: p[0:N])</span>
<span class="w">   </span><span class="cp">#pragma omp distribute parallel for simd</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">teams</span><span class="mf">.6</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w">  </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">distribute</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">simd</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="asynchronous-target-execution-and-dependences">
<h2>Asynchronous <strong>target</strong> Execution and Dependences<a class="headerlink" href="#asynchronous-target-execution-and-dependences" title="Permalink to this headline">#</a></h2>
<p>Asynchronous execution of a <strong>target</strong> region can be accomplished by creating an explicit task around the <strong>target</strong> region. Examples with explicit tasks are shown at the beginning of this section.</p>
<p>As of OpenMP 4.5 and beyond the <strong>nowait</strong> clause can be used on the <strong>target</strong> directive for asynchronous execution. Examples with  <strong>nowait</strong> clauses follow the explicit <strong>task</strong> examples.</p>
<p>This section also shows the use of <strong>depend</strong> clauses to order  executions through dependences.</p>
<section id="asynchronous-target-with-tasks">
<h3>Asynchronous <strong>target</strong> with Tasks<a class="headerlink" href="#asynchronous-target-with-tasks" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>task</strong> and <strong>target</strong> constructs  are used to execute multiple <strong>target</strong> regions asynchronously. The task that  encounters the <strong>task</strong> construct generates an explicit task that contains  a <strong>target</strong> region. The thread executing the explicit task encounters a task  scheduling point while waiting for the execution of the <strong>target</strong> region  to complete, allowing the thread to switch back to the execution of the encountering  task or one of the previously generated explicit tasks.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: async_target.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#pragma omp begin declare target</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">F</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="cp">#define N 1000000000</span>
<span class="cp">#define CHUNKSZ 1000000</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">Z</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">pipedF</span><span class="p">(){</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">C</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">C</span><span class="o">+=</span><span class="n">CHUNKSZ</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp task shared(Z)</span>
<span class="w">      </span><span class="cp">#pragma omp target map(Z[C:CHUNKSZ])</span>
<span class="w">      </span><span class="cp">#pragma omp parallel for</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">CHUNKSZ</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp taskwait</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran version has an interface block that contains the <strong>declare</strong> <strong>target</strong>.  An identical statement exists in the function declaration (not shown here).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">async_target</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">parameters</span><span class="w"></span>
<span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">1000000000</span><span class="p">,</span><span class="w"> </span><span class="n">CHUNKSZ</span><span class="o">=</span><span class="mi">1000000</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">pipedF</span><span class="p">()</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">parameters</span><span class="p">,</span><span class="w"> </span><span class="n">ONLY</span><span class="o">:</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">CHUNKSZ</span><span class="w"></span>
<span class="n">integer</span><span class="w">            </span><span class="o">::</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="n">real</span><span class="w">               </span><span class="o">::</span><span class="w"> </span><span class="n">z</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="n">interface</span><span class="w"></span>
<span class="w">   </span><span class="n">function</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">     </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">intent</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="n">z</span><span class="w"></span>
<span class="w">     </span><span class="n">real</span><span class="w">             </span><span class="o">::</span><span class="n">F</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">F</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">interface</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="k">do</span><span class="w"> </span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">CHUNKSZ</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">shared</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">C</span><span class="o">:</span><span class="n">C</span><span class="o">+</span><span class="n">CHUNKSZ</span><span class="mi">-1</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">C</span><span class="p">,</span><span class="n">C</span><span class="o">+</span><span class="n">CHUNKSZ</span><span class="mi">-1</span><span class="w"></span>
<span class="w">            </span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">taskwait</span><span class="w"></span>
<span class="w">   </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">pipedF</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following example shows how the <strong>task</strong> and <strong>target</strong> constructs  are used to execute multiple <strong>target</strong> regions asynchronously. The task dependence  ensures that the storage is allocated and initialized on the device before it is  accessed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: async_target.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp task shared(v1, v2) depend(out: v1, v2)</span>
<span class="w">   </span><span class="cp">#pragma omp target device(dev) map(v1, v2)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="c1">// check whether on device dev</span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_is_initial_device</span><span class="p">())</span><span class="w"></span>
<span class="w">   </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="w">       </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span><span class="w"></span>
<span class="w">       </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span><span class="w"></span>
<span class="w">       </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// execute other work asychronously</span>
<span class="w">   </span><span class="cp">#pragma omp task shared(v1, v2, p) depend(in: v1, v2)</span>
<span class="w">   </span><span class="cp">#pragma omp target device(dev) map(to: v1, v2) map(from: p[0:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="c1">// check whether on device dev</span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_is_initial_device</span><span class="p">())</span><span class="w"></span>
<span class="w">   </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="w">       </span><span class="cp">#pragma omp parallel for</span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">       </span><span class="n">free</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">free</span><span class="p">(</span><span class="n">v2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp taskwait</span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The Fortran example below is similar to the C version above. Instead of pointers, though, it uses the convenience of Fortran allocatable arrays on the device. In order to preserve the arrays  allocated on the device across multiple <strong>target</strong> regions, a <strong>target</strong> <strong>data</strong> region  is used in this case.</p>
<p>If there is no shape specified for an allocatable array in a <strong>map</strong> clause, only the array descriptor (also called a dope vector) is mapped. That is, device space is created for the descriptor, and it is initially populated with host values. In this case, the  <em>v1</em>  and  <em>v2</em>  arrays will be in a non-associated state on the device. When space for  <em>v1</em>  and  <em>v2</em>  is allocated on the device in the first <strong>target</strong> region the addresses to the space will be included in their descriptors.</p>
<p>At the end of the first <strong>target</strong> region, the arrays  <em>v1</em>  and  <em>v2</em>  are preserved on the device  for access in the second <strong>target</strong> region. At the end of the second <strong>target</strong> region, the data  in array  <em>p</em>  is copied back, the arrays  <em>v1</em>  and  <em>v2</em>  are not.</p>
<p>A <strong>depend</strong> clause is used in the <strong>task</strong> directive to provide a wait at the beginning of the second  <strong>target</strong> region, to insure that there is no race condition with  <em>v1</em>  and  <em>v2</em>  in the two tasks. It would be noncompliant to use  <em>v1</em>  and/or  <em>v2</em>  in lieu of  <em>N</em>  in the <strong>depend</strong> clauses,  because the use of non-allocated allocatable arrays as list items in a <strong>depend</strong> clause would  lead to unspecified behavior.</p>
<p><strong>Note</strong> - This example is not strictly compliant with the OpenMP 4.5 specification since the allocation status of allocatable arrays  <em>v1</em>  and  <em>v2</em>  is changed inside the <strong>target</strong> region, which is not allowed. (See the restrictions for the <strong>map</strong> clause in the  <em>Data-mapping Attribute Rules and Clauses</em>   section of the specification.) However, the intention is to relax the restrictions on mapping of allocatable variables in the next release of the specification so that the example will be compliant.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">async_target</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w">  </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">idev</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="p">,</span><span class="w"> </span><span class="n">ONLY</span><span class="o">:</span><span class="w"> </span><span class="n">omp_is_initial_device</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">             </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="p">,</span><span class="n">allocatable</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="o">:</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w">  </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">idev</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="n">init</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">shared</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">depend</span><span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="n">idev</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">omp_is_initial_device</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">stop</span><span class="w"> </span><span class="s">&quot;not executing on target device&quot;</span><span class="w"></span>
<span class="w">         </span><span class="n">allocate</span><span class="p">(</span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="w"></span>
<span class="w">         </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w">  </span><span class="o">!</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="n">asychronously</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">shared</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">depend</span><span class="p">(</span><span class="n">in</span><span class="o">:</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="n">idev</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">omp_is_initial_device</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">stop</span><span class="w"> </span><span class="s">&quot;not executing on target device&quot;</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">            </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">               </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="n">deallocate</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">taskwait</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">data</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="nowait-clause-on-target-construct">
<h3><strong>nowait</strong> Clause on <strong>target</strong> Construct<a class="headerlink" href="#nowait-clause-on-target-construct" title="Permalink to this headline">#</a></h3>
<p>The following example shows how to execute code asynchronously on a  device without an explicit task. The <strong>nowait</strong> clause on a <strong>target</strong>  construct allows the thread of the  <em>target task</em>  to perform other work while waiting for the <strong>target</strong> region execution to complete.  Hence, the <strong>target</strong> region can execute asynchronously on the  device (without requiring a host thread to idle while waiting for  the  <em>target task</em>  execution to complete).</p>
<p>In this example the product of two vectors (arrays),  <em>v1</em>  and  <em>v2</em> , is formed. One half of the operations is performed on the device, and the last half on the host, concurrently.</p>
<p>After a team of threads is formed the primary thread generates  the  <em>target task</em>  while the other threads can continue on, without a barrier, to the execution of the host portion of the vector product. The completion of the  <em>target task</em>  (asynchronous target execution) is  guaranteed by the synchronization in the implicit barrier at the end of the  host vector-product worksharing loop region. See the <strong>barrier</strong>  glossary entry in the OpenMP specification for details.</p>
<p>The host loop scheduling is <strong>dynamic</strong>, to balance the host thread executions, since  one thread is being used for offload generation. In the situation where  little time is spent by the  <em>target task</em>  in setting  up and tearing down the target execution, <strong>static</strong> scheduling may be desired.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: async_target.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#define N 1000000      </span><span class="c1">//N must be even</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w">   </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="n">N</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w">   </span><span class="n">chunk</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="n">v2</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="n">vxv</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="cp">#pragma omp masked</span>
<span class="w">      </span><span class="cp">#pragma omp target teams distribute parallel for nowait \</span>
<span class="cp">                                map(to: v1[0:n/2]) \</span>
<span class="cp">                                map(to: v2[0:n/2]) \</span>
<span class="cp">                                map(from: vxv[0:n/2])</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"> </span><span class="n">vxv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="cp">#pragma omp for schedule(dynamic,chunk)</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"> </span><span class="n">vxv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; vxv[0] vxv[n-1] %f %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vxv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">vxv</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">async_target</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.1</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">concurrent_async</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">1000000</span><span class="w">  </span><span class="o">!!</span><span class="n">n</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">even</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w">           </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">chunk</span><span class="o">=</span><span class="mi">1000</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">              </span><span class="o">::</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">v2</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">vxv</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">masked</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">teams</span><span class="w"> </span><span class="n">distribute</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">nowait</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">                    </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="w">   </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">                    </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="w">   </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">                    </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">vxv</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w">    </span><span class="n">vxv</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">masked</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">schedule</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span><span class="n">chunk</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">;</span><span class="w">  </span><span class="n">vxv</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="w">   </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; vxv(1) vxv(n) :&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vxv</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">vxv</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="asynchronous-target-with-nowait-and-depend-clauses">
<h3>Asynchronous <strong>target</strong> with <strong>nowait</strong> and <strong>depend</strong> Clauses<a class="headerlink" href="#asynchronous-target-with-nowait-and-depend-clauses" title="Permalink to this headline">#</a></h3>
<p>More details on dependences can be found in  Section 5.3, Task  Dependences. In this example, there are three flow dependences.  In the first two dependences the target task does not execute until the preceding explicit tasks have finished.   These  dependences are produced by arrays  <em>v1</em>  and  <em>v2</em>   with the <strong>out</strong> dependence type in the first two tasks, and the <strong>in</strong> dependence type in the target task.</p>
<p>The last dependence is produced by array  <em>p</em>   with the <strong>out</strong> dependence type in the target task, and the <strong>in</strong> dependence type in the last task.  The last task does not execute until the target task finishes.</p>
<p>The <strong>nowait</strong> clause on the <strong>target</strong> construct creates a deferrable  <em>target task</em> , allowing the encountering task to continue execution without waiting for the completion of the  <em>target task</em> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: async_target.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.5</span>
<span class="cm">*/</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp parallel num_threads(2)</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">#pragma omp single</span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="cp">#pragma omp task depend(out:v1)</span>
<span class="w">         </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">         </span><span class="cp">#pragma omp task depend(out:v2)</span>
<span class="w">         </span><span class="n">init</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">         </span><span class="cp">#pragma omp target nowait depend(in:v1,v2) depend(out:p) \</span>
<span class="cp">                                      map(to:v1,v2) map( from: p)</span>
<span class="w">         </span><span class="cp">#pragma omp parallel for private(i)</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">         </span><span class="cp">#pragma omp task depend(in:p)</span>
<span class="w">         </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">async_target</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_4</span><span class="mf">.5</span><span class="w"></span>

<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">implicit</span><span class="w"> </span><span class="n">none</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w">           </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="p">,</span><span class="w"> </span><span class="n">allocatable</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="o">:</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="o">:</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">allocate</span><span class="p">(</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="n">num_threads</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">single</span><span class="w"></span>

<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">depend</span><span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="n">v1</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">depend</span><span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">nowait</span><span class="w"> </span><span class="n">depend</span><span class="p">(</span><span class="n">in</span><span class="o">:</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">depend</span><span class="p">(</span><span class="n">out</span><span class="o">:</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="o">&amp;</span><span class="w">                 </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">)</span><span class="w">  </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">            </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>


<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="n">depend</span><span class="p">(</span><span class="n">in</span><span class="o">:</span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">task</span><span class="w"></span>

<span class="w">     </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">single</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">parallel</span><span class="w"></span>

<span class="w">   </span><span class="n">deallocate</span><span class="p">(</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="device-routines">
<h2>Device Routines<a class="headerlink" href="#device-routines" title="Permalink to this headline">#</a></h2>
<section id="omp-is-initial-device-routine">
<h3><strong>omp_is_initial_device</strong> Routine<a class="headerlink" href="#omp-is-initial-device-routine" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>omp_is_initial_device</strong> runtime library routine  can be used to query if a code is executing on the initial host device or on a  target device. The example then sets the number of threads in the <strong>parallel</strong>  region based on where the code is executing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: device.1</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_5.1</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="cp">#pragma omp begin declare target</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">extern</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp end declare target</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_vars</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">init_vars</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target device(42) map(p[:N], v1[:N], v2[:N])</span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">nthreads</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">omp_is_initial_device</span><span class="p">())</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;1024 threads on target device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">nthreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;8 threads on initial device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">nthreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp parallel for private(i) num_threads(nthreads)</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">device</span><span class="mf">.1</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="p">,</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">1024</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="n">module</span><span class="w"> </span><span class="n">vmult</span><span class="w"></span>
<span class="n">contains</span><span class="w"></span>
<span class="w">   </span><span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="p">,</span><span class="w"> </span><span class="n">ONLY</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">omp_is_initial_device</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">nthreads</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(.</span><span class="n">not</span><span class="p">.</span><span class="w"> </span><span class="n">omp_is_initial_device</span><span class="p">())</span><span class="w"> </span><span class="n">then</span><span class="w"></span>
<span class="w">         </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;1024 threads on target device&quot;</span><span class="w"></span>
<span class="w">         </span><span class="n">nthreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">         </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;8 threads on initial device&quot;</span><span class="w"></span>
<span class="w">         </span><span class="n">nthreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="w">      </span><span class="n">endif</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">private</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">num_threads</span><span class="p">(</span><span class="n">nthreads</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="n">vmult</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">prog_vec_mult</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">params</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">vmult</span><span class="w"></span>
<span class="n">real</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">call</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="omp-get-num-devices-routine">
<h3><strong>omp_get_num_devices</strong> Routine<a class="headerlink" href="#omp-get-num-devices-routine" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>omp_get_num_devices</strong> runtime library routine  can be used to determine the number of devices.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: device.2</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vec_mult</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">ndev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_num_devices</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">do_offload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ndev</span><span class="o">&gt;</span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="mi">1000000</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="cp">#pragma omp target if(do_offload) \</span>
<span class="cp">                      map(to: v1[0:N], v2[:N]) \</span>
<span class="cp">                      map(from: p[0:N])</span>
<span class="w">   </span><span class="cp">#pragma omp parallel for if(N&gt;1000) private(i)</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">device</span><span class="mf">.2</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">subroutine</span><span class="w"> </span><span class="n">vec_mult</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="p">,</span><span class="w"> </span><span class="n">ONLY</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">omp_get_num_devices</span><span class="w"></span>
<span class="n">real</span><span class="w">    </span><span class="o">::</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ndev</span><span class="w"></span>
<span class="n">logical</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">do_offload</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">ndev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_num_devices</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="n">do_offload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ndev</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="n">and</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="mi">1000000</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">do_offload</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">from</span><span class="o">:</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">parallel</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">&gt;</span><span class="mi">1000</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w"></span>
<span class="w">         </span><span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">end</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">output</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">subroutine</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="omp-set-default-device-and-omp-get-default-device-routines">
<h3><strong>omp_set_default_device</strong> and  <strong>omp_get_default_device</strong> Routines<a class="headerlink" href="#omp-set-default-device-and-omp-get-default-device-routines" title="Permalink to this headline">#</a></h3>
<p>The following example shows how the <strong>omp_set_default_device</strong> and <strong>omp_get_default_device</strong>  runtime library routines can be used to set the default device and determine the  default device respectively.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: device.3</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.0</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">default_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Default device = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">default_device</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">omp_set_default_device</span><span class="p">(</span><span class="n">default_device</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_default_device</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">default_device</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Default device is still = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">default_device</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">device</span><span class="mf">.3</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w">    </span><span class="n">omp_4</span><span class="mf">.0</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">foo</span><span class="w"></span>
<span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="p">,</span><span class="w"> </span><span class="n">ONLY</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">,</span><span class="w"> </span><span class="n">omp_set_default_device</span><span class="w"></span>
<span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">old_default_device</span><span class="p">,</span><span class="w"> </span><span class="n">new_default_device</span><span class="w"></span>
<span class="w">   </span><span class="n">old_default_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Default device = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">old_default_device</span><span class="w"></span>
<span class="w">   </span><span class="n">new_default_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_default_device</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">omp_set_default_device</span><span class="p">(</span><span class="n">new_default_device</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_default_device</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">old_default_device</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot;Default device is STILL = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">old_default_device</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="device-and-host-memory-association">
<h3>Device and Host Memory Association<a class="headerlink" href="#device-and-host-memory-association" title="Permalink to this headline">#</a></h3>
<p>The association of device memory with host memory
can be established by calling the <strong>omp_target_associate_ptr</strong>
API routine as part of the mapping.
The following example shows the use of this routine
to associate device memory of size <em>CS</em>,
allocated by the <strong>omp_target_alloc</strong> routine and
pointed to by the device pointer <em>dev_ptr</em>,
with a chunk of the host array <em>arr</em> starting at index <em>ioff</em>.
In Fortran, the intrinsic function <strong>c_loc</strong> is called
to obtain the corresponding C pointer (<em>h_ptr</em>) of <em>arr(ioff)</em>
for use in the call to the API routine.</p>
<p>Since the reference count of the resulting mapping is infinite,
it is necessary to use the <strong>target update</strong> directive (or
the <strong>always</strong> modifier in a <strong>map</strong> clause) to accomplish a
data transfer between host and device.
The explicit mapping of the array section <em>arr[ioff:CS]</em>
(or <em>arr(ioff:ioff+CS-1)</em> in Fortran) on the <strong>target</strong>
construct ensures that the allocated and associated device memory is used
when referencing the array <em>arr</em> in the <strong>target</strong> region.
The device pointer <em>dev_ptr</em> cannot be accessed directly
after a call to the <strong>omp_target_associate_ptr</strong> routine.</p>
<p>After the <strong>target</strong> region, the device pointer is disassociated from
the current chunk of the host memory by calling the <strong>omp_target_disassociate_ptr</strong> routine before working on the next chunk.
The device memory is freed by calling the <strong>omp_target_free</strong>
routine at the end.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* @@name:       target_associate_ptr.1</span>
<span class="cm">* @@type:       C</span>
<span class="cm">* @@compilable: yes</span>
<span class="cm">* @@linkable:   yes</span>
<span class="cm">* @@expect:     success</span>
<span class="cm">* @@version:    omp_4.5</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="cp">#define CS 50</span>
<span class="cp">#define N  (CS*2)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Allocate device memory</span>
<span class="w">  </span><span class="n">dev_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">omp_target_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CS</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Loop over chunks</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ioff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ioff</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">ioff</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">CS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Associate device memory with one chunk of host memory</span>
<span class="w">    </span><span class="n">omp_target_associate_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">ioff</span><span class="p">],</span><span class="w"> </span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CS</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;before: arr[%d]=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ioff</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">ioff</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Update the device data</span>
<span class="w">    </span><span class="cp">#pragma omp target update to(arr[ioff:CS]) device(dev)</span>

<span class="w">    </span><span class="c1">// Explicit mapping of arr to make sure that we use the allocated </span>
<span class="w">    </span><span class="c1">// and associated memory.  No host-device data update here.</span>
<span class="w">    </span><span class="cp">#pragma omp target map(tofrom : arr[ioff:CS]) device(dev)</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">CS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">ioff</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Update the host data</span>
<span class="w">    </span><span class="cp">#pragma omp target update from(arr[ioff:CS]) device(dev)</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;after: arr[%d]=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ioff</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">ioff</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Disassociate device pointer from the current chunk of host memory</span>
<span class="w">    </span><span class="c1">// before next use</span>
<span class="w">    </span><span class="n">omp_target_disassociate_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">ioff</span><span class="p">],</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Free device memory</span>
<span class="w">  </span><span class="n">omp_target_free</span><span class="p">(</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cm">/* Outputs:</span>
<span class="cm">  before: arr[0]=0</span>
<span class="cm">  after: arr[0]=1</span>
<span class="cm">  before: arr[50]=50</span>
<span class="cm">  after: arr[50]=51</span>
<span class="cm"> */</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>!!%compiler: gfortran
!!%cflags: -fopenmp

! @@name:       target_associate_ptr.1
! @@type:       F-free
! @@compilable: yes
! @@linkable:   yes
! @@expect:     success
! @@version:    omp_5.1
program target_associate
  use omp_lib
  use, intrinsic :: iso_c_binding
  implicit none

  integer, parameter :: CS = 50
  integer, parameter :: N  = CS*2
  integer, target :: arr(N)
  type(c_ptr) :: h_ptr, dev_ptr
  integer(c_size_t) :: csize, dev_off
  integer(c_int) :: dev
  integer :: i, ioff, s

  do i = 1, N
    arr(i) = i
  end do

  dev = omp_get_default_device()
  csize = c_sizeof(arr(1)) * CS

  ! Allocate device memory
  dev_ptr = omp_target_alloc(csize, dev)
  dev_off = 0

  ! Loop over chunks
  do ioff = 1, N, CS

    ! Associate device memory with one chunk of host memory
    h_ptr = c_loc(arr(ioff))
    s = omp_target_associate_ptr(h_ptr, dev_ptr, csize, dev_off, dev)

    print *, &quot;before: arr(&quot;, ioff, &quot;)=&quot;, arr(ioff)

    ! Update the device data
    !$omp target update to(arr(ioff:ioff+CS-1)) device(dev)

    ! Explicit mapping of arr to make sure that we use the allocated 
    ! and associated memory.  No host-device data update here.
    !$omp target map(tofrom: arr(ioff:ioff+CS-1)) device(dev)
      do i = 0, CS-1
        arr(i+ioff) = arr(i+ioff) + 1
      end do
    !$omp end target

    ! Update the host data
    !$omp target update from(arr(ioff:ioff+CS-1)) device(dev)

    print *, &quot;after: arr(&quot;, ioff, &quot;)=&quot;, arr(ioff)

    ! Disassociate device pointer from the current chunk of host memory
    ! before next use
    s = omp_target_disassociate_ptr(h_ptr, dev)
  end do

  ! Free device memory
  call omp_target_free(dev_ptr, dev)

end
! Outputs:
!  before: arr( 1 )= 1
!  after: arr( 1 )= 2
!  before: arr( 51 )= 51
!  after: arr( 51 )= 52
</pre></div>
</div>
</div>
</div>
</section>
<section id="target-memory-and-device-pointers-routines">
<h3>Target Memory and Device Pointers Routines<a class="headerlink" href="#target-memory-and-device-pointers-routines" title="Permalink to this headline">#</a></h3>
<p>The following example shows how to create space on a device, transfer data to and from that space, and free the space, using API calls. The API calls directly execute allocation, copy and free operations on the device, without invoking any mapping through a <strong>target</strong> directive. The <strong>omp_target_alloc</strong> routine allocates space and returns a device pointer for referencing the space in the <strong>omp_target_memcpy</strong> API routine on the host. The <strong>omp_target_free</strong> routine frees the space on the device.</p>
<p>The example also illustrates how to access that space in a <strong>target</strong> region by exposing the device pointer in an <strong>is_device_ptr</strong> clause.</p>
<p>The example creates an array of cosine values on the default device, to be used on the host device. The function fails if a default device is not available.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//%compiler: clang</span>
<span class="c1">//%cflags: -fopenmp</span>

<span class="cm">/*</span>
<span class="cm">* name: device.4</span>
<span class="cm">* type: C</span>
<span class="cm">* version: omp_4.5</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">get_dev_cos</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mem_dev_cpy</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_initial_device</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">omp_get_num_devices</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; ERROR: No device found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">mem_dev_cpy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">omp_target_alloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">mem_dev_cpy</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; ERROR: No space left on device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">                          </span><span class="cm">/* dst  src */</span><span class="w"></span>
<span class="w">   </span><span class="n">omp_target_memcpy</span><span class="p">(</span><span class="n">mem_dev_cpy</span><span class="p">,</span><span class="w"> </span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="mi">0</span><span class="p">,</span><span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="n">t</span><span class="p">,</span><span class="w">   </span><span class="n">h</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="cp">#pragma omp target is_device_ptr(mem_dev_cpy) device(t)</span>
<span class="w">   </span><span class="cp">#pragma omp teams distribute parallel for</span>
<span class="w">     </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"> </span><span class="n">mem_dev_cpy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="cm">/* init data */</span><span class="w"></span>

<span class="w">                   </span><span class="cm">/* dst  src */</span><span class="w"></span>
<span class="w">    </span><span class="n">omp_target_memcpy</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">mem_dev_cpy</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="mi">0</span><span class="p">,</span><span class="w">             </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">h</span><span class="p">,</span><span class="w">             </span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">omp_target_free</span><span class="p">(</span><span class="n">mem_dev_cpy</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The following Fortran example illustrates how to use the <strong>omp_target_alloc</strong> and <strong>omp_target_memcpy</strong> functions to directly allocate device storage and transfer data to and from a device. It also shows how to check for the presence of device data with the <strong>omp_target_is_present</strong> function and to associate host and device storage with the <strong>omp_target_associate_ptr</strong> function.</p>
<p>In Section 1 of the code, 40 bytes of storage are allocated on the default device with the <strong>omp_target_alloc</strong> function, which returns a value (of type  <strong>C_PTR</strong> ) that contains the device address of the storage. In the subsequent <strong>target</strong> construct,  <strong>cp</strong>  is specified on the <strong>is_device_ptr</strong> clause to instruct the compiler that  <strong>cp</strong>  is a device pointer. The device pointer ( <strong>cp</strong> ) is then associated with the Fortran pointer ( <strong>fp</strong> ) via the  <strong>c_f_pointer</strong>  routine inside the <strong>target</strong> construct. As a result,  <strong>fp</strong>  points to the storage on the device that is allocated by the <strong>omp_target_alloc</strong> routine. In the <strong>target</strong> region, the value 4 is assigned to the storage on the device, using the Fortran pointer. A trivial test checks that all values were correctly assigned. The Fortran pointer ( <strong>fp</strong> ) is nullified before the end of the <strong>target</strong> region. After the <strong>target</strong> construct, the space on the device is freed with the <strong>omp_target_free</strong> function, using the device  <strong>cp</strong>  pointer which is set to null after the call.</p>
<p>In Section 2, the content of the storage allocated on the host is directly copied to the OpenMP allocated storage on the device. First, storage is allocated for the device and host using <strong>omp_target_alloc</strong>. Next, on the host the device pointer, returned from the allocation <strong>omp_target_alloc</strong> function, is associated with a Fortran pointer, and values are assigned to the storage. Similarly, values are assigned on the device to the device storage, after associating a Fortran pointer ( <strong>fp_dst</strong> ) with the device’s storage pointer ( <strong>cp_dst</strong> ).</p>
<p>Next the <strong>omp_target_memcpy</strong> function directly copies the host data to the device storage, specified by the respective host and device pointers. This copy will overwrite -1 values in the device storage, and is checked in the next <strong>target</strong> construct. Keyword arguments are used here for clarity. (A positional argument list is used in the next Section.)</p>
<p>In Section 3, space is allocated (with a Fortran ALLOCATE statement) and initialized using a host Fortran pointer ( <strong>h_fp</strong> ), and the address of the storage is directly assigned to a host C pointer ( <strong>h_cp</strong> ). The following <strong>omp_target_is_present</strong> function returns  <strong>0</strong>  (false, of integer(C_INT) type) to indicate that  <strong>h_cp</strong>  does not have any corresponding storage on the default device.</p>
<p>Next, the same amount of space is allocated on the default device with the <strong>omp_target_alloc</strong> function, which returns a device pointer ( <strong>d_cp</strong> ). The device pointer  <strong>d_cp</strong>  and host pointer  <strong>h_cp</strong>  are then associated using the <strong>omp_target_associate_ptr</strong> function. The device storage to which  <strong>d_cp</strong>  points becomes the corresponding storage of the host storage to which  <strong>h_cp</strong>  points. The following <strong>omp_target_is_present</strong> call confirms this, by returning a non-zero value of integer(C_INT) type for true.</p>
<p>After the association, the content of the  host storage is copied to the device using the <strong>omp_target_memcpy</strong> function. In the final <strong>target</strong> construct an array section of  <strong>h_fp</strong>   is mapped to the device, and evaluated for correctness. The mapping establishes a connection of  <strong>h_fp</strong>  with the corresponding device data in the <strong>target</strong> construct, but does not produce an update on the device because the previous <strong>omp_target_associate_ptr</strong> routine sets the  reference count of the mapped object to infinity, meaning a mapping  without the <strong>always</strong> modifier will not  update the device object.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">!!%</span><span class="n">compiler</span><span class="o">:</span><span class="w"> </span><span class="n">gfortran</span><span class="w"></span>
<span class="o">!!%</span><span class="n">cflags</span><span class="o">:</span><span class="w"> </span><span class="o">-</span><span class="n">fopenmp</span><span class="w"></span>

<span class="o">!</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">device</span><span class="mf">.4</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="o">-</span><span class="n">free</span><span class="w"></span>
<span class="o">!</span><span class="w"> </span><span class="n">version</span><span class="o">:</span><span class="w"> </span><span class="n">omp_5</span><span class="mf">.0</span><span class="w"></span>
<span class="n">program</span><span class="w"> </span><span class="n">device_mem</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">omp_lib</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="p">,</span><span class="w"> </span><span class="n">intrinsic</span><span class="w">            </span><span class="o">::</span><span class="w"> </span><span class="n">iso_c_binding</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="n">parameter</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="p">(</span><span class="n">c_ptr</span><span class="p">)</span><span class="w">               </span><span class="o">::</span><span class="w"> </span><span class="n">cp</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span><span class="w"> </span><span class="n">pointer</span><span class="w">   </span><span class="o">::</span><span class="w"> </span><span class="n">fp</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span><span class="w">            </span><span class="o">::</span><span class="w"> </span><span class="n">rc</span><span class="p">,</span><span class="w"> </span><span class="n">host_dev</span><span class="p">,</span><span class="w"> </span><span class="n">targ_dev</span><span class="w"></span>
<span class="w">  </span><span class="n">integer</span><span class="p">(</span><span class="n">c_size_t</span><span class="p">)</span><span class="w">         </span><span class="o">::</span><span class="w"> </span><span class="n">int_bytes</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">fp_src</span><span class="p">(</span><span class="o">:</span><span class="p">),</span><span class="w"> </span><span class="n">fp_dst</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w">    </span><span class="o">!</span><span class="w"> </span><span class="n">Section</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">vars</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="p">(</span><span class="n">c_ptr</span><span class="p">)</span><span class="w">       </span><span class="o">::</span><span class="w"> </span><span class="n">cp_src</span><span class="p">,</span><span class="w">    </span><span class="n">cp_dst</span><span class="w">       </span><span class="o">!</span><span class="w"> </span><span class="n">Section</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">vars</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="n">h_fp</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w">                 </span><span class="o">!</span><span class="w"> </span><span class="n">Section</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">vars</span><span class="w"></span>
<span class="w">  </span><span class="n">type</span><span class="p">(</span><span class="n">c_ptr</span><span class="p">)</span><span class="w">       </span><span class="o">::</span><span class="w"> </span><span class="n">h_cp</span><span class="p">,</span><span class="w">    </span><span class="n">d_cp</span><span class="w">           </span><span class="o">!</span><span class="w"> </span><span class="n">Section</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">vars</span><span class="w"></span>

<span class="w">  </span><span class="n">integer</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">i</span><span class="w"></span>

<span class="w">  </span><span class="n">host_dev</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_initial_device</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">targ_dev</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_default_device</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">int_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C_SIZEOF</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span><span class="w"></span>

<span class="o">!------------------------------------------------</span><span class="n">Section</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">vv</span><span class="o">-----------</span><span class="w"></span>
<span class="w">  </span><span class="n">cp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_alloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">int_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">targ_dev</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">is_device_ptr</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="n">targ_dev</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="n">fp</span><span class="w"> </span><span class="n">implicit</span><span class="w"> </span><span class="n">map</span><span class="w"></span>
<span class="w">     </span><span class="n">call</span><span class="w"> </span><span class="n">c_f_pointer</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="w"> </span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="p">])</span><span class="w">              </span><span class="o">!</span><span class="n">fp</span><span class="w"> </span><span class="n">becomes</span><span class="w"> </span><span class="n">associated</span><span class="w"></span>
<span class="w">     </span><span class="n">fp</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">all</span><span class="p">(</span><span class="n">fp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot;PASSED 1 of 5&quot;</span><span class="w"></span>
<span class="w">     </span><span class="n">nullify</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="w">                   </span><span class="o">!</span><span class="n">fp</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">returned</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">disassociated</span><span class="w"></span>
<span class="w">  </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">  </span><span class="n">call</span><span class="w"> </span><span class="n">omp_target_free</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="w"> </span><span class="n">targ_dev</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_null_ptr</span><span class="w"></span>

<span class="o">!------------------------------------------------</span><span class="n">Section</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">vv</span><span class="o">-----------</span><span class="w"></span>

<span class="w">   </span><span class="n">cp_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_alloc</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">int_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">host_dev</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">cp_dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_alloc</span><span class="p">(</span><span class="w">  </span><span class="n">N</span><span class="w">  </span><span class="o">*</span><span class="n">int_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">targ_dev</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="w">           </span><span class="n">Initialize</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">c_f_pointer</span><span class="p">(</span><span class="n">cp_src</span><span class="p">,</span><span class="w"> </span><span class="n">fp_src</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"></span>
<span class="w">   </span><span class="n">fp_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="n">targ_dev</span><span class="p">)</span><span class="w"> </span><span class="n">is_device_ptr</span><span class="p">(</span><span class="n">cp_dst</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">call</span><span class="w"> </span><span class="n">c_f_pointer</span><span class="p">(</span><span class="n">cp_dst</span><span class="p">,</span><span class="w"> </span><span class="n">fp_dst</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w">   </span><span class="o">!</span><span class="w"> </span><span class="n">fp_dst</span><span class="w"> </span><span class="n">becomes</span><span class="w"> </span><span class="n">associated</span><span class="w"></span>
<span class="w">     </span><span class="n">fp_dst</span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="w">                          </span><span class="o">!</span><span class="w"> </span><span class="n">Initial</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">storage</span><span class="w"></span>
<span class="w">     </span><span class="n">nullify</span><span class="p">(</span><span class="n">fp_dst</span><span class="p">)</span><span class="w">                         </span><span class="o">!</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">disassociated</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="o">!</span><span class="w">  </span><span class="n">Copy</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="p">(</span><span class="n">dst</span><span class="p">)</span><span class="w"> </span><span class="n">array</span><span class="w"></span>
<span class="w">   </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_memcpy</span><span class="p">(</span><span class="w">                                             </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">dst</span><span class="o">=</span><span class="n">cp_dst</span><span class="p">,</span><span class="w">             </span><span class="n">src</span><span class="o">=</span><span class="n">cp_src</span><span class="p">,</span><span class="w">    </span><span class="n">length</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">int_bytes</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">dst_offset</span><span class="o">=</span><span class="mi">0</span><span class="n">_c_size_t</span><span class="p">,</span><span class="w">  </span><span class="n">src_offset</span><span class="o">=</span><span class="n">int_bytes</span><span class="p">,</span><span class="w">              </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="n">dst_device_num</span><span class="o">=</span><span class="n">targ_dev</span><span class="p">,</span><span class="n">src_device_num</span><span class="o">=</span><span class="n">host_dev</span><span class="p">)</span><span class="w"></span>

<span class="o">!</span><span class="w">  </span><span class="n">Check</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">device</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="n">targ_dev</span><span class="p">)</span><span class="w"> </span><span class="n">is_device_ptr</span><span class="p">(</span><span class="n">cp_dst</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="n">call</span><span class="w"> </span><span class="n">c_f_pointer</span><span class="p">(</span><span class="n">cp_dst</span><span class="p">,</span><span class="w"> </span><span class="n">fp_dst</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="p">])</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">all</span><span class="p">(</span><span class="n">fp_dst</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)])</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot;PASSED 2 of 5&quot;</span><span class="w"></span>
<span class="w">     </span><span class="n">nullify</span><span class="p">(</span><span class="n">fp_dst</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="o">!------------------------------------------------</span><span class="n">Section</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">vv</span><span class="o">-----------</span><span class="w"></span>

<span class="w">   </span><span class="o">!</span><span class="n">allocate</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">initialize</span><span class="p">.</span><span class="w"></span>
<span class="w">   </span><span class="n">allocate</span><span class="p">(</span><span class="n">h_fp</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">source</span><span class="o">=</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)])</span><span class="w"></span>

<span class="w">   </span><span class="n">h_cp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_loc</span><span class="p">(</span><span class="n">h_fp</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="o">!</span><span class="w"> </span><span class="n">Device</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">aware</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">allocation</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">host</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">omp_target_is_present</span><span class="p">(</span><span class="n">h_cp</span><span class="p">,</span><span class="w"> </span><span class="n">targ_dev</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PASSED 3 of 5&quot;</span><span class="w"></span>

<span class="w">             </span><span class="o">!</span><span class="w"> </span><span class="n">Allocate</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">memory</span><span class="w"></span>
<span class="w">   </span><span class="n">d_cp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_target_alloc</span><span class="p">(</span><span class="n">c_sizeof</span><span class="p">(</span><span class="n">h_fp</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">size</span><span class="p">(</span><span class="n">h_fp</span><span class="p">),</span><span class="w"> </span><span class="n">targ_dev</span><span class="p">)</span><span class="w"></span>

<span class="w">             </span><span class="o">!</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">associate</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">storage</span><span class="w"></span>
<span class="w">   </span><span class="n">rc</span><span class="o">=</span><span class="n">omp_target_associate_ptr</span><span class="p">(</span><span class="n">h_cp</span><span class="p">,</span><span class="n">d_cp</span><span class="p">,</span><span class="n">c_sizeof</span><span class="p">(</span><span class="n">h_fp</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">size</span><span class="p">(</span><span class="n">h_fp</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">                               </span><span class="mi">0</span><span class="n">_c_size_t</span><span class="p">,</span><span class="n">targ_dev</span><span class="p">)</span><span class="w"></span>

<span class="w">             </span><span class="o">!</span><span class="w"> </span><span class="n">check</span><span class="w"> </span><span class="n">presence</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="n">pointer</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">omp_target_is_present</span><span class="p">(</span><span class="n">h_cp</span><span class="p">,</span><span class="w"> </span><span class="n">targ_dev</span><span class="p">)</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="s">&quot;PASSED 4 of 5&quot;</span><span class="w"></span>

<span class="w">             </span><span class="o">!</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">host</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">via</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">pointers</span><span class="w"></span>
<span class="w">   </span><span class="n">rc</span><span class="o">=</span><span class="n">omp_target_memcpy</span><span class="p">(</span><span class="n">d_cp</span><span class="p">,</span><span class="w">       </span><span class="n">h_cp</span><span class="p">,</span><span class="n">c_sizeof</span><span class="p">(</span><span class="n">h_fp</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">size</span><span class="p">(</span><span class="n">h_fp</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">                        </span><span class="mi">0</span><span class="n">_c_size_t</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="n">_c_size_t</span><span class="p">,</span><span class="w">                        </span><span class="o">&amp;</span><span class="w"></span>
<span class="w">                        </span><span class="n">targ_dev</span><span class="p">,</span><span class="w">   </span><span class="n">host_dev</span><span class="p">)</span><span class="w"></span>

<span class="w">             </span><span class="o">!</span><span class="w"> </span><span class="n">validate</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">region</span><span class="w"></span>
<span class="w">             </span><span class="o">!</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="n">since</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">infinity</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">device</span><span class="p">(</span><span class="n">targ_dev</span><span class="p">)</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">h_fp</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">all</span><span class="p">(</span><span class="n">h_fp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)])</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">print</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PASSED 5 of 5&quot;</span><span class="w"></span>
<span class="w">   </span><span class="o">!</span><span class="n">$omp</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">target</span><span class="w"></span>

<span class="w">   </span><span class="n">call</span><span class="w"> </span><span class="n">omp_target_free</span><span class="p">(</span><span class="n">d_cp</span><span class="p">,</span><span class="n">targ_dev</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">deallocate</span><span class="p">(</span><span class="n">h_fp</span><span class="p">)</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">program</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "native"
        },
        kernelOptions: {
            kernelName: "native",
            path: "./contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'native'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="Chap_tasking.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Tasking</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="Chap_SIMD.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">SIMD</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The OpenMP Community<br/>
  
      &copy; <a href="../copyright.html">Copyright</a> 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>